import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r,o as h,c as p,b as s,d as n,a as e,w as i,e as l}from"./app-DXKPJHsU.js";const c="/assets/MySQL%E7%B4%A2%E5%BC%95-D8MYfTYW.png",g="/assets/image-Cw4ydfty.png",d="/assets/image-1-CJ3PXNns.png",m="/assets/image-2-ChflzHgU.png",_="/assets/image-3-RXpa0Qg3.png",u="/assets/image-4-BLuUMZWw.png",b="/assets/image-5-D2sSKav4.png",y="/assets/image-6-BvS33RRn.png",k="/assets/image-7-gDztlaZx.png",f="/assets/image-8-DRnAYYH3.png",B={},v=l('<p>描述MySQL的索引结构、创建原则、优化实践经验</p><h2 id="零、mysql索引思维导图" tabindex="-1"><a class="header-anchor" href="#零、mysql索引思维导图"><span>零、MySQL索引思维导图</span></a></h2><figure><img src="'+c+'" alt="" tabindex="0"><figcaption></figcaption></figure><h2 id="一、基础概念" tabindex="-1"><a class="header-anchor" href="#一、基础概念"><span>一、基础概念</span></a></h2>',4),D=l("<li><strong>操作系统-页(Page)</strong>: 操作系统会将 <strong>物理/虚拟内存</strong> 分割成大小相等的 <strong>页(Page)</strong>，用于内存管理和分配。常见页(Page)大小通常为4KB、8KB等。</li><li><strong>MySQL-页(Page)</strong>: MySQL中的页通常指的是InnoDB存储引擎中的<strong>数据页</strong>，每个数据页中包含多条 <strong>行记录</strong>。常见页(Page)大小为16KB。</li><li><strong>局部性原理</strong>: 程序在访问某个数据/指令时，很可能会紧接着访问相邻的数据/指令。</li><li><strong>预读</strong>: 根据&quot;<strong>局部性原理</strong>&quot;，操作系统常会在进行磁盘IO时，会进行&quot;<strong>预读</strong>&quot;；即1次磁盘IO操作不光会读取请求的目标数据块(block0)到内存，还会读取与目标数据块相邻的数据块(block1、block2)到内存，以提升数据访问效率。</li>",4),x=s("strong",null,"磁盘&内存IO速度差异",-1),A=s("strong",null,"访问磁盘的IO成本是访问内存的十万倍左右",-1),M=l(`<h2 id="二、索引分类" tabindex="-1"><a class="header-anchor" href="#二、索引分类"><span>二、索引分类</span></a></h2><h3 id="_2-1、按-存储类型-划分" tabindex="-1"><a class="header-anchor" href="#_2-1、按-存储类型-划分"><span>2.1、按 <strong>存储类型</strong> 划分</span></a></h3><p>InnoDB中B+树索引可以分为<strong>聚集索引</strong> 和 <strong>辅助索引</strong>，区别在于 <strong>叶子结点存储的是否是完整的行记录</strong>。</p><ol><li>主键索引(<strong>聚集索引</strong>)<br> 聚集索引 按照表的 <strong>主键(PK)</strong> 构造一棵B+树，<strong>叶子结点</strong> 存储一条完整的行记录，聚集索引的 1个<strong>叶子结点</strong> 就是MySQL的 1个<strong>数据页</strong>；同时，每个 <strong>叶子结点</strong> 之间都通过 <strong>双向链表</strong> 进行连接。<br> 因此，使用主键索引执行 <strong>主键排序</strong> 和 <strong>主键范围查找</strong> 的速度很快。</li><li>二级索引(<strong>辅助索引</strong>)<br> 二级索引 按照 <strong>用户指定列(单/多列)</strong> 构造一棵B+树，叶子结点只存储一条行记录的部分数据(主键(PK) + 用户指定列)，存储引擎会先在辅助索引中定位到具体的叶子结点，然后获取到叶子结点中存储的<strong>主键(PK)<strong>值，最后，再通过</strong>回表</strong>(如有必要)，在<strong>主键索引</strong>获取到一条完整的行记录。</li></ol><h3 id="_2-2、按-功能-划分" tabindex="-1"><a class="header-anchor" href="#_2-2、按-功能-划分"><span>2.2、按 <strong>功能</strong> 划分</span></a></h3><ol><li>普通索引</li><li>唯一索引(unique index)</li><li>复合(联合)索引: 区分度越高的列越应该放在前面，<strong>最左匹配原则(索引创建原则)</strong></li><li>前缀索引</li><li>虚拟列索引</li></ol><h3 id="_2-3、回表-覆盖索引" tabindex="-1"><a class="header-anchor" href="#_2-3、回表-覆盖索引"><span>2.3、回表 &amp; 覆盖索引</span></a></h3><ol><li><strong>回表</strong><br> 指通过辅助索引无法查询到本次要查询的所有字段，则根据辅助索引叶子结点中的主键(PK)值，再到主键索引中进行一次查询，获取到叶子结点的一条完整的行记录。这个操作称为「<strong>回表</strong>」。</li><li><strong>覆盖索引</strong><br> 覆盖索引是一种 <strong>数据查询方式</strong>，不是具体的哪一类索引。若辅助索引中包含本次查询的所有字段，只通过 <strong>辅助索引</strong> 就能拿到结果，而 无需「<strong>回表</strong>」。则称本次查询使用了<strong>覆盖索引</strong>。</li></ol><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="shiki shiki-themes github-light one-dark-pro" style="background-color:#fff;--shiki-dark-bg:#282c34;color:#24292e;--shiki-dark:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#6A737D;--shiki-dark:#7F848E;font-style:inherit;--shiki-dark-font-style:italic;">-- 建立复合索引(name, age)</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#C678DD;">CREATE</span><span style="color:#D73A49;--shiki-dark:#C678DD;"> INDEX</span><span style="color:#6F42C1;--shiki-dark:#61AFEF;"> idx_name_age</span><span style="color:#D73A49;--shiki-dark:#C678DD;"> ON</span><span style="color:#24292E;--shiki-dark:#ABB2BF;"> user(username, age);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;--shiki-dark:#7F848E;font-style:inherit;--shiki-dark-font-style:italic;">-- 覆盖索引查询: 要查询的字段均存在于索引树结点的数据项中</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#C678DD;">select</span><span style="color:#24292E;--shiki-dark:#ABB2BF;"> username, age </span><span style="color:#D73A49;--shiki-dark:#C678DD;">from</span><span style="color:#24292E;--shiki-dark:#ABB2BF;"> user </span><span style="color:#D73A49;--shiki-dark:#C678DD;">where</span><span style="color:#24292E;--shiki-dark:#ABB2BF;"> username </span><span style="color:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="color:#032F62;--shiki-dark:#98C379;"> &#39;lihua&#39;</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;--shiki-dark:#7F848E;font-style:inherit;--shiki-dark-font-style:italic;">-- phone_number列值不在 idx_name_age复合索引中, 故需「回表」</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#C678DD;">select</span><span style="color:#24292E;--shiki-dark:#ABB2BF;"> username, age, phone_number </span><span style="color:#D73A49;--shiki-dark:#C678DD;">from</span><span style="color:#24292E;--shiki-dark:#ABB2BF;"> user </span><span style="color:#D73A49;--shiki-dark:#C678DD;">where</span><span style="color:#24292E;--shiki-dark:#ABB2BF;"> username </span><span style="color:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="color:#032F62;--shiki-dark:#98C379;"> &#39;lihua&#39;</span><span style="color:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="三、索引结构" tabindex="-1"><a class="header-anchor" href="#三、索引结构"><span>三、索引结构</span></a></h2><p>下面分析几种索引结构的差异。</p><h3 id="_3-1、hash索引" tabindex="-1"><a class="header-anchor" href="#_3-1、hash索引"><span>3.1、Hash索引</span></a></h3><p>InnoDB中支持的Hash索引是 <strong>自适应的</strong>，InnoDB会根据表的使用情况自动为表生成 <strong>Hash索引</strong>；不能人为干预是否在一张表中生成 <strong>Hash索引</strong>。InnoDB会监控对表上辅助索引的查找，若发现某辅助索引被频繁访问，则辅助索引会成为热🔥数据；并建立哈希索引，提升访问速度。</p><p><strong>特点</strong>:</p><ol><li>无序，无树高</li><li>降低对辅助索引的访问频次</li><li>自适应</li></ol><p><strong>缺点</strong>:</p><ol><li>会占用 InnoDB buffer pool 资源</li><li>仅支持等值查询，<strong>不支持范围查找</strong></li><li>无法用于排序</li><li>有冲突可能</li></ol><h3 id="_3-2、b树索引" tabindex="-1"><a class="header-anchor" href="#_3-2、b树索引"><span>3.2、B树索引</span></a></h3><ol><li>所有键值分布在整个树中</li><li>任何关键字出现且只出现在一个节点中</li><li>搜索有可能在非叶子节点结束</li><li>在关键字全集内做一次查找，性能逼近二分查找算法</li></ol><figure><img src="`+g+'" alt="操作系统页大小=MySQL页大小时的B树" tabindex="0"><figcaption>操作系统页大小=MySQL页大小时的B树</figcaption></figure><p><strong>B+树与B树的不同</strong><br> （1）B+树将完整行记录存储在叶子节点，非叶子节点只存储索引结点数据。<br> （2）B+树的叶子节点之间使用双向链表进行连接。</p><h3 id="_3-3、b-树索引" tabindex="-1"><a class="header-anchor" href="#_3-3、b-树索引"><span>3.3、B+树索引</span></a></h3>',22),S=s("ol",null,[s("li",null,"B+树的每个结点都是1个InnoDB页"),s("li",null,[n("只有叶子结点存储真实数据，非叶子结点存储指针(非真实数据)"),s("br"),n(" 因为1页磁盘块大小固定，因此一旦把真实数据放到非叶子结点，那么树高势必会增加；这也是为什么索引字段应该尽量小的原因")]),s("li",null,[s("strong",null,"1次IO操作"),n(" 读取 "),s("strong",null,"1个B+树结点"),n("(即，"),s("strong",null,"1个操作系统-页(Page)"),n(")")]),s("li",null,[n("IO次数取决于B+树的"),s("strong",null,"高度h"),n("，若当前表的数据大小为"),s("strong",null,"N"),n("，1页磁盘块的数据项的数量为"),s("strong",null,"m"),n("，则 "),s("strong",null,"树高"),n(" 为 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"h"),s("mo",null,"="),s("mi",null,"l"),s("mi",null,"o"),s("msubsup",null,[s("mi",null,"g"),s("mrow",null,[s("mi",null,"m"),s("mo",null,"+"),s("mn",null,"1")]),s("mi",null,"N")])]),s("annotation",{encoding:"application/x-tex"},"h=log_{m+1}^{N}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6944em"}}),s("span",{class:"mord mathnormal"},"h"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1.1478em","vertical-align":"-0.3064em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"l"),s("span",{class:"mord mathnormal"},"o"),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"g"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8413em"}},[s("span",{style:{top:"-2.4519em","margin-left":"-0.0359em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight"},"m"),s("span",{class:"mbin mtight"},"+"),s("span",{class:"mord mtight"},"1")])])]),s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.10903em"}},"N")])])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3064em"}},[s("span")])])])])])])])]),n("；当数据量"),s("strong",null,"N"),n("一定时，m越大，h越小")]),s("li",null,[s("strong",null,"索引的最左匹配特性"),s("br"),n(" 若B+树的索引结构为 "),s("strong",null,"复合索引"),n("(e.g. id, name, age)；则B+树会"),s("strong",null,"按照从左至右顺序建树"),n("，只有先确定id，才能确定name；若查询条件只有(id, age)，则索引会在id匹配完后停止匹配"),s("br"),s("img",{src:d,alt:"操作系统页大小=MySQL页大小时的B+树"})])],-1),I=l('<h2 id="四、不同存储引擎下的索引结构" tabindex="-1"><a class="header-anchor" href="#四、不同存储引擎下的索引结构"><span>四、不同存储引擎下的索引结构</span></a></h2><h3 id="_4-1、myisam引擎" tabindex="-1"><a class="header-anchor" href="#_4-1、myisam引擎"><span>4.1、MyISAM引擎</span></a></h3><p>MyISAM引擎下，表可以没有主键。</p><h4 id="_4-1-1、聚集索引" tabindex="-1"><a class="header-anchor" href="#_4-1-1、聚集索引"><span>4.1.1、聚集索引</span></a></h4><p>MyISAM引擎使用B+Tree作为索引结构，<strong>叶子节点的data域</strong>存放的是<strong>数据记录的地址</strong>。<br><img src="'+m+'" alt=""></p><h4 id="_4-1-2、辅助索引" tabindex="-1"><a class="header-anchor" href="#_4-1-2、辅助索引"><span>4.1.2、辅助索引</span></a></h4><p>在MyISAM中，主索引和辅助索引在结构上没有任何区别，只是 主索引要求key是唯一的，而辅助索引的key可以重复。<br><img src="'+_+'" alt=""></p><h3 id="_4-2、innodb引擎" tabindex="-1"><a class="header-anchor" href="#_4-2、innodb引擎"><span>4.2、InnoDB引擎</span></a></h3><p>InnoDB要求 表必须有主键。</p><h4 id="_4-2-1、聚集索引" tabindex="-1"><a class="header-anchor" href="#_4-2-1、聚集索引"><span>4.2.1、聚集索引</span></a></h4>',10),E=s("strong",null,"完整的行记录数据",-1),w=s("br",null,null,-1),Q=s("img",{src:u,alt:""},null,-1),C=l('<h4 id="_4-2-2、辅助索引" tabindex="-1"><a class="header-anchor" href="#_4-2-2、辅助索引"><span>4.2.2、辅助索引</span></a></h4><p>InnoDB的辅助索引，引用主键(PK)作为<strong>叶子结点的data域</strong>。<br><img src="'+b+'" alt=""></p><h3 id="_4-3、innodb和myisam引擎区别" tabindex="-1"><a class="header-anchor" href="#_4-3、innodb和myisam引擎区别"><span>4.3、InnoDB和MyISAM引擎区别</span></a></h3><ol><li><strong>主键(PK)</strong><ol><li>MySQL引擎 表必须有索引</li><li>MyISAM引擎 表可以没有索引</li></ol></li><li><strong>索引</strong><ol><li>聚集索引： <ol><li><strong>InnoDB引擎 数据文件本身就是索引文件</strong></li><li><strong>MyISAM引擎 索引和数据是分开的</strong></li></ol></li><li>辅助索引： <ol><li>InnoDB的辅助索引data域存储相应记录主键的值而不是地址</li><li>MyISAM的辅助索引和主索引没有多大区别</li></ol></li></ol></li></ol><h2 id="五、faq" tabindex="-1"><a class="header-anchor" href="#五、faq"><span>五、FAQ</span></a></h2><h3 id="_5-1、复合-联合-索引是如何构建b-树的" tabindex="-1"><a class="header-anchor" href="#_5-1、复合-联合-索引是如何构建b-树的"><span>5.1、复合(联合)索引是如何构建B+树的?</span></a></h3><p>ans: 下图出自《<strong>高性能MySQL 3rd Edition</strong>》<br><img src="'+y+'" alt=""></p><p>e.g. 表结构 为(a int, b int, c int)，索引结构 为(a, b)，则联合索引结构如下。<br><img src="'+k+'" alt=""></p><h3 id="_5-2、索引与索引个数的关系" tabindex="-1"><a class="header-anchor" href="#_5-2、索引与索引个数的关系"><span>5.2、索引与索引个数的关系?</span></a></h3><p>ans:</p><ol><li>建立复合索引只会建立1棵B+树，若复合索引顺序 或 字段不同，则会建立多棵B+树。</li><li>多个列分别建立索引，则每个列会分别建立一棵B+树，有几个列就有几个B+树。</li></ol><h3 id="_5-3、索引下推是什么" tabindex="-1"><a class="header-anchor" href="#_5-3、索引下推是什么"><span>5.3、索引下推是什么?</span></a></h3><p>ans: 在有限范围内进行比较，减少回表次数。<br><img src="'+f+'" alt=""></p><h3 id="_5-4、sql字符串如何比较大小" tabindex="-1"><a class="header-anchor" href="#_5-4、sql字符串如何比较大小"><span>5.4、SQL字符串如何比较大小?</span></a></h3><p>ans: 从字符串的第一个字符开始比较ASCII码值，如果相等则看下一个，以此类推; <strong>小写字母</strong>的ASCII码 &gt; <strong>大写字母</strong>的ASCII码 &gt; <strong>数字</strong> 的ASCII码。</p><h2 id="六、参考文献" tabindex="-1"><a class="header-anchor" href="#六、参考文献"><span>六、参考文献</span></a></h2>',16),q={href:"https://zhuanlan.zhihu.com/p/447472435",target:"_blank",rel:"noopener noreferrer"},L={href:"https://blog.csdn.net/m0_49161353/article/details/120270845",target:"_blank",rel:"noopener noreferrer"},z={href:"https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html",target:"_blank",rel:"noopener noreferrer"},F={href:"https://dev.mysql.com/doc/refman/5.7/en/index-merge-optimization.html",target:"_blank",rel:"noopener noreferrer"},P={href:"https://mp.weixin.qq.com/s/iVDIlhM94loH0b632fhJxw?poc_token=HOFQaWajEzk8t18tSgOpWJ37A40IBQcqZJB6foMb",target:"_blank",rel:"noopener noreferrer"},T={href:"https://juejin.cn/post/6844903921450745863",target:"_blank",rel:"noopener noreferrer"},j={href:"https://tech.meituan.com/2014/08/20/innodb-lock.html",target:"_blank",rel:"noopener noreferrer"},N={href:"https://www.aneasystone.com/archives/2017/12/solving-dead-locks-three.html",target:"_blank",rel:"noopener noreferrer"},H={href:"http://blog.codinglabs.org/articles/theory-of-mysql-index.html",target:"_blank",rel:"noopener noreferrer"},O={href:"https://juejin.cn/post/6844904073955639304",target:"_blank",rel:"noopener noreferrer"},K={href:"https://www.cs.usfca.edu/~galles/visualization/Algorithms.html",target:"_blank",rel:"noopener noreferrer"},Z={href:"https://juejin.cn/post/7129490960169304095",target:"_blank",rel:"noopener noreferrer"};function J(R,W){const a=r("font"),t=r("ExternalLinkIcon");return h(),p("div",null,[v,s("ol",null,[D,s("li",null,[x,n(": "),e(a,{color:"red"},{default:i(()=>[A]),_:1})])]),M,S,I,s("p",null,[s("strong",null,[e(a,{color:"red"},{default:i(()=>[n("InnoDB的数据文件本身就是 聚集索引 文件")]),_:1})]),n("，叶子节点的data域包含 "),E,n("。"),w,Q]),C,s("ol",null,[s("li",null,[s("a",q,[n("https://zhuanlan.zhihu.com/p/447472435"),e(t)])]),s("li",null,[s("a",L,[n("https://blog.csdn.net/m0_49161353/article/details/120270845"),e(t)])]),s("li",null,[s("a",z,[n("https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html"),e(t)])]),s("li",null,[s("a",F,[n("https://dev.mysql.com/doc/refman/5.7/en/index-merge-optimization.html"),e(t)])]),s("li",null,[s("a",P,[n("https://mp.weixin.qq.com/s/iVDIlhM94loH0b632fhJxw?poc_token=HOFQaWajEzk8t18tSgOpWJ37A40IBQcqZJB6foMb"),e(t)])]),s("li",null,[s("a",T,[n("https://juejin.cn/post/6844903921450745863"),e(t)])]),s("li",null,[s("a",j,[n("https://tech.meituan.com/2014/08/20/innodb-lock.html"),e(t)])]),s("li",null,[s("a",N,[n("https://www.aneasystone.com/archives/2017/12/solving-dead-locks-three.html"),e(t)])]),s("li",null,[s("a",H,[n("http://blog.codinglabs.org/articles/theory-of-mysql-index.html"),e(t)])]),s("li",null,[s("a",O,[n("https://juejin.cn/post/6844904073955639304"),e(t)])]),s("li",null,[s("a",K,[n("https://www.cs.usfca.edu/~galles/visualization/Algorithms.html"),e(t)])]),s("li",null,[s("a",Z,[n("https://juejin.cn/post/7129490960169304095"),e(t)])])])])}const Y=o(B,[["render",J],["__file","MySQL索引.html.vue"]]),X=JSON.parse('{"path":"/components/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%B4%A2%E5%BC%95/MySQL%E7%B4%A2%E5%BC%95.html","title":"MySQL索引","lang":"zh-CN","frontmatter":{"title":"MySQL索引","index":true,"category":["中间件"],"tag":["db"],"date":"2024-04-20T00:00:00.000Z","article":true,"star":false,"description":"描述MySQL的索引结构、创建原则、优化实践经验","head":[["meta",{"property":"og:url","content":"https://raysunwhut.github.io/components/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%B4%A2%E5%BC%95/MySQL%E7%B4%A2%E5%BC%95.html"}],["meta",{"property":"og:site_name","content":"浪客剑心"}],["meta",{"property":"og:title","content":"MySQL索引"}],["meta",{"property":"og:description","content":"描述MySQL的索引结构、创建原则、优化实践经验"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-06-12T09:12:55.000Z"}],["meta",{"property":"article:tag","content":"db"}],["meta",{"property":"article:published_time","content":"2024-04-20T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-06-12T09:12:55.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"MySQL索引\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-04-20T00:00:00.000Z\\",\\"dateModified\\":\\"2024-06-12T09:12:55.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"零、MySQL索引思维导图","slug":"零、mysql索引思维导图","link":"#零、mysql索引思维导图","children":[]},{"level":2,"title":"一、基础概念","slug":"一、基础概念","link":"#一、基础概念","children":[]},{"level":2,"title":"二、索引分类","slug":"二、索引分类","link":"#二、索引分类","children":[{"level":3,"title":"2.1、按 存储类型 划分","slug":"_2-1、按-存储类型-划分","link":"#_2-1、按-存储类型-划分","children":[]},{"level":3,"title":"2.2、按 功能 划分","slug":"_2-2、按-功能-划分","link":"#_2-2、按-功能-划分","children":[]},{"level":3,"title":"2.3、回表 & 覆盖索引","slug":"_2-3、回表-覆盖索引","link":"#_2-3、回表-覆盖索引","children":[]}]},{"level":2,"title":"三、索引结构","slug":"三、索引结构","link":"#三、索引结构","children":[{"level":3,"title":"3.1、Hash索引","slug":"_3-1、hash索引","link":"#_3-1、hash索引","children":[]},{"level":3,"title":"3.2、B树索引","slug":"_3-2、b树索引","link":"#_3-2、b树索引","children":[]},{"level":3,"title":"3.3、B+树索引","slug":"_3-3、b-树索引","link":"#_3-3、b-树索引","children":[]}]},{"level":2,"title":"四、不同存储引擎下的索引结构","slug":"四、不同存储引擎下的索引结构","link":"#四、不同存储引擎下的索引结构","children":[{"level":3,"title":"4.1、MyISAM引擎","slug":"_4-1、myisam引擎","link":"#_4-1、myisam引擎","children":[]},{"level":3,"title":"4.2、InnoDB引擎","slug":"_4-2、innodb引擎","link":"#_4-2、innodb引擎","children":[]},{"level":3,"title":"4.3、InnoDB和MyISAM引擎区别","slug":"_4-3、innodb和myisam引擎区别","link":"#_4-3、innodb和myisam引擎区别","children":[]}]},{"level":2,"title":"五、FAQ","slug":"五、faq","link":"#五、faq","children":[{"level":3,"title":"5.1、复合(联合)索引是如何构建B+树的?","slug":"_5-1、复合-联合-索引是如何构建b-树的","link":"#_5-1、复合-联合-索引是如何构建b-树的","children":[]},{"level":3,"title":"5.2、索引与索引个数的关系?","slug":"_5-2、索引与索引个数的关系","link":"#_5-2、索引与索引个数的关系","children":[]},{"level":3,"title":"5.3、索引下推是什么?","slug":"_5-3、索引下推是什么","link":"#_5-3、索引下推是什么","children":[]},{"level":3,"title":"5.4、SQL字符串如何比较大小?","slug":"_5-4、sql字符串如何比较大小","link":"#_5-4、sql字符串如何比较大小","children":[]}]},{"level":2,"title":"六、参考文献","slug":"六、参考文献","link":"#六、参考文献","children":[]}],"git":{"createdTime":1718183575000,"updatedTime":1718183575000,"contributors":[{"name":"RaySunWHUT","email":"42628912+RaySunWHUT@users.noreply.github.com","commits":1}]},"readingTime":{"minutes":6.99,"words":2096},"filePathRelative":"components/数据库/索引/MySQL索引.md","localizedDate":"2024年4月20日","excerpt":"<p>描述MySQL的索引结构、创建原则、优化实践经验</p>\\n","autoDesc":true}');export{Y as comp,X as data};
