import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as o,o as i,c as a,b as t,d as e,a as r,e as g}from"./app-DXKPJHsU.js";const c="/assets/queue-Cyy1KCH-.png",p="/assets/publisher-9lw_U6yM.png",h="/assets/rabbitMQ-SIfxiQUE.png",l="/assets/pd_demo-BA1kjhbq.png",d="/assets/dis_trans-CJUS5JKO.png",u="/assets/psc-UVUh4hEw.png",m={},b=g('<div class="hint-container note"><p class="hint-container-title">MQ基础知识、概念整理</p></div><h2 id="一、使用场景" tabindex="-1"><a class="header-anchor" href="#一、使用场景"><span>一、使用场景</span></a></h2><ol><li>异步处理</li><li>流量控制</li><li>服务解耦</li></ol><p>MQ缺点:</p><ol><li>增加延迟</li><li>增加系统复杂度</li><li>可能产生数据不一致问题</li></ol><h2 id="二、主流产品" tabindex="-1"><a class="header-anchor" href="#二、主流产品"><span>二、主流产品</span></a></h2><h3 id="_2-1、第一梯队" tabindex="-1"><a class="header-anchor" href="#_2-1、第一梯队"><span>2.1、第一梯队</span></a></h3><ol><li><strong>RabbitMQ</strong><ol><li><strong>优点</strong><ol><li><strong>开箱即用(轻量级)</strong></li><li>Exchange模块(交换机)，支持路由配置</li><li>客户端支持最多的编程语言</li><li>支持AMQP协议</li></ol></li><li><strong>缺点</strong><ol><li>对消息积压支持不好，大量消息积压时性能急剧下降</li><li><strong>性能最差(几万～十几万/秒)</strong></li><li>开发语言Erlang学习曲线陡峭</li></ol></li></ol></li><li><strong>RocketMQ</strong><ol><li><strong>优点</strong>： <ol><li>性能(几十万/秒)、稳定性和可靠性都不错</li><li>响应时延低(低延迟)</li><li>金融级稳定性</li><li>适合 <strong>在线业务</strong></li></ol></li><li><strong>缺点</strong>： <ol><li><strong>周边生态系统相对较差</strong></li></ol></li></ol></li><li><strong>Kafka</strong><ol><li><strong>优点</strong>： <ol><li><strong>周边生态系统兼容性最好</strong>！</li><li><strong>异步收发性能最好(吞吐量高)</strong>！</li><li>适合<strong>日志、监控、大数据、流计算</strong></li></ol></li><li><strong>缺点</strong>： <ol><li><strong>同步响应时延较高</strong>(攒一波再发送/处理)</li><li><strong>不太适合在线业务</strong></li></ol></li></ol></li></ol><h3 id="_2-2、第二梯队" tabindex="-1"><a class="header-anchor" href="#_2-2、第二梯队"><span>2.2、第二梯队</span></a></h3><ol><li><strong>ActiveMQ</strong><br> 最老牌消息队列，仅用于兼容旧系统</li><li><strong>ZeroMQ</strong><br> 更适合称为“基于消息队列的多线程网络库”</li><li><strong>Pulsar</strong><br> 特点: 存储 &amp; 计算分离</li></ol><h2 id="三、消息模型" tabindex="-1"><a class="header-anchor" href="#三、消息模型"><span>三、消息模型</span></a></h2><h3 id="_3-1、队列模型" tabindex="-1"><a class="header-anchor" href="#_3-1、队列模型"><span>3.1、队列模型</span></a></h3><p>任何一条消息只能被其中的一个消费者收到<br><img src="'+c+'" alt="队列模型"></p><h3 id="_3-2、发布-订阅模型-publish-subscribe-pattern" tabindex="-1"><a class="header-anchor" href="#_3-2、发布-订阅模型-publish-subscribe-pattern"><span>3.2、发布-订阅模型(Publish-Subscribe Pattern)</span></a></h3><p>与队列模型<strong>最大区别</strong>：一份消息数据能不能被消费多次的问题<br><img src="'+p+'" alt="发布-订阅模型"></p><h2 id="四、rabbitmq消息模型" tabindex="-1"><a class="header-anchor" href="#四、rabbitmq消息模型"><span>四、RabbitMQ消息模型</span></a></h2><p>使用 <strong>队列模型</strong>，通过 <strong>Exchange模块</strong> 实现发布-订阅模型功能。</p><details><summary> See Detail </summary> 使用 队列模型，通过 Exchange模块 实现 “发布-订阅模型” 中 “一份数据可被多个订阅者消费的的功能”。 <p>Exchange模块决定将消息投递到哪个队列中，若同一份消息有多个消费者，则Exchange模块会将消息发送至多个队列。</p></details><figure><img src="'+h+'" alt="" tabindex="0"><figcaption></figcaption></figure><h2 id="五、rocketmq-kafka消息模型" tabindex="-1"><a class="header-anchor" href="#五、rocketmq-kafka消息模型"><span>五、RocketMQ/Kafka消息模型</span></a></h2><p>使用 <strong>发布-订阅模型</strong><br><img src="'+l+'" alt=""></p><p>每个 <strong>主题(Topic)</strong> 包含多个<strong>队列(Queue)/分区(Partition)</strong>，通过多个队列来实现多实例并行生产和消费。</p><p>消息有序性：只能保证 <strong>队列层面</strong> 的消息有序性，主题层面<strong>无法保证</strong>消息严格有序。</p><p>消息可靠性：<strong>“请求-确认”机制</strong>。</p><p><strong>生产</strong> 和 <strong>消费</strong> 过程中，分别有1次请求-确认机制。</p><h2 id="六、消息队列基本概念" tabindex="-1"><a class="header-anchor" href="#六、消息队列基本概念"><span>六、消息队列基本概念</span></a></h2><figure><img src="'+l+'" alt="" tabindex="0"><figcaption></figcaption></figure><ul><li><strong>生产者(Producer): 发布者(Publisher)</strong></li><li><strong>消费组(Consumer Group): 订阅者(Subscriber)</strong><ol><li>每个 <strong>消费组(Consumer Group)</strong> 都消费 <strong>主题(Topic)</strong> 中一份完整的消息(所有队列的全部消息)，不同消费组之间消费进度不受影响</li><li>一个消费组中包含多个 <strong>消费者(Consumer)实例</strong>，同一组内的消费者是竞争消费关系</li><li>同一消费组在每个队列上只能串行消费，多个队列加在一起就是并行消费，<strong>并行度</strong>就是队列数量</li><li>某个队列在同一消费组中最多只能由一个消费者实例占用</li><li>接4，<strong>分区 → 消费者: 1 : 1，消费者 → 分区: 1 : N</strong></li><li>Consumer Group 对应 Topic，Consumer对应Queue</li></ol></li><li><strong>消费者(Consumer):</strong> 消费组下的消费实例</li><li><strong>消费位置(Consumer Offset)</strong>: 记录消费组在当前队列的消费位置 <ol><li>每个消费组在每个队列上维护一个消费位置(<strong>注</strong>: 消费位置和消费者无关)</li><li>消费位置一般保存在Broker中(RocketMQ/Kafka)</li></ol></li><li><strong>主题(Topic):</strong> 服务端存放消息的容器</li><li><strong>队列(Queue)/分区(Partition):</strong> 一个主题包含多个队列/分区，通过队列/分区实现多实例并行生产和消费</li><li><strong>服务端(Broker):</strong> 存储队列的服务器</li></ul><h2 id="七、分布式事务" tabindex="-1"><a class="header-anchor" href="#七、分布式事务"><span>七、分布式事务</span></a></h2><p>常见分布式事务实现</p><ol><li>两阶段提交-2PC(Two-phase Commit)</li><li>TCC(Try-Confirm-Cancel)</li><li>事务消息</li></ol><p>消息队列通过 <strong>事务消息</strong> 实现分布式事务。</p><p><img src="'+d+'" alt=""><br><strong>步骤4</strong> 提交/回滚失败处理方案</p><ol><li>Kafka会直接抛出异常，用户自行解决，重试 or 其他。</li><li>RocketMQ增加 <strong>事务反查机制</strong> 解决(业务代码提供反查接口)。</li></ol><h2 id="八、消息丢失-重复-积压" tabindex="-1"><a class="header-anchor" href="#八、消息丢失-重复-积压"><span>八、消息丢失 &amp; 重复 &amp; 积压</span></a></h2><h3 id="消息丢失处理-消息可靠性传递" tabindex="-1"><a class="header-anchor" href="#消息丢失处理-消息可靠性传递"><span>消息丢失处理(消息可靠性传递)</span></a></h3><h4 id="检测消息丢失的方法" tabindex="-1"><a class="header-anchor" href="#检测消息丢失的方法"><span>检测消息丢失的方法</span></a></h4><p>利用消息队列的 <strong>有序性</strong> 验证是否有消息丢失(使用 <strong>拦截器机制</strong>)</p><p><strong>注</strong>：</p><ol><li>多实例Producer，则每个Producer生成各自消息序号(带Producer标识)</li><li>需指定队列/分区(Partition)，每个分区单独检测</li><li>Consumer端按Producer检测序号连续性，Consumer实例数要与分区数量一致</li></ol><h4 id="消息生产-消费流程" tabindex="-1"><a class="header-anchor" href="#消息生产-消费流程"><span>消息生产-消费流程</span></a></h4><figure><img src="'+u+'" alt="" tabindex="0"><figcaption></figcaption></figure><ul><li><strong>生产阶段</strong><br> 编写发送消息代码时，正确处理返回值或捕捉异常，即可保证消息不丢失</li><li><strong>存储阶段</strong><br> 将消息写入磁盘后，再给Producer返回确认响应<br> 多Broker节点集群，则需至少将消息发送到2个以上节点，再给Producer返回响应</li><li><strong>消费阶段</strong><br> 执行完消费逻辑后，再返回消费确认响应</li></ul><h2 id="九、重复消息处理" tabindex="-1"><a class="header-anchor" href="#九、重复消息处理"><span>九、重复消息处理</span></a></h2><p><strong>消息重复不可避免</strong>, 服务质量标准：</p><ol><li><strong>At most once</strong>：至多一次(消息最多送达一次)，没有消息可靠性保证，允许丢消息</li><li><strong>At least once</strong>：至少一次，不允许丢失消息，但允许少量重复消息出现</li><li><strong>Exactly once</strong>：恰好一次，只会被送达一次，不允许丢失 &amp; 重复</li></ol><h3 id="使用幂等性解决重复消息问题" tabindex="-1"><a class="header-anchor" href="#使用幂等性解决重复消息问题"><span><strong>使用幂等性解决重复消息问题</strong></span></a></h3><p><strong>At least once + 幂等消费 = Exactly once</strong></p><h3 id="幂等消费实现方式" tabindex="-1"><a class="header-anchor" href="#幂等消费实现方式"><span><strong>幂等消费实现方式</strong></span></a></h3><p>从消费业务逻辑设计入手，将 <strong>消费业务逻辑</strong> 设计成具备幂等性的操作，包括</p><ol><li>设置数据库唯一约束(<strong>unique key</strong>)</li><li>为更新的数据设置前置条件(增加 <strong>版本号属性</strong>)</li><li>记录并检查操作(Token机制 或 GUID) <strong>，一般不建议使用</strong></li></ol><h2 id="十、消息积压处理" tabindex="-1"><a class="header-anchor" href="#十、消息积压处理"><span>十、消息积压处理</span></a></h2><h3 id="优化性能" tabindex="-1"><a class="header-anchor" href="#优化性能"><span>优化性能</span></a></h3><p>发送端：增加批量(提高吞吐量)、提高并发(降低时延)<br> 消费端：</p><ol><li>系统设计时，保证消费性能高于生产端发送性能</li><li><strong>水平扩容</strong>，增加consumer实例，并与 <strong>队列/分区(Partition)</strong> 数量保持一致</li></ol><h3 id="问题排查" tabindex="-1"><a class="header-anchor" href="#问题排查"><span>问题排查</span></a></h3><p>问题：排查是否是<strong>消费失败(如消息格式异常)导致的一条消息反复消费</strong>的情况 ?<br> 解决方案：消息队列中间件提供 “<strong>死信队列</strong>” 功能，自动把反复消费失败的消息丢到死信队列中，避免一条消息卡住队列。</p><h2 id="十一、faq" tabindex="-1"><a class="header-anchor" href="#十一、faq"><span>十一、FAQ</span></a></h2><h3 id="_1、单个队列并行消费如何实现" tabindex="-1"><a class="header-anchor" href="#_1、单个队列并行消费如何实现"><span>1、单个队列并行消费如何实现 ?</span></a></h3><p>此时，将 <strong>队列 : 消费者</strong> 置成 <strong>1 : N</strong> 即可。</p><p>问题：消息空洞(e.g. 3个消费者实例读1个队列(Queue)中的5、6、7三条消息，<strong>6、7 ACK</strong> 返回但 <strong>5 ACK</strong> 未返回)</p><p>解决方案：消息队列中间件提供 “<strong>重试队列</strong>” 功能，将5这条消息复制到重试队列，更新消费位置为8，继续消费。下次拉消息时，优先把重试队列中的消息给消费者。</p><h3 id="_2、如何保证消息的严格顺序" tabindex="-1"><a class="header-anchor" href="#_2、如何保证消息的严格顺序"><span>2、如何保证消息的严格顺序 ？</span></a></h3><p><strong>全局严格顺序</strong>：将队列数置为1即可。<br><strong>局部严格顺序</strong>：通过一致性哈希算法指定队列发送消息实现。</p><h1 id="参考文献" tabindex="-1"><a class="header-anchor" href="#参考文献"><span>参考文献</span></a></h1>',65),_={href:"http://juconcurrent.com/books-jksj-71-80/",target:"_blank",rel:"noopener noreferrer"},f={href:"https://cwiki.apache.org/confluence/display/KAFKA/Kafka+Improvement+Proposals",target:"_blank",rel:"noopener noreferrer"},k={href:"https://kafka.apache.org/documentation/#introduction",target:"_blank",rel:"noopener noreferrer"};function E(x,v){const n=o("ExternalLinkIcon");return i(),a("div",null,[b,t("ol",null,[t("li",null,[t("a",_,[e("http://juconcurrent.com/books-jksj-71-80/"),r(n)])]),t("li",null,[t("a",f,[e("https://cwiki.apache.org/confluence/display/KAFKA/Kafka+Improvement+Proposals"),r(n)])]),t("li",null,[t("a",k,[e("https://kafka.apache.org/documentation/#introduction"),r(n)])])])])}const y=s(m,[["render",E],["__file","消息队列(MQ)-基础知识.html.vue"]]),M=JSON.parse('{"path":"/components/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%9F%BA%E7%A1%80/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97(MQ)-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html","title":"消息队列(MQ)-基础知识","lang":"zh-CN","frontmatter":{"title":"消息队列(MQ)-基础知识","category":["中间件"],"tag":["mq"],"date":"2023-07-20T00:00:00.000Z","description":"MQ基础知识、概念整理","head":[["meta",{"property":"og:url","content":"https://raysunwhut.github.io/components/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%9F%BA%E7%A1%80/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97(MQ)-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html"}],["meta",{"property":"og:site_name","content":"浪客剑心"}],["meta",{"property":"og:title","content":"消息队列(MQ)-基础知识"}],["meta",{"property":"og:description","content":"MQ基础知识、概念整理"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-02T15:08:48.000Z"}],["meta",{"property":"article:tag","content":"mq"}],["meta",{"property":"article:published_time","content":"2023-07-20T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-05-02T15:08:48.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"消息队列(MQ)-基础知识\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-07-20T00:00:00.000Z\\",\\"dateModified\\":\\"2024-05-02T15:08:48.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"一、使用场景","slug":"一、使用场景","link":"#一、使用场景","children":[]},{"level":2,"title":"二、主流产品","slug":"二、主流产品","link":"#二、主流产品","children":[{"level":3,"title":"2.1、第一梯队","slug":"_2-1、第一梯队","link":"#_2-1、第一梯队","children":[]},{"level":3,"title":"2.2、第二梯队","slug":"_2-2、第二梯队","link":"#_2-2、第二梯队","children":[]}]},{"level":2,"title":"三、消息模型","slug":"三、消息模型","link":"#三、消息模型","children":[{"level":3,"title":"3.1、队列模型","slug":"_3-1、队列模型","link":"#_3-1、队列模型","children":[]},{"level":3,"title":"3.2、发布-订阅模型(Publish-Subscribe Pattern)","slug":"_3-2、发布-订阅模型-publish-subscribe-pattern","link":"#_3-2、发布-订阅模型-publish-subscribe-pattern","children":[]}]},{"level":2,"title":"四、RabbitMQ消息模型","slug":"四、rabbitmq消息模型","link":"#四、rabbitmq消息模型","children":[]},{"level":2,"title":"五、RocketMQ/Kafka消息模型","slug":"五、rocketmq-kafka消息模型","link":"#五、rocketmq-kafka消息模型","children":[]},{"level":2,"title":"六、消息队列基本概念","slug":"六、消息队列基本概念","link":"#六、消息队列基本概念","children":[]},{"level":2,"title":"七、分布式事务","slug":"七、分布式事务","link":"#七、分布式事务","children":[]},{"level":2,"title":"八、消息丢失 & 重复 & 积压","slug":"八、消息丢失-重复-积压","link":"#八、消息丢失-重复-积压","children":[{"level":3,"title":"消息丢失处理(消息可靠性传递)","slug":"消息丢失处理-消息可靠性传递","link":"#消息丢失处理-消息可靠性传递","children":[]}]},{"level":2,"title":"九、重复消息处理","slug":"九、重复消息处理","link":"#九、重复消息处理","children":[{"level":3,"title":"使用幂等性解决重复消息问题","slug":"使用幂等性解决重复消息问题","link":"#使用幂等性解决重复消息问题","children":[]},{"level":3,"title":"幂等消费实现方式","slug":"幂等消费实现方式","link":"#幂等消费实现方式","children":[]}]},{"level":2,"title":"十、消息积压处理","slug":"十、消息积压处理","link":"#十、消息积压处理","children":[{"level":3,"title":"优化性能","slug":"优化性能","link":"#优化性能","children":[]},{"level":3,"title":"问题排查","slug":"问题排查","link":"#问题排查","children":[]}]},{"level":2,"title":"十一、FAQ","slug":"十一、faq","link":"#十一、faq","children":[{"level":3,"title":"1、单个队列并行消费如何实现 ?","slug":"_1、单个队列并行消费如何实现","link":"#_1、单个队列并行消费如何实现","children":[]},{"level":3,"title":"2、如何保证消息的严格顺序 ？","slug":"_2、如何保证消息的严格顺序","link":"#_2、如何保证消息的严格顺序","children":[]}]}],"git":{"createdTime":1689875154000,"updatedTime":1714662528000,"contributors":[{"name":"RaySunWHUT","email":"42628912+RaySunWHUT@users.noreply.github.com","commits":2}]},"readingTime":{"minutes":6.46,"words":1938},"filePathRelative":"components/消息队列/消息队列基础/消息队列(MQ)-基础知识.md","localizedDate":"2023年7月20日","excerpt":"<div class=\\"hint-container note\\">\\n<p class=\\"hint-container-title\\">MQ基础知识、概念整理</p>\\n</div>\\n","autoDesc":true}');export{y as comp,M as data};
