const V=Object.entries,et=Object.fromEntries,st="ENTRIES",L="KEYS",T="VALUES",_="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case T:return this.value();case L:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],nt=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return R(e,t,s,n,i,1,o,""),n},R=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let F=f;F<y;++F){const v=g!==t[F],z=o[p+F]+ +v,A=o[p+F+1]+1,w=o[m+F]+1,j=o[m+F+1]=Math.min(z,A,w);j<l&&(l=j)}if(l>s)continue t}R(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,st)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return nt(this._tree,t,s)}get(t){const s=k(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=k(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new D(this,L)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,I(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},k=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return k(e.get(s),t.slice(s.length))},I=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)W(n);else if(s.size===1){const[o,u]=s.entries().next().value;q(n,o,u)}}},W=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&q(e.slice(0,-1),n,o)}},q=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],ut=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},it=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,M="or",$="and",rt="and_not",ct=(e,t)=>{e.includes(t)||e.push(t)},N=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},P=({score:e},{score:t})=>t-e,lt=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,ht={[M]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),N(n.terms,u)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);N(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[rt]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},dt=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},at=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},ft=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,lt),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},gt={k:1.2,b:.7,d:.5},mt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(it),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:M,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:gt},pt={combineWith:$,prefix:(e,t,s)=>t===s.length-1},Ft={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},_t={...Ft,...U},K=Symbol("*"),yt=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,u]of e._documentIds){const i=n.boostDocument?n.boostDocument(u,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},X=(e,t=M)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=ht[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},S=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){ft(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const y=g.get(l),F=e._fieldLength.get(l)[h],v=dt(y,m,e._documentCount,F,p,r),z=n*a*f*v,A=d.get(l);if(A){A.score+=z,ct(A.terms,t);const w=G(A.match,s);w?w.push(c):A.match[s]=[c]}else d.set(l,{score:z,terms:[t],match:{[s]:[c]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:G(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...J.weights,...i},h=e._index.get(t.term),g=S(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const y=l.length-t.term.length;if(!y)continue;p?.delete(l);const F=a*l.length/(l.length+.3*y);S(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,y]=p.get(l);if(!y)continue;const F=c*l.length/(l.length+y);S(e,t.term,l,F,f,o,u,d,g)}return g},Y=(e,t,s={})=>{if(t===K)return yt(e,s);if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>Y(e,g,a));return X(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(at(i)).map(a=>At(e,a,i));return X(c,i.combineWith)},Q=(e,t,s={})=>{const n=Y(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length||1,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),queryTerms:r,match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return t===K&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(P),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Q(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(P),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?_t:t.autoVacuum;this._options={...mt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...pt,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},B=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},wt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),xt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),Z=(e,t,s={})=>{const n={};return Q(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(y=>!y.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>B(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>B(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const y=m.map(F=>B(f,F)).filter(F=>F!==null);y.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:y},r])}}}),V(n).sort(([,o],[,u])=>"max"==="total"?wt(o,u):xt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=ut(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},tt=(e,t,s={})=>{const n=Ct(t,e,{fuzzy:.2,maxFuzzy:3,...s}).map(({suggestion:o})=>o);return e.includes(" ")?n:n.filter(o=>!o.includes(" "))},bt=et(V(JSON.parse("{\"/\":{\"documentCount\":240,\"nextId\":240,\"documentIds\":{\"0\":\"1\",\"1\":\"2\",\"2\":\"2#埃氏筛\",\"3\":\"2#欧拉筛-线性筛\",\"4\":\"2#参考文献\",\"5\":\"2@0\",\"6\":\"2@1\",\"7\":\"3\",\"8\":\"4\",\"9\":\"5\",\"10\":\"6\",\"11\":\"6#问题分析-典例精析\",\"12\":\"6#p2440-木材加工\",\"13\":\"6#p1824-进击的奶牛\",\"14\":\"6#p2678-跳石头\",\"15\":\"6#p3853-路标设置\",\"16\":\"6#问题模型阐述\",\"17\":\"6#解题关键-问题核心-本质\",\"18\":\"6#二分法的作用\",\"19\":\"6#参考文献\",\"20\":\"6@0\",\"21\":\"6@1\",\"22\":\"7\",\"23\":\"7#零、二分查找-二分答案算法全景图\",\"24\":\"7#一、二分查找-算法模版\",\"25\":\"7#二、参考文献\",\"26\":\"7@0\",\"27\":\"7@1\",\"28\":\"8\",\"29\":\"8#一、knuth洗牌算法-fisher-yates-shuffle\",\"30\":\"8#二、蓄水池抽样-reservoir-sampling-算法\",\"31\":\"8@0\",\"32\":\"8@1\",\"33\":\"9\",\"34\":\"9#现象描述\",\"35\":\"9#解决方案\",\"36\":\"9#参考文献\",\"37\":\"9@0\",\"38\":\"9@1\",\"39\":\"10\",\"40\":\"10#零、一致性哈希算法-思维导图\",\"41\":\"10#一、问题背景\",\"42\":\"10#二、解决方案\",\"43\":\"10#_2-1、负载均衡层-加权轮询\",\"44\":\"10#_2-2、哈希算法\",\"45\":\"10#_2-3、一致性哈希算法\",\"46\":\"10#_2-4、带虚拟节点的一致性哈希算法\",\"47\":\"10#三、一致性哈希算法实现\",\"48\":\"10#四、参考文献\",\"49\":\"10@0\",\"50\":\"10@1\",\"51\":\"11\",\"52\":\"11#类加载流程\",\"53\":\"11#详解jvm线程私有域\",\"54\":\"11#详解jvm公共内存域\",\"55\":\"11#参考文献\",\"56\":\"11@0\",\"57\":\"11@1\",\"58\":\"12\",\"59\":\"12#jvm常量池种类\",\"60\":\"12#jvm常量池内存分布\",\"61\":\"12#faq\",\"62\":\"12#字符串字面量是什么时候进入到字符串常量池\",\"63\":\"12@0\",\"64\":\"12@1\",\"65\":\"13\",\"66\":\"13#类加载器结构\",\"67\":\"13#自定义类加载器\",\"68\":\"13#实战学习\",\"69\":\"13#使用自定义类加载器解析mybatis注解\",\"70\":\"13#线程上下文类加载器\",\"71\":\"13#mysql-driver\",\"72\":\"13#launchedurlclassloader\",\"73\":\"13#faq\",\"74\":\"13#参考文献\",\"75\":\"13@0\",\"76\":\"13@1\",\"77\":\"14\",\"78\":\"14#线程中断机制-知识图谱\",\"79\":\"14#线程中断处理方法\",\"80\":\"14#中断-interrupt-作用\",\"81\":\"14#中断处理原则\",\"82\":\"14#faq\",\"83\":\"14#参考文献\",\"84\":\"14@0\",\"85\":\"14@1\",\"86\":\"15\",\"87\":\"15#一、问题描述\",\"88\":\"15#二、分页问题优化前提\",\"89\":\"15#三、分布式场景下的分页查询\",\"90\":\"15#四、深分页优化\",\"91\":\"15#_4-1、表主键id连续\",\"92\":\"15#_4-2、带-last-条件-查询\",\"93\":\"15#_4-3、子查询\",\"94\":\"15#_4-4、级联子查询\",\"95\":\"15#五、参考文献\",\"96\":\"15@0\",\"97\":\"15@1\",\"98\":\"16\",\"99\":\"16#一、快速幂基本原理\",\"100\":\"16#_1-1、快速幂时间复杂度\",\"101\":\"16#_1-3、快速幂-c-实现\",\"102\":\"16#二、快速幂应用\",\"103\":\"16#_2-1、应用1-幂取模\",\"104\":\"16#_2-2、应用2-麦森数\",\"105\":\"16#三、参考文献\",\"106\":\"16@0\",\"107\":\"16@1\",\"108\":\"17\",\"109\":\"17#git核心基础-知识图谱\",\"110\":\"17#git操作流程图\",\"111\":\"17#git名词解释\",\"112\":\"17#git命令\",\"113\":\"17#git-push\",\"114\":\"17#git-stash\",\"115\":\"17#git-reset\",\"116\":\"17#关于-head\",\"117\":\"17#git-reflog\",\"118\":\"17#git-revert\",\"119\":\"17#git-log\",\"120\":\"17#git-log-两点-比较\",\"121\":\"17#git-log-三点-比较\",\"122\":\"17#git-diff\",\"123\":\"17#git-diff-两点-比较-三点-比较\",\"124\":\"17#git-文件类型\",\"125\":\"17#工作区-workspace-命令\",\"126\":\"17#暂存区-stage-命令\",\"127\":\"17#本地仓库-repository-命令\",\"128\":\"17#清除远程分支引用\",\"129\":\"17#参考文献\",\"130\":\"17@0\",\"131\":\"17@1\",\"132\":\"18\",\"133\":\"18#一、文章梗概\",\"134\":\"18#二、rebase-变基-与merge-合并-区别\",\"135\":\"18#三、交互式rebase\",\"136\":\"18#_3-1、rebase操作命令\",\"137\":\"18#_3-2、rebase-edit命令与reword命令区别\",\"138\":\"18#四、场景实践\",\"139\":\"18#_4-1、伪变基-修改指定分支的commit提交描述信息-reword\",\"140\":\"18#_4-2、标记commit提交-实现rebase自动编排\",\"141\":\"18#五、rebase优缺点\",\"142\":\"18#优点\",\"143\":\"18#缺点\",\"144\":\"18#六、使用法则\",\"145\":\"18#七、参考文献\",\"146\":\"18@0\",\"147\":\"18@1\",\"148\":\"19\",\"149\":\"19#一、问题背景\",\"150\":\"19#二、传统文件传输\",\"151\":\"19#_2-1、传统文件传输的问题\",\"152\":\"19#_2-2、可优化点\",\"153\":\"19#三、零拷贝\",\"154\":\"19#_3-1、mmap-write\",\"155\":\"19#_3-2、sendfile\",\"156\":\"19#_3-3、真正的零拷贝\",\"157\":\"19#四、零拷贝应用\",\"158\":\"19#五、参考文献\",\"159\":\"19@0\",\"160\":\"19@1\",\"161\":\"20\",\"162\":\"20#零、sql优化-思维导图\",\"163\":\"20#一、sql优化原则\",\"164\":\"20#二、常见sql优化方法\",\"165\":\"20@0\",\"166\":\"20@1\",\"167\":\"21\",\"168\":\"21#零、mysql索引思维导图\",\"169\":\"21#一、基础概念\",\"170\":\"21#二、索引分类\",\"171\":\"21#_2-1、按-存储类型-划分\",\"172\":\"21#_2-2、按-功能-划分\",\"173\":\"21#_2-3、回表-覆盖索引\",\"174\":\"21#三、索引结构\",\"175\":\"21#_3-1、hash索引\",\"176\":\"21#_3-2、b树索引\",\"177\":\"21#_3-3、b-树索引\",\"178\":\"21#四、不同存储引擎下的索引结构\",\"179\":\"21#_4-1、myisam引擎\",\"180\":\"21#_4-1-1、聚集索引\",\"181\":\"21#_4-1-2、辅助索引\",\"182\":\"21#_4-2、innodb引擎\",\"183\":\"21#_4-2-1、聚集索引\",\"184\":\"21#_4-2-2、辅助索引\",\"185\":\"21#_4-3、innodb和myisam引擎区别\",\"186\":\"21#五、faq\",\"187\":\"21#_5-1、复合-联合-索引是如何构建b-树的\",\"188\":\"21#_5-2、索引与索引个数的关系\",\"189\":\"21#_5-3、索引下推是什么\",\"190\":\"21#_5-4、sql字符串如何比较大小\",\"191\":\"21#六、参考文献\",\"192\":\"21@0\",\"193\":\"21@1\",\"194\":\"22\",\"195\":\"22#一、使用场景\",\"196\":\"22#二、主流产品\",\"197\":\"22#_2-1、第一梯队\",\"198\":\"22#_2-2、第二梯队\",\"199\":\"22#三、消息模型\",\"200\":\"22#_3-1、队列模型\",\"201\":\"22#_3-2、发布-订阅模型-publish-subscribe-pattern\",\"202\":\"22#四、rabbitmq消息模型\",\"203\":\"22#五、rocketmq-kafka消息模型\",\"204\":\"22#六、消息队列基本概念\",\"205\":\"22#七、分布式事务\",\"206\":\"22#八、消息丢失-重复-积压\",\"207\":\"22#消息丢失处理-消息可靠性传递\",\"208\":\"22#检测消息丢失的方法\",\"209\":\"22#消息生产-消费流程\",\"210\":\"22#九、重复消息处理\",\"211\":\"22#使用幂等性解决重复消息问题\",\"212\":\"22#幂等消费实现方式\",\"213\":\"22#十、消息积压处理\",\"214\":\"22#优化性能\",\"215\":\"22#问题排查\",\"216\":\"22#十一、faq\",\"217\":\"22#_1、单个队列并行消费如何实现\",\"218\":\"22#_2、如何保证消息的严格顺序\",\"219\":\"22@0\",\"220\":\"22@1\",\"221\":\"23\",\"222\":\"24\",\"223\":\"25\",\"224\":\"26\",\"225\":\"27\",\"226\":\"28\",\"227\":\"29\",\"228\":\"30\",\"229\":\"31\",\"230\":\"32\",\"231\":\"33\",\"232\":\"34\",\"233\":\"35\",\"234\":\"36\",\"235\":\"37\",\"236\":\"38\",\"237\":\"39\",\"238\":\"40\",\"239\":\"41\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1],\"1\":[1,1],\"2\":[1,64],\"3\":[2,65],\"4\":[1,18],\"5\":[null,null,1],\"6\":[null,null,1],\"7\":[1],\"8\":[1],\"9\":[2],\"10\":[1,2],\"11\":[3,14],\"12\":[2],\"13\":[2],\"14\":[2],\"15\":[2],\"16\":[1],\"17\":[3],\"18\":[1,4],\"19\":[1],\"20\":[null,null,1],\"21\":[null,null,2],\"22\":[2,2],\"23\":[3],\"24\":[3,184],\"25\":[2,27],\"26\":[null,null,1],\"27\":[null,null,1],\"28\":[2,1],\"29\":[6,110],\"30\":[5,109],\"31\":[null,null,1],\"32\":[null,null,2],\"33\":[2],\"34\":[1,12],\"35\":[1,17],\"36\":[1,27],\"37\":[null,null,1],\"38\":[null,null,1],\"39\":[1,1],\"40\":[3],\"41\":[2,2],\"42\":[2],\"43\":[5,5],\"44\":[2,7],\"45\":[3,25],\"46\":[3,43],\"47\":[2,1],\"48\":[2,20],\"49\":[null,null,1],\"50\":[null,null,1],\"51\":[1,2],\"52\":[1],\"53\":[1],\"54\":[1],\"55\":[1,49],\"56\":[null,null,1],\"57\":[null,null,1],\"58\":[1,6],\"59\":[1],\"60\":[1],\"61\":[1],\"62\":[2,54],\"63\":[null,null,1],\"64\":[null,null,2],\"65\":[1,2],\"66\":[1],\"67\":[1],\"68\":[1],\"69\":[1],\"70\":[1],\"71\":[2],\"72\":[1],\"73\":[1,26],\"74\":[1,60],\"75\":[null,null,1],\"76\":[null,null,3],\"77\":[1,2],\"78\":[1],\"79\":[1,21],\"80\":[1,93],\"81\":[1,86],\"82\":[1,118],\"83\":[1,8],\"84\":[null,null,1],\"85\":[null,null,1],\"86\":[1,2],\"87\":[2,40],\"88\":[2,9],\"89\":[2,54],\"90\":[2],\"91\":[3,21],\"92\":[6,29],\"93\":[3,43],\"94\":[2,38],\"95\":[2,19],\"96\":[null,null,1],\"97\":[null,null,1],\"98\":[1,1],\"99\":[2,3],\"100\":[2,7],\"101\":[4,29],\"102\":[2],\"103\":[4,42],\"104\":[1,73],\"105\":[2,17],\"106\":[null,null,1],\"107\":[null,null,1],\"108\":[1,1],\"109\":[1],\"110\":[1],\"111\":[1,46],\"112\":[1],\"113\":[1,14],\"114\":[1,21],\"115\":[1,65],\"116\":[1,14],\"117\":[1,9],\"118\":[1,45],\"119\":[1,43],\"120\":[1,3],\"121\":[2,12],\"122\":[1,22],\"123\":[1,18],\"124\":[1,37],\"125\":[3,26],\"126\":[3,26],\"127\":[3,8],\"128\":[1,8],\"129\":[1,22],\"130\":[null,null,1],\"131\":[null,null,1],\"132\":[2,4],\"133\":[2],\"134\":[6,61],\"135\":[2,10],\"136\":[3,31],\"137\":[4,60],\"138\":[2],\"139\":[6,16],\"140\":[4,22],\"141\":[2],\"142\":[1,9],\"143\":[1,7],\"144\":[2,14],\"145\":[2,10],\"146\":[null,null,1],\"147\":[null,null,1],\"148\":[1,1],\"149\":[2,3],\"150\":[2],\"151\":[3,19],\"152\":[2,8],\"153\":[2,8],\"154\":[3,20],\"155\":[3,27],\"156\":[2,21],\"157\":[2,4],\"158\":[2,13],\"159\":[null,null,1],\"160\":[null,null,1],\"161\":[1],\"162\":[3],\"163\":[2,15],\"164\":[2,108],\"165\":[null,null,1],\"166\":[null,null,1],\"167\":[1,3],\"168\":[2],\"169\":[2,35],\"170\":[2],\"171\":[4,42],\"172\":[3,12],\"173\":[4,41],\"174\":[2,2],\"175\":[3,25],\"176\":[3,13],\"177\":[2,38],\"178\":[2],\"179\":[3,3],\"180\":[3,3],\"181\":[4,6],\"182\":[3,3],\"183\":[4,3],\"184\":[3,5],\"185\":[3,14],\"186\":[2],\"187\":[6,16],\"188\":[4,10],\"189\":[4,4],\"190\":[4,10],\"191\":[2,67],\"192\":[null,null,1],\"193\":[null,null,1],\"194\":[3,2],\"195\":[2,7],\"196\":[2],\"197\":[3,38],\"198\":[2,10],\"199\":[2],\"200\":[3,1],\"201\":[8,2],\"202\":[2,17],\"203\":[3,27],\"204\":[2,51],\"205\":[2,26],\"206\":[4],\"207\":[3],\"208\":[1,15],\"209\":[2,13],\"210\":[2,18],\"211\":[1,7],\"212\":[1,16],\"213\":[2],\"214\":[1,15],\"215\":[1,11],\"216\":[2],\"217\":[3,32],\"218\":[3,22],\"219\":[null,null,1],\"220\":[null,null,1],\"221\":[1,3],\"222\":[1],\"223\":[1],\"224\":[1],\"225\":[1],\"226\":[1],\"227\":[1],\"228\":[1],\"229\":[1],\"230\":[1],\"231\":[1],\"232\":[1],\"233\":[1],\"234\":[1],\"235\":[1],\"236\":[1],\"237\":[1],\"238\":[1],\"239\":[1]},\"averageFieldLength\":[1.9641160691359578,26.087160572017215,0.6756183885786078],\"storedFields\":{\"0\":{\"h\":\"algorithm\"},\"1\":{\"h\":\"质数筛\",\"t\":[\"给出2种低时间复杂度快速筛选质数的方法\"]},\"2\":{\"h\":\"埃氏筛\",\"t\":[\"埃氏筛，即 埃拉托斯特尼筛法，时间复杂度为 O(nlog(logn))，算法详情可参见wiki百科：埃拉托斯特尼筛法\",\"public class AceSifter { /* * 返回 <= n 的所有质数 * * @param n 上界 */ private static List<Integer> aceSifter(int n) { // 质数表 List<Integer> primes = new ArrayList<>(); // flag[i] = true: i为质数 boolean[] flag = new boolean[n + 1]; Arrays.fill(flag, true); // 0、1 不是质数 flag[0] = flag[1] = false; // 将合数置为false for (int i = 2; i <= n; i++) { if (flag[i]) { // 注: j >= 0作用: 避免溢出 for (int j = i * i; j >= 0 && j <= n; j += i) { // 此处可加 if (flag[i]) 判断, 也可不加 flag[j] = false; } primes.add(i); } } return primes; } public static void main(String[] args) { List<Integer> primes = aceSifter(110); System.out.println(primes); } } \"]},\"3\":{\"h\":\"欧拉筛/线性筛\",\"t\":[\"欧拉筛，又名线性筛，时间复杂度为 O(n)，算法详情可参考: 欧拉筛\",\"public class EulerSifter { /** * 返回 <= n 的所有质数<br/> * @param n 上界 */ private static List<Integer> eulerSifter(int n) { // 质数表 List<Integer> primes = new ArrayList<>(); // flag[i] = true: i为质数 boolean[] flag = new boolean[n + 1]; Arrays.fill(flag, true); // 0、1 不是质数 flag[0] = flag[1] = false; // 2 是质数 flag[2] = true; for (int i = 2; i <= n; i++) { // 若i是「质数」，添加至质数表 if (flag[i]) { primes.add(i); } // l是i的最小质因数，将 <=l(i的最小质因数)的质数与i相乘，并标记为false for (int l : primes) { if (i * l > n) { break; } flag[i * l] = false; if (i % l == 0) { break; } } } return primes; } public static void main(String[] args) { List<Integer> primes = eulerSifter(110); System.out.println(primes); } } \"]},\"4\":{\"h\":\"参考文献\",\"t\":[\"https://zh.wikipedia.org/wiki/埃拉托斯特尼筛法\",\"https://www.bilibili.com/video/BV1H8411E7hn/?spm_id_from=333.999.0.0&vd_source=e9988d180a03a7b167558e2688c4362b\"]},\"5\":{\"c\":[\"algorithm\"]},\"6\":{\"c\":[\"质数筛\"]},\"7\":{\"h\":\"components\"},\"8\":{\"h\":\"java\"},\"9\":{\"h\":\"system design\"},\"10\":{\"h\":\"浅析二分答案问题模型\",\"t\":[\"General summary\"]},\"11\":{\"h\":\"问题分析(典例精析)\",\"t\":[\"首先，会看到这篇文章的，大概率是对二分答案问题模型有了基本了解，并且想要进一步洞悉问题全貌的同学，因此，本文开篇暂不阐述“二分答案问题模型”的概念，而是先抛出题目，在解题的过程中由近及远、由浅入深的加深对问题的理解，并且最终掌握二分答案问题模型的本质/核心。\"]},\"12\":{\"h\":\"P2440-木材加工\"},\"13\":{\"h\":\"P1824-进击的奶牛\"},\"14\":{\"h\":\"P2678-跳石头\"},\"15\":{\"h\":\"P3853-路标设置\"},\"16\":{\"h\":\"问题模型阐述\"},\"17\":{\"h\":\"解题关键 & 问题核心/本质\"},\"18\":{\"h\":\"二分法的作用\",\"t\":[\"二分法在此处仅仅只是手段，用于加快枚举速度，仅此而已。\"]},\"19\":{\"h\":\"参考文献\"},\"20\":{\"c\":[\"algorithm\"]},\"21\":{\"c\":[\"二分\",\"问题模型\"]},\"22\":{\"h\":\"二分查找 & 二分答案\",\"t\":[\"二分查找-java算法模版\"]},\"23\":{\"h\":\"零、二分查找 & 二分答案算法全景图\"},\"24\":{\"h\":\"一、二分查找-算法模版\",\"t\":[\"// 二分查找标准模版 // 二分查找主要有以下3种实现方式 // 1. [左闭, 右开) // 2. [左闭, 右闭] // 3. 二分答案写法 /** * 二分查找要点 * 1. 明确搜索区间 * 1.1 [左闭, 右开) * 1.2 [左闭, 右闭] * 2. 清楚结束条件 * 搜索区间决定结束条件 * [左闭, 右开) 结束条件为 left == right * [左闭, 右闭] 结束条件为 left == right + 1 * 3. 区分越界条件 * 区分不同情况下的越界判断条件，不宜死记，可基于对不同情况二分查找逻辑的理解确定 * 在融汇以上3点的情况下，可写出不同情况下的二分查找算法，也可基于思维难度更低的 二分答案 思想实现算法 * @author RaySunWHUT * @Date 2023-07-12 09:37 */ public class Main { /** * 搜索区间: [左闭, 右闭] * 返回目标元素 target 最小(左)下标(第一次出现位置) * @param arr * @param target * @return */ public int findLeftClosed(int[] arr, int target) { // 1. 搜索区间: [left, right] int left = 0; int right = arr.length - 1; // 2. 结束条件: left = right + 1 while (left <= right) { int mid = left + (right - left) / 2; if (arr[mid] > target) { // 在 mid 的左侧区间 [left, mid - 1] 搜素 right = mid - 1; } else if (arr[mid] < target) { // 在 mid 的右侧区间 [mid + 1, right] 搜素 left = mid + 1; } else if (arr[mid] == target) { // 为清晰逻辑, 等于(==)目标元素时的分支也要写清楚 right = mid - 1; } } // 左右均会越界, 关键看返回什么 // 2种越界情况: // 1. 目标元素 大于(>) 元素序列的所有元素时(left == arr.length, right == arr.length - 1), 返回 -1 // 2. 目标元素 小于(<) 元素序列的所有元素时(left == 0, right == -1), 返回 -1 // 为提高程序健壮性 和 方便记忆, 最好写成 if (left >= arr.length || right < 0), 此处是为了清晰程序的可达性 if (left >= arr.length) { return -1; } // 目标元素存在时, 返回元素最小(左)下标; 目标元素不存在时, 返回 大于(>) 目标元素的元素的最小(左)下标 // 注: 由于 left = right + 1, 故也可返回 right + 1 // return left; // 目标元素存在时, 返回元素最小(左)下标; 目标元素不存在时, 返回 -1 // 此处, left 可替换为 right + 1 return arr[left] == target ? left : -1; } /** * 搜索区间: [左闭, 右闭] * 返回目标元素 target 最大(右)下标(最后一次出现位置) * @param arr * @param target * @return */ public int findRightClosed(int[] arr, int target) { // 1. 搜索区间: [left, right] int left = 0; int right = arr.length - 1; // 2. 结束条件: left = right + 1 while (left <= right) { int mid = left + (right - left) / 2; if (arr[mid] > target) { // 在 mid 的左侧区间 [left, mid - 1] 搜素 right = mid - 1; } else if (arr[mid] < target) { // 在 mid 的右侧区间 [mid + 1, right] 搜素 left = mid + 1; } else if (arr[mid] == target) { left = mid + 1; } } // 左右均会越界, 关键看返回什么 // 2种越界情况: // 1. 目标元素 大于(>) 元素序列的所有元素时(left == arr.length, right == arr.length - 1), 返回 -1 // 2. 目标元素 小于(<) 元素序列的所有元素时(left == 0, right == -1), 返回 -1 // 为提高程序健壮性 和 方便记忆, 最好写成 if (left >= arr.length || right < 0), 此处是为了清晰程序的可达性 if (right < 0) { return -1; } // 目标元素存在时, 返回元素最大(右)下标; 目标元素不存在时, 返回 小于(<) 目标元素的元素的最大(右)下标 // 注: 由于 left = right + 1, 故也可返回 left - 1 // return right; // 目标元素存在时, 返回元素最大(右)下标; 目标元素不存在时, 返回 -1 // 此处, right 可替换为 left - 1 return arr[right] == target ? right : -1; } /** * 搜索区间: [左闭, 右开) * 返回目标元素最小(左)下标(第一次出现位置) * @param arr * @param target * @return */ public int findLeftOpen(int[] arr, int target) { // 1. 搜索区间: [left, right) int left = 0; int right = arr.length; // 2. 结束条件: left == right, 此时搜索区间为[left, left), 可正确终止 while (left < right) { int mid = left + (right - left) / 2; if (arr[mid] > target) { // 在 mid 的右侧区间 [mid + 1, right) 搜索 right = mid; } else if (arr[mid] < target) { // 在 mid 的左侧区间 [left, mid) 搜素 left = mid + 1; } else if (arr[mid] == target) { right = mid; } } // 返回left时, 只有右边界会越界 // 1种越界情况: // 1. 目标元素 大于(>) 元素序列的所有元素时(left == right == arr.length), 返回 -1 // 由于结束条件是left == right, 故此处left可替换为right // 两种不同写法的理解: // 此处写成 left >= arr.length, 含义是left逐渐逼近元素序列右边界, 直至与right相等 // 此处写成 right >= arr.length, 含义是right始终保持不动, left逐渐逼近, 直至两者相等 if (left >= arr.length) { return -1; } // 目标元素存在时, 返回元素小(左)下标; 目标元素不存在时, 返回 大于(>) 目标元素的元素的最小(左)下标 // 注: 由于 left == right, 故也可返回 right // return left; // 目标元素存在时, 返回元素最小(左)下标; 目标元素不存在时, 返回 -1 return arr[left] == target ? left : -1; } /** * 搜索区间: [左闭, 右开) * 返回目标元素最大(右)下标(最后一次出现位置) * 注意⚠️: 搜索区间[左闭, 右开)的情况下, 返回值较为特殊, 需特别记忆！ * @param arr * @param target * @return */ public int findRightOpen(int[] arr, int target) { // 1. 搜索区间: [left, right) int left = 0; int right = arr.length; // 2. 结束条件: left == right, 此时搜索区间为[left, left), 可正确终止 while (left < right) { int mid = left + (right - left) / 2; if (arr[mid] > target) { // 在 mid 的左侧区间 [left, mid) 搜素 right = mid; } else if (arr[mid] < target) { // 在 mid 的左侧区间 [mid + 1, right) 搜素 left = mid + 1; } else if (arr[mid] == target) { left = mid + 1; } } // 返回left - 1时, 只有左边界会越界(此处需特别注意⚠️: 由于 arr[mid] == target 时, left = mid + 1, 所以满足条件的 mid = left - 1, 故需要返回 left - 1) // 1种越界情况: // 1. 目标元素 小于(<) 元素序列的所有元素时(left == right == 0), 返回 -1 // 虽然会出现 left == right == arr.length 的情况, 但此处返回 left - 1, 所以不会触发越界情况 // 虽然结束条件是left == right, 但此处返回 left - 1 更具逻辑性 if (left - 1 < 0) { return -1; } // 目标元素存在时, 返回元素最大(右)下标; 目标元素不存在时, 返回 小于(<) 目标元素的元素的最大(右)下标 // 注: 由于 left == right, 故也可返回 right - 1 // return left - 1; // 目标元素存在时, 返回元素最大(右)下标; 目标元素不存在时, 返回 -1 return arr[left - 1] == target ? left - 1 : -1; } /** * 具备 \\\"单调性\\\" 的真值命题P(x) * @param arr * @param target * @param mid * @return */ private boolean f(int[] arr, int target, int mid) { return arr[mid] >= target; } /** * 二分答案思想实现二分查找(关键在于思想) * 注意⚠️: 可通过修改 \\\"真值命题P(x)\\\" 的方法逻辑以及 \\\"分界点\\\" 两侧的处理逻辑, 适配不同搜索区间的不同情况 * 使用二分答案写法思维难度更低，此处只举例说明 \\\"搜索区间 为 [左闭, 右开) 查找目标元素左边界\\\" 的情况，其他情况同理 * e.g. * 搜索区间: [左闭, 右开) * 返回目标元素最大(右)下标(最后一次出现位置) * @param arr * @param target * @return */ public int findLeftOpenAns(int[] arr, int target) { int left = 0; int right = arr.length; int ans = -1; while (left < right) { int mid = left + (right - left) / 2; if (f(arr, target, mid)) { // 二分答案思想 ans = mid; right = mid; } else { left = mid + 1; } } // 返回left时, 只有右边界会越界 // 1种越界情况: // 1. 目标元素 大于(>) 元素序列的所有元素时(left == right == arr.length), 返回 -1 // 由于结束条件是left == right, 故此处left可替换为right // 两种不同写法的理解: // 此处写成 left >= arr.length, 含义是left逐渐逼近元素序列右边界, 直至与right相等 // 此处写成 right >= arr.length, 含义是right始终保持不动, left逐渐逼近, 直至两者相等 if (left >= arr.length) { return -1; } // 目标元素存在时, 返回元素小(左)下标; 目标元素不存在时, 返回 大于(>) 目标元素的元素的最小(左)下标 // return ans; // 目标元素存在时, 返回元素最小(左)下标; 目标元素不存在时, 返回 -1 return arr[ans] == target ? ans : -1; } public static void main(String[] args) { // int[] arr = new int[]{1, 2, 2, 4, 7, 9, 9, 9, 13}; int[] arr = new int[]{2, 2, 4, 7, 9, 9, 9, 13}; // int[] arr = new int[]{1, 2, 2, 4, 7, 9, 9, 9}; Main binarySearch = new Main(); int[] targets = new int[]{0, 2, 4, 9, 13, 20}; System.out.println(\\\"=== 寻找目标元素左边界 ===\\\"); // 寻找目标元素左边界 for (int target : targets) { int idx = binarySearch.findLeftClosed(arr, target); System.out.println(\\\"idx: \\\" + idx); } for (int target : targets) { int idx = binarySearch.findLeftOpen(arr, target); System.out.println(\\\"idx: \\\" + idx); } for (int target : targets) { int idx = binarySearch.findLeftOpenAns(arr, target); System.out.println(\\\"idx: \\\" + idx); } System.out.println(\\\"=== 寻找目标元素右边界 ===\\\"); // 寻找目标元素左边界 for (int target : targets) { int idx = binarySearch.findRightClosed(arr, target); System.out.println(\\\"idx: \\\" + idx); } for (int target : targets) { int idx = binarySearch.findRightOpen(arr, target); System.out.println(\\\"idx: \\\" + idx); } } } \",\"注：有空可补充 灵山府二分文章\"]},\"25\":{\"h\":\"二、参考文献\",\"t\":[\"https://leetcode.cn/problems/search-in-rotated-sorted-array/solutions/1987503/by-endlesscheng-auuh/\",\"https://labuladong.github.io/algo/di-ling-zh-bfe1b/wo-xie-le--3c789/\"]},\"26\":{\"c\":[\"algorithm\"]},\"27\":{\"c\":[\"二分法\"]},\"28\":{\"h\":\"洗牌算法 & 蓄水池抽样算法\",\"t\":[\"描述洗牌算法和随机抽样算法的底层原理和实现\"]},\"29\":{\"h\":\"一、Knuth洗牌算法(Fisher-Yates Shuffle)\",\"t\":[\"算法目标：将1个 数组 或 列表 随机打乱，以等可能概率生成 数组 或 列表 的1个 随机排列。算法流程：\",\"对于1个含n个无重复元素的 数组 或 列表，对于 [0, n -1] 范围内的每个 下标为i 的元素，从下标范围 [i, n-1] 中，随机选出1个 下标为k 的元素，与 下标为i 的元素交换。\",\"遍历 数组 或 列表，对 数组 或 列表 中的每个元素执行 步骤1。\",\"数组遍历完成，即完成 “洗牌”。\",\"算法 正确性证明：\",\"首先，根据排列组合，对于1个含n个无重复元素的 数组 或 列表，其总排列数为n x (n - 1) x (n - 2) x … x 1 = n!，而算法目标就是从这 n! 种排列组合中，随机选出1个排列。\",\"根据Knuth算法流程， \",\"对于下标0，则选择范围是 [0, n-1]，故有n种随机选法\",\"对于下标1，则选择范围是 [1 , n-1]，有n-1种随机选法\",\"…\",\"对于下标n-1，则选择范围是 [n-1, n-1]，有1种随机选法\",\"因此，Knuth洗牌算法可以从 n! 种选择(排列)中，随机选出1种排列，达成了算法目标。：Knuth洗牌算法，对于 含重复元素 的数组/列表同样适用，上文中以“n个无重复元素”表述，主要是为了论证 Knuth洗牌算法 的正确性 & 有效性。\",\"LC题源：LC384-打乱数组算法实现(java)：\",\"class Solution { private int[] nums; public Solution(int[] nums) { this.nums = nums; } public int[] reset() { return nums; } public int[] shuffle() { Random rand = new Random(); // 深拷贝 int[] ans = nums.clone(); // 对于下标i, 从 下标范围[i, n-1] 中，随机选出1个元素与nums[i]交换 // 故，会随机产生 n x (n-1) x (n-2)x...x1 = n!种组合 for (int i = 0; i < ans.length; i++) { int k = i + rand.nextInt(ans.length - i); swap(ans, i, k); } return ans; } private void swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } \"]},\"30\":{\"h\":\"二、蓄水池抽样(Reservoir Sampling)算法\",\"t\":[\"算法目标：从未知容量大小(N ≥ k)的样本集中，以等概率选出k个样本。\",\"算法流程：\",\"将样本集的 前k个样本(下标范围为**[0, k-1]**的元素) 放到 ”蓄水池” 中。\",\"从 第 i 个元素(i > k-1) 开始，每次随机生成1个范围在 [0, i] 间的 随机数 j\",\"若 j ≤ k-1，则将 下标为i 的元素 与 下标为j 的元素 交换。\",\"若 j > k-1，不执行操作。\",\"算法正确性证明： 对于 第i个元素(i > k - 1)，它被选入蓄水池的概率是 k/i；对于已在蓄水池中的元素，它被选中的概率同样是k/i； 故当遍历至 第N-1个 元素时，选中样本集中各个元素的概率均为 k/N，达成了算法目标。\",\"算法时间复杂度：O(N)LC题源：LC382-链表随机结点算法实现(java)：\",\"import java.util.Random; public class ReservoirSampling { // 从数据流中随机抽取k个样本 public static int[] reservoirSample(int[] stream, int k) { int[] reservoir = new int[k]; Random random = new Random(); // 将前k个元素放入蓄水池 for (int i = 0; i < k; i++) { reservoir[i] = stream[i]; } // 处理剩余的元素 for (int i = k; i < stream.length; i++) { // 生成一个范围在[0, i]之间的随机数 // 每个元素(未在蓄水池 & 已在蓄水池中的元素)被选中的概率都是 k/i(i分之k) int j = random.nextInt(i + 1); // 如果随机数j落在蓄水池的范围内，则替换蓄水池中的第j个元素 if (j < k) { reservoir[j] = stream[i]; } } return reservoir; } public static void main(String[] args) { int[] stream = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; int k = 5; int[] result = reservoirSample(stream, k); System.out.println(\\\"Sampled elements:\\\"); for (int value : result) { System.out.print(value + \\\" \\\"); } } } \"]},\"31\":{\"c\":[\"algorithm\"]},\"32\":{\"c\":[\"抽样\",\"随机排列\"]},\"33\":{\"h\":\"docker启动后自动退出-解决办法\"},\"34\":{\"h\":\"现象描述\",\"t\":[\"执行命令run一个容器(container)，容器生成后发现既没有任何报错也没有消息提示，就自动关闭。\",\"docker run --name=\\\"容器名\\\" [镜像(Image)名] \"]},\"35\":{\"h\":\"解决方案\",\"t\":[\"添加 -it参数\",\"方案1无效，则在-it参数后在命令最后加上/bin/bash\",\"docker run -it --name=\\\"容器名\\\" [镜像(Image)名] \",\"方案1无效解决方案\",\"docker run -it --name=\\\"容器名\\\" [镜像(Image)名] /bin/bash \"]},\"36\":{\"h\":\"参考文献\",\"t\":[\"https://blog.csdn.net/haokelaicds/article/details/124961973?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-124961973-blog-94554897.235^v38^pc_relevant_default_base&spm=1001.2101.3001.4242.1&utm_relevant_index=3\"]},\"37\":{\"c\":[\"中间件\"]},\"38\":{\"c\":[\"docker\"]},\"39\":{\"h\":\"一致性哈希\",\"t\":[\"描述一致性哈希算法的基本原理\"]},\"40\":{\"h\":\"零、一致性哈希算法-思维导图\"},\"41\":{\"h\":\"一、问题背景\",\"t\":[\"在客户端请求量较大时，如何合理分配客户端对网站后台服务器集群的大量请求\"]},\"42\":{\"h\":\"二、解决方案\"},\"43\":{\"h\":\"2.1、负载均衡层 + 加权轮询\",\"t\":[\"使用场景：每个节点存储的数据相同的情况，若数据分布式的存储在不同的节点的上，则无法使用加权轮询。\"]},\"44\":{\"h\":\"2.2、哈希算法\",\"t\":[\"对节点数量进行取模运算。痛点：若节点数量发生变化，即在对系统做扩容或者缩容时，必须迁移改变了映射关系的数据。否则会出现查询不到数据的问题。\"]},\"45\":{\"h\":\"2.3、一致性哈希算法\",\"t\":[\"一致性哈希 是指将「存储节点」和「数据」都映射到一个首尾相连的哈希环上。\",\"一致性哈希算法对2^32进行取模运算，由2^32个点组成 哈希环。\",\"一致性哈希算法流程：\",\"对 存储节点 进行哈希\",\"对 数据 存取进行哈希\",\"在一致性哈希算法中，若 增加 或 移除 一个节点，仅影响该节点在哈希环上顺时针相邻的后继节点，其余数据不受影响。\",\"存在问题\",\"一致性哈希算法虽然减少了数据迁移量，但存在节点分布不均匀的问题。\"]},\"46\":{\"h\":\"2.4、带虚拟节点的一致性哈希算法\",\"t\":[\"改为「两层」映射，目的 是 让节点相对均匀的分布在哈希环(节点数量越多，在哈希环上的分布就越均匀)。\",\"不再将 真实节点 映射到哈希环上。\",\"将 虚拟节点 映射到哈希环上，并将 虚拟节点 映射(→) 到 实际节点。\",\"FAQ：使用 带虚拟结点 的一致性hash算法后，每次 新增/删除 物理机，都会 引入、剔除大量虚拟结点，那么数据迁移量不是更大了嘛 ?\",\"ans：引入虚拟结点后，在增删物理机时，虽然迁移的虚拟结点数量增多了，但两个虚拟结点间的 ”段长” 更短了；同时，无论是否使用带虚拟结点的一致性hash算法，机器上的总数据量是不变的，故迁移的数量是不变的，只是“带虚拟结点”的一致性hash算法会让数据分布的更均匀。\"]},\"47\":{\"h\":\"三、一致性哈希算法实现\",\"t\":[\"可参考labuladong的一致性hash算法实现\"]},\"48\":{\"h\":\"四、参考文献\",\"t\":[\"https://xiaolincoding.com/os/8_network_system/hash.html#_9-4-什么是一致性哈希\",\"https://mp.weixin.qq.com/s/zL-n7zq0Zyhf-l_GQil2dg\"]},\"49\":{\"c\":[\"中间件\"]},\"50\":{\"c\":[\"hash\"]},\"51\":{\"h\":\"JVM基本原理分析\",\"t\":[\"General summary\"]},\"52\":{\"h\":\"类加载流程\"},\"53\":{\"h\":\"详解JVM线程私有域\"},\"54\":{\"h\":\"详解JVM公共内存域\"},\"55\":{\"h\":\"参考文献\",\"t\":[\"https://houbb.github.io/2022/05/10/interview-09-jvm-gc#\",\"https://doocs.github.io/jvm/00-quickstart.html\",\"https://mp.weixin.qq.com/s/l3wSzgSjd58yiBS3Ld1WDw\",\"https://mp.weixin.qq.com/s/_XXxeZ8R5kND6KJ8nV_cQw\",\"https://pdai.tech/md/java/jvm/java-jvm-gc-g1.html\",\"https://mp.weixin.qq.com/s/_XXxeZ8R5kND6KJ8nV_cQw\",\"https://stackoverflow.com/questions/60220158/how-do-symbolic-references-resolve-to-direct-references-in-class-loading-phase-i\",\"https://blog.jamesdbloom.com/JVMInternals.html\",\"https://github.com/TangBean/understanding-the-jvm\"]},\"56\":{\"c\":[\"java\"]},\"57\":{\"c\":[\"JVM\"]},\"58\":{\"h\":\"浅析JVM常量池\",\"t\":[\"this is a great one.\"]},\"59\":{\"h\":\"JVM常量池种类\"},\"60\":{\"h\":\"JVM常量池内存分布\"},\"61\":{\"h\":\"FAQ\"},\"62\":{\"h\":\"字符串字面量是什么时候进入到字符串常量池 ?\",\"t\":[\"https://doocs.github.io/jvm/01-jvm-memory-structure.html#运行时常量池\",\"https://segmentfault.com/a/1190000040922573\",\"https://blogs.oracle.com/javamagazine/post/java-class-file-constant-pool\",\"https://docs.oracle.com/javase/specs/jvms/se17/html/jvms-4.html#jvms-4.4\",\"https://stackoverflow.com/questions/10209952/what-is-the-purpose-of-the-java-constant-pool\",\"https://www.jianshu.com/p/8394c560eec0\",\"https://www.zhihu.com/question/50258991/answer/120450561\",\"https://www.zhihu.com/question/30300585/answer/51335493\",\"https://cana.space/详解符号引用转直接引用/\",\"https://docs.oracle.com/javase/specs/jvms/se6/html/ConstantPool.doc.html\",\"https://www.jianshu.com/p/8394c560eec0\"]},\"63\":{\"c\":[\"java\"]},\"64\":{\"c\":[\"JVM\",\"常量池\"]},\"65\":{\"h\":\"深度解析JVM类加载机制\",\"t\":[\"General summary\"]},\"66\":{\"h\":\"类加载器结构\"},\"67\":{\"h\":\"自定义类加载器\"},\"68\":{\"h\":\"实战学习\"},\"69\":{\"h\":\"使用自定义类加载器解析Mybatis注解\"},\"70\":{\"h\":\"线程上下文类加载器\"},\"71\":{\"h\":\"MySQL Driver\"},\"72\":{\"h\":\"LaunchedURLClassLoader\"},\"73\":{\"h\":\"FAQ\",\"t\":[\"如何判断两个类(Class对象)是否相等 ?\",\"本地IDEA启动SpringBoot与服务器jar包形式运行SpringBoot项目的区别是什么 ?\",\"对于String.class或者Object.class这样的由BootstrapClassLoader加载的类，当使用AppClassLoader加载器加载某个类时，若该类中出现String.class的话，那么是不是每次都需要基于双亲委派模型递归遍历，直至BootstrapClassLoader调用findLoadedClass方法时，才可以判断出String.class或者Object.class已被加载呢 ?\",\"当自定义类加载需要加载的类中出现String.class时，类加载如何加载 ?\",\"为什么我看不到AppClassLoader的源码 ?\",\"在不遵循双亲委派模型的情况下，使用自定义类加载器加载String.class会发生什么 ?\",\"JVM在加载一个类时，发现类中引用了尚未被加载至JVM中的类(对于每个类)，JVM是如何处理处理的 ?\"]},\"74\":{\"h\":\"参考文献\",\"t\":[\"https://developer.aliyun.com/article/1114576https://blog.csdn.net/yangliuhbhd/article/details/81022057https://frank909.blog.csdn.net/article/details/54973413https://blog.csdn.net/zxh1991811/article/details/107981268http://www.yxhuang.com/2020/07/07/java-class-loader/https://blog.csdn.net/m0_46761060/article/details/124417972https://blog.csdn.net/zuodaoyong/article/details/113788263https://blog.csdn.net/justloveyou_/article/details/72217806https://spring-source-code-learning.gitbook.teaho.net/boot/spring-boot-loader.htmlhttps://www.jianshu.com/p/0a86966146b6https://mp.weixin.qq.com/s?__biz=MzkwNzI0MzQ2NQ==&mid=2247488905&idx=1&sn=654ee37d8aaaa1415f30bdbf065de129&source=41#wechat_redirecthttps://blog.csdn.net/qq_44543508/article/details/102983363https://segmentfault.com/a/1190000023130736?utm_source=sf-similar-article\"]},\"75\":{\"c\":[\"java\"]},\"76\":{\"c\":[\"JVM\",\"classLoader\",\"注解\"]},\"77\":{\"h\":\"浅析java线程中断机制\",\"t\":[\"分析java线程中断的作用、使用场景以及处理原则\"]},\"78\":{\"h\":\"\"},\"79\":{\"h\":\"\",\"t\":[\"Thread类中有3个与线程中断有关的方法:\",\"interrupt(): 唯一一个可将线程 中断标识 置为 true 的方法\",\"isInterrupted(): 返回线程 中断标识。\",\"interrupted(): 返回线程 中断标识，并 清除 线程中断标识(即若当前线程被中断，且中断标识为 true，则调用 interrupted() 方法后，会返回 true，同时将线程中断标识置为 false)。\"]},\"80\":{\"h\":\"\",\"t\":[\"Java语言中的 中断(Interrupt) 与中文语境中中断的含义略有不同；在Java语言中，线程 中断(Interrupt) 并不是真正的将某个运行中的线程终止，中断(Interrupt)的作用 更接近于 协调 和 通知；至于收到中断信号的线程如何响应(终止、继续执行 或 挂起等)，由被中断线程自己决定。\",\"程序示例\",\"public class SleepTest { public static void main(String[] args) { Thread c = Thread.currentThread(); Thread t = new Thread(() -> { try { // 此处sleep()只起阻塞作用, 也可替换成空转的for消除try..catch语句 Thread.sleep(2000L); c.interrupt(); } catch (InterruptedException e) { throw new RuntimeException(e); } }); t.start(); System.out.println(\\\"------ thread start! ------\\\"); // 实践证明：interrupt()方法只会将线程的中断标识置为true, 无法终止线程运行，只起协同(通知)作用，具体执行怎样的逻辑，取决于代码对中断的响应 try { Thread.sleep(3000L); } catch (InterruptedException e) { System.out.println(\\\"exception occurs!\\\"); // 注: 抛出InterruptedException异常后，中断标识会被置为false System.out.println(\\\"interrupt status - \\\" + c.isInterrupted()); // throw new RuntimeException(e); } System.out.println(\\\"线程状态: \\\" + Thread.currentThread().getState()); } \",\"运行结果\",\"可以看到 Thread.sleep() 方法会可以感知中断，并抛出InterruptedException异常， 其他会抛出 InterruptedException异常 的方法包括但不限于:\",\"wait()\",\"sleep()\",\"join()\",\"offer()\",\"take(): 凡是在方法声明中抛出 InterruptedException异常 的方法，均可感知到中断标识变化，并会在线程中断标识发生变化 (置为true) 后，抛出 InterruptedException异常。\",\"需要特别说明，抛出 InterruptedException异常 后，中断标识会被清除(重置为 false)。\"]},\"81\":{\"h\":\"\",\"t\":[\"响应中断\",\"显示响应 程序逻辑中使用 isInterrupted()、interrupted() 方法判断中断标识，执行响应逻辑。\",\"隐式响应 方法声明中包含 throws InterruptedException 的方法会自动响应中断。\",\"传递中断 当其他线程调用另一个线程的 interrupt() 方法中断它时，应该将中断传递给被中断线程。 处理方法: \",\"继续向⽅法调⽤栈的上层抛出 InterruptedException异常 传递中断\",\"重新设置线程中断标识(使用interrupt()) 传递中断\",\"避免忽略中断 程序中捕获的InterruptedException中断异常, 不应被吞掉。 程序示例\",\"public class SleepTest { public static void main(String[] args) { Thread c = Thread.currentThread(); Thread t = new Thread(() -> { try { Thread.sleep(2000L); c.interrupt(); } catch (InterruptedException e) { throw new RuntimeException(e); } }); t.start(); System.out.println(\\\"------ thread start! ------\\\"); // 测试 printStackTrace()方法 是否会吞掉异常 while(true) { System.out.println(\\\"running!!!\\\"); if (c.isInterrupted()) { break; } try { // 当线程被阻塞在 sleep()/join()/wait() 这些方法时, 如果被中断, 就会抛出 InterruptedException 受检异常， // 并且，当前线程的中断标识会被清除(置为false) Thread.sleep(1000L); } catch (InterruptedException e) { // printStackTrace()会吞掉异常 e.printStackTrace(); // 方法1: 重置中断标识 // c.interrupt(); // 方法2: 向⽅法调⽤栈的上层抛出受检异常 // throw new RuntimeException(e); } } } } \",\"运行结果\",\"程序catch到受检异常InterruptedException后，执行 e.printStackTrace() 语句后吞掉了异常，导致出现while死循环。: 程序中捕获的任何受检异常都不应该被吞掉，否则会导致上层调⽤栈什么信息也获取不到。\"]},\"82\":{\"h\":\"\",\"t\":[\"Q: 抛出 InterruptedException 异常后，中断标识就⼀定被清除(置为false)吗 ？ans: 是的，线程中断标识一定会被清空。\",\"Q: 处在死锁状态的线程是否可以被中断 ?ans: 处于死锁状态的线程无法直接被中断。\",\"Q: 已进⼊临界区的线程能否被中断 ?ans: 已进入临界区的线程无法被直接中断。程序示例\",\"public class InterruptTest2 { private static final ReentrantLock lock = new ReentrantLock(); public static void main(String[] args) throws InterruptedException { List<Thread> list = new ArrayList<>(); int sum = 2; for (int i = 0; i < sum; i++) { Thread thread = new Thread(() -> { String name = Thread.currentThread().getName(); // 尝试获取锁，不可响应中断 lock.lock(); try { // 执行临界区操作 while (true) { // lock()方法虽然不可响应中断, 但可以使用isInterrupted()方法判断中断状态, 显示处理中断 // if (Thread.currentThread().isInterrupted()) { // System.out.println(\\\"break!!!\\\"); // break; // } System.out.println(name + \\\": executing\\\"); for (int k = 0; k < Integer.MAX_VALUE; k++) for (int l = 0; l < Integer.MAX_VALUE; l++); } } finally { // 退出临界区，释放锁 lock.unlock(); } }); thread.start(); list.add(thread); } Thread.sleep(2000L); for (int i = 0; i < sum; i++) { // 中断线程 list.get(i).interrupt(); System.out.println(list.get(i).getName() + \\\": interrupt status - \\\" + list.get(i).isInterrupted()); } Thread.sleep(1000L); for (int i = 0; i < sum; i++) { System.out.println(list.get(i).getName() + \\\": thread state - \\\" + list.get(i).getState()); } } } \",\"运行结果\",\"可以看到，已进入临界区的程序，无法响应中断，但可以在临界区程序中使用 isInterrupted() 等方法判断中断状态, 显示处理中断。\",\"Q: 如果已进⼊临界区的线程不能被中断，有什么办法可以响应中断吗?ans: 如果希望正在等待锁(acquiring)、等待 I/O 操作或处于睡眠状态的线程 响应中断，可以使用可重入锁(ReentrantLock)的 lock.lockInterruptibly() 方法；使用 lock.lockInterruptibly() 方法可以让正在阻塞等待获取锁(acquiring)的线程响应中断，抛出InterruptedException受检异常。程序示例\",\"public class InterruptTest2 { private static final ReentrantLock lock = new ReentrantLock(); public static void main(String[] args) throws InterruptedException { List<Thread> list = new ArrayList<>(); int sum = 2; for (int i = 0; i < sum; i++) { Thread thread = new Thread(() -> { String name = Thread.currentThread().getName(); try { // 尝试获取锁，可响应中断 lock.lockInterruptibly(); // 执行临界区操作 while (true) { System.out.println(name + \\\": executing\\\"); for (int k = 0; k < Integer.MAX_VALUE; k++) for (int m = 0; m < Integer.MAX_VALUE; m++); } } catch (InterruptedException e) { System.out.println(name + \\\": interrupted\\\"); throw new RuntimeException(e); } finally { // 退出临界区，释放锁 lock.unlock(); } }); thread.start(); list.add(thread); } Thread.sleep(2000L); for (int i = 0; i < sum; i++) { // 中断线程 list.get(i).interrupt(); System.out.println(list.get(i).getName() + \\\": interrupt status - \\\" + list.get(i).isInterrupted()); } Thread.sleep(1000L); for (int i = 0; i < sum; i++) { System.out.println(list.get(i).getName() + \\\": thread state - \\\" + list.get(i).getState()); } } } \",\"运行结果\"]},\"83\":{\"h\":\"参考文献\",\"t\":[\"https://dayarch.top/p/java-concurrency-book.html\"]},\"84\":{\"c\":[\"java\"]},\"85\":{\"c\":[\"中断\"]},\"86\":{\"h\":\"深分页问题\",\"t\":[\"描述MySQL深分页问题&解决方案\"]},\"87\":{\"h\":\"一、问题描述\",\"t\":[\"浅分页-定义：当offset值较小时，执行分页查询的SQL语句称为 “浅分页”深分页-定义：当SQL分页查询的 偏移量(OFFSET) 较大的时，会导致数据库出现 性能瓶颈(OOM) 故，将 查询偏移量(OFFSET)过大 的场景称为 ”深分页”e.g.\",\"-- 注: limit & offset 语法: limit offset, pageSize <=> limit ? offset ? -- e.g. limit 100000, 10 <=>(等价于) limit 10 offset 100000 -- 排序字段要加索引/是索引列 SELECT * FROM t_order ORDER BY id LIMIT 1000000, 10 \"]},\"88\":{\"h\":\"二、分页问题优化前提\",\"t\":[\"分页场景下必须加 order by，且order by的字段，必须是 索引列，否则无论怎样优化SQL，查询性能都很难提升\"]},\"89\":{\"h\":\"三、分布式场景下的分页查询\",\"t\":[\"分布式场景下，由于数据存在于多个 分表 之中，当执行 分页查询 时，需要将 分页SQL语句 下推到各个MySQL实例的分表中执行，再在内存中聚合排序各分表的查询结果，最后返回。\",\"但是，为了保证分页查询数据的正确性，需要 改写分页SQL语句。\",\"e.g.\",\"-- 原分页SQL语句 -- 原执行结果{(id: 4, t_col1: a), (id: 7, t_col1: b)}❌ select * from t_order order by id limit 2, 2; -- 改写后的分页SQL语句 -- 原执行结果{(id: 1, t_col1: a), (id: 3, t_col1: b)}✅ select * from t_order order by id limit 0, 4; -- 再比如, -- 单机单表 场景 SELECT * FROM t_order ORDER BY id LIMIT 1000000, 10 -- 多MySQL实例&多分表 场景 -- 改写后的正确SQL SELECT * FROM t_order ORDER BY id LIMIT 0, 1000010 \"]},\"90\":{\"h\":\"四、深分页优化\"},\"91\":{\"h\":\"4.1、表主键id连续\",\"t\":[\"当可保证 id的连续性 时，可根据 id范围 进行 分页\",\"SELECT * FROM t_order WHERE id >= 100001 AND id <= 100010 ORDER BY id \"]},\"92\":{\"h\":\"4.2、带 {last_条件} 查询\",\"t\":[\"具体实现：可通过 记录上次查询结果 的最后1条记录的id 进行 分页查询(需要配合程序逻辑实现)场景限制：不支持 跳页(即 通过点击页码数字跳转)推荐使用场景：没有页码，滑动加载下一页，只有上/下一页按钮 的应用\",\"SELECT * FROM t_order WHERE id >= #{last_id} LIMIT 10 \"]},\"93\":{\"h\":\"4.3、子查询\",\"t\":[\"将查询条件转移到 主键索引，由于子查询中select选出字段只有 主键列(id)，故 使用了覆盖索引，减少了回表次数，进而减少了大量IO操作。\",\"京东解法: 子查询改造，可一定程度上降低OOM概率：个人认为不够好，不如一次性在子查询中将满足偏移量的所有id全查出来，而不是仅在子查询已经定位到满足offset的第一条记录的id后，就直接返回；然后再交给主表，使用 >= 再定位查找1遍，这种做法 没有充分利用好子查询的定位/查询结果\",\"# 原SQL SELECT * FROM t_order ORDER BY id LIMIT 1000000, 10 # 子查询改造 SELECT * FROM t_order WHERE id > (SELECT id FROM t_order order by id limit 1000000, 1) LIMIT 10; \",\"：京东认为，此方案数据查询量级较大时，仍然有OOM风险，故建议子查询只作为应急过渡方案.\"]},\"94\":{\"h\":\"4.4、级联子查询\",\"t\":[\"阿里巴巴java开发手册-关于深分页问题的解法 使用 子查询 + 覆盖索引 在 最小化回表次数+IO操作次数 的情况下，查出符合条件的主键(id)值，然后再与 SELECT * 的SQL查询 做级联，查出符合条件的SQL语句。\",\"：得物官方使用此方案解决深分页问题，详见此处\",\"-- 注：以下2条SQL等价 SELECT t1.* FROM t_order AS t1 INNER JOIN (SELECT id FROM t_order ORDER BY id LIMIT 100000 , 20) AS t2 ON t1.id = t2.id SELECT t1.* FROM t_order AS t1 , (SELECT id FROM t_order ORDER BY id LIMIT 100000 , 20) AS t2 WHERE t1.id = t2.id \"]},\"95\":{\"h\":\"五、参考文献\",\"t\":[\"https://mp.weixin.qq.com/s/ZEwGKvRCyvAgGlmeseAS7g\",\"https://juejin.cn/post/6985478936683610149\",\"https://javaguide.cn/high-performance/deep-pagination-optimization.html#子查询\"]},\"96\":{\"c\":[\"系统设计\"]},\"97\":{\"c\":[\"分页\"]},\"98\":{\"h\":\"快速幂算法\",\"t\":[\"描述快速幂算法原理\"]},\"99\":{\"h\":\"一、快速幂基本原理\",\"t\":[\"基本原理：幂次分解\",\"a105=a1∗a8∗a32∗a64\"]},\"100\":{\"h\":\"1.1、快速幂时间复杂度\",\"t\":[\"快速幂时间复杂度: O(log2n​)\",\"整数n的二进制位数 为 1+⌊log2n​⌋\"]},\"101\":{\"h\":\"1.3、快速幂-C++实现\",\"t\":[\"题源: 牛客-JZ16\",\"class Solution { public: // 题目描述: // 实现函数 double Power(double base, int exp)，求base的exp次方 // 注: exp可能为负 double Power(double base, int exp) { double res = 1; // 处理exp为负的情况 int pow = exp < 0 ? -1 * exp : exp; while (pow != 0) { if ((pow & 1) == 1) { res *= base; } pow >>= 1; base *= base; } return exp < 0 ? 1.0 / res : res; } }; \"]},\"102\":{\"h\":\"二、快速幂应用\"},\"103\":{\"h\":\"2.1、应用1-幂取模\",\"t\":[\"计算anmodm\",\"#include<iostream> #include<cmath> #include<cstdio> #include<algorithm> #include<string> #include<set> #include<unordered_set> #include<vector> #include<climits> #include<limits> #include<map> #include<unordered_map> #include<string.h> using namespace std; int main() { long long a, n, m; cin >> a >> n >> m; long long r = 1; while (n != 0) { // &运算 需要加 括号() if ((n & 1) == 1) { r = r * a % m; } a = a * a % m; n = n >> 1; } cout << r << endl; return 0; } \"]},\"104\":{\"h\":\"\",\"t\":[\"#include<iostream> #include<cmath> #include<cstdio> #include<algorithm> #include<string> #include<set> #include<unordered_set> #include<vector> #include<climits> #include<limits> #include<map> #include<unordered_map> #include<string.h> #include<queue> using namespace std; int res[500]; int lenRes = 0; void multiple(int arr[], int lenArr, int nums[], int lenNum) { int lenA = lenArr + lenNum; int a[lenA]; memset(a, 0, sizeof(a)); for (int i = 0; i < lenArr; i++) { for (int j = 0; j < lenNum; j++) { a[i + j] += arr[i] * nums[j]; } } for (int i = 0; i < lenA - 1; i++) { a[i + 1] += a[i] / 10; a[i] %= 10; if (i < 500) { res[i] = a[i]; } else { break; } } lenRes = lenA >= 500 ? 500 : lenA; } int arr[500]; int lenArr = 0; // 求解数字a的N次方(高精度) void compute(int* a, int* b, int lenA, int lenB) { int len = lenA + lenB; int c[len]; memset(c, 0, sizeof(c)); for (int i = 0; i < lenA; i++) { for (int j = 0; j < lenB; j++) { c[i + j] += a[i] * b[j]; } } for (int i = 0; i < len - 1; i++) { c[i + 1] += c[i] / 10; c[i] %= 10; if (i < 500) { arr[i] = c[i]; } else { break; } } lenArr = len >= 500 ? 500: len; } int main() { int p; cin >> p; int bits = p * log10(2) + 1; cout << bits << endl; memset(res, 0, sizeof(res)); res[0] = 1; lenRes = 1; memset(arr, 0, sizeof(arr)); arr[0] = 2; lenArr = 1; // 快速幂 while (p != 0) { if ((p & 1) == 1) { multiple(arr, lenArr, res, lenRes); } compute(arr, arr, lenArr, lenArr); p >>= 1; } res[0] -= 1; for (int i = 500 - 1; i >= 0; i--) { cout << res[i]; if (i % 50 == 0) { cout << endl; } } return 0; } \"]},\"105\":{\"h\":\"三、参考文献\",\"t\":[\"https://www.bilibili.com/video/BV16Z4y1M7y1/?share_source=copy_web&vd_source=e9988d180a03a7b167558e2688c4362b\",\"https://www.luogu.com.cn/blog/80614/solution-p1226\"]},\"106\":{\"c\":[\"algorithm\"]},\"107\":{\"c\":[\"快速幂\"]},\"108\":{\"h\":\"git核心基础知识\",\"t\":[\"git基础知识及易混淆概念整理\"]},\"109\":{\"h\":\"\"},\"110\":{\"h\":\"\"},\"111\":{\"h\":\"\",\"t\":[\"工作区(workspace)\",\"即在电脑里能看到的代码库目录，在 工作区(workspace) 新增、删除、修改文件。\",\"暂存区(index / stage)\",\"临时存放文件的变动/更改，实际上它只是一个文件(.git/index)，保存 待提交(to be committed) 文件信息。\",\"使用 git add 命令将 工作区(workspace) 的修改保存至 暂存区(stage)。\",\"本地仓库(Repository)\",\"保存 已提交(committed) 的文件修改/变动。\",\"使用 git commit -m \\\"msg\\\" 命令将 暂存区(stage) 的修改保存至 本地仓库(Repository)。\",\"远程仓库(Remote)\",\"使用 git push origin 命令将 本地仓库(Repository) 的修改推送至 远程仓库(Remote)。\",\"头(HEAD)\",\"HEAD类似一个“指针”，指向 当前分支 的 最新commit。\"]},\"112\":{\"h\":\"\"},\"113\":{\"h\":\"\",\"t\":[\"# 强制推送 git push -f origin # 将 本地 branchA 分支 的最新提交, 推送到 远程仓库的 branchB 分支 git push branchA:branchB \"]},\"114\":{\"h\":\"\",\"t\":[\"作用：在不执行提交commit的情况下，保存当前 暂存区(stage) 的文件变更/更改(用于保存现场)。\",\"使用场景：当前正在feature分支开发需求中，功能尚未开发完成且不想进行commit，但临时遭遇突发情况，需要切换到其他分支处理问题。\",\"# 将stage区文件变动暂存 git stash # 还原现场 git stash pop # 销毁暂存内容 git stash drop \"]},\"115\":{\"h\":\"\",\"t\":[\"git reset 操作 会将代码 回退(回滚) 至指定commitId版本，根据参数项[--mixed | --soft | --hard]的不同，将HEAD与commitId之间的所有commit提交的文件变动/更改，回退 至 工作区(workspace)、暂存区(stage) 或 清除。\",\"使用注意事项⚠️ :\",\"git reset HEAD 仅用于 回滚git add 操作，在文件更改已 提交(commit) 至 本地仓库(Repository) 的情况下，git reset HEAD(当前分支最新commit)是没有任何效果的，什么也不会发生。\",\"回滚 git commit 操作 需使用 git reset [--soft | --mixed | --hard] [commitId] ，且 [commitId] 必须早于 HEAD。\",\"git reset [--soft | --mixed | --hard] [HEAD | commitId] # --mixed(默认) # 作用: 将HEAD与commId之间的所有commit的文件更改/变动，全部 回退至 工作区(workspace), 即 尚未添加(add)至暂存区(stage) 的状态 # 使用场景: 撤回 git add, git commit # git reset HEAD 仅用于 回滚 git add 操作 git reset git reset HEAD # 回滚 git commit 操作 # 注: 此处 commitId 必须早于 HEAD 才会有效果 git reset [commitId] # --soft # 作用: 将HEAD与commId之间的所有commit的文件更改/变动，全部 回退 至 暂存区(stage)，即 已添加(add)至 暂存区(stage) 的状态 git reset --soft [commitId] # --hard # 作用: 将代码 回滚 至指定commitId版本 # 注: 将HEAD与commId之间的所有commit的文件更改/变动, 全部 清除，代码切换至指定commitId版本；若操作失误则 git log 无法找到提交痕迹，可通过 git reflog 找到commitId版本并恢复。 git reset --hard [commitId] \"]},\"116\":{\"h\":\"\",\"t\":[\"HEAD 表示当前版本。\",\"HEAD^ 上一个版本\",\"HEAD^^ 上上一个版本\",\"HEAD^^^ 上上上一个版本\",\"HEAD~n 回撤 n 个版本(HEAD~0等价于HEAD)，这种也是更加方便的\"]},\"117\":{\"h\":\"\",\"t\":[\"保存所有commit记录，包括使用 git reset --hard 回退的commit记录仍然可以通过 git reflog 找到。\"]},\"118\":{\"h\":\"\",\"t\":[\"git revert -n [commitId] 操作会 “撤销↩️” 指定commitId的更改，并将指定commitId的更改 回退 至 暂存区(stage)。\",\"revert 理解为 “撤销↩️” 某个commit的更改更为合适。\",\"reset操作 是向后的，revert操作 是向前的，即在原分支最新提交的基础上生成一个新commit。\",\"深刻理解：git revert HEAD 连续执行两次就和什么也没有执行是一样的。\",\"# revert操作 会在当前代码基础上撤回指定commit的更改，并在用户填写完commit msg后, 将 “在当前代码基础上撤回指定commit更改后的代码”，自动commit至远程分支 git revert [commitId] # -n: 使用 revert -n 后，会将当前commit的更改保存至暂存区，用户可进一步调整后再手动commit git revert -n [commitId] git revert 与 git reset 区别: # 将代码 回滚 至指定commitId版本 git reset [commitId] # 撤销↩️ 指定commitId版本的提交, 并将指定commitId版本的提交回退至 暂存区(stage) # 注：git revert 的效果是 撤回，而 git reset 的效果是 回滚 git revert -n [commitId] \"]},\"119\":{\"h\":\"\",\"t\":[\"查看仓库分支的提交(commit)记录信息，包括commitId、提交人和提交时间描述等。\",\"git log --pretty=\\\"%an(%cd) %h - %s\\\" --since=\\\"2022-09-01\\\" --no-merges --name-status \",\"# 命令格式 # 注意: 没有这种写法: git log branchA branchB # git log 两点 和 空格 不一样 git log [<branch> | <commit>]..[<branch> | <commit>] git log [<branch> | <commit>]...[<branch> | <commit>] # 正确✅ git log testMater...testSun # 错误❌ # 注: git 两点log 和三点diff 的 \\\"点(.)\\\" 前后不能有空格 git log testMater ... testSun \"]},\"120\":{\"h\":\"\",\"t\":[\"展示 分支B拥有而分支A没有的所有提交。\"]},\"121\":{\"h\":\"git log\",\"t\":[\": git log三点(…)比较的两个分支 。\",\"展示 分支B拥有而分支A没有的所有提交，以及，分支A拥有而分支B没有的所有提交。\",\"网上流传的原图都包浆了，太丑了，重新绘制(不带水印！)\"]},\"122\":{\"h\":\"\",\"t\":[\"可在分支、commit之间执行 diff。\",\"# 命令格式 # 空格 和 .. 比较等价 git diff [<branch> | <commit>] [<branch> | <commit>] git diff [<branch> | <commit>]..[<branch> | <commit>] git diff [<branch> | <commit>]...[<branch> | <commit>] # 正确✅ git diff testMater...testSun # 错误❌ # 注: git 两点diff 和三点diff 的 \\\"点(.)\\\" 前后不能有空格 git diff testMater ... testSun \"]},\"123\":{\"h\":\"\",\"t\":[\"ps: 虽然二者逻辑结果相同，但仍有细微差别，log三点比较没有前后顺序之分(即 git log A...B 与 git log B...A 结果完全一致)，但diff两点比较( git diff A..B 与 git diff B..A )虽然逻辑结果相同，但实际执行返回结果是不同的，体现在交换顺序后， -> ， -> \"]},\"124\":{\"h\":\"\",\"t\":[\"在 Git 中，文件可以分为以下几类：\",\"已修改文件(modified)：在 工作区(workspace) 中已修改，但尚未添加到 暂存区(stage) 的文件。\",\"已暂存文件(staged)：已通过 git add 命令添加到 暂存区(stage) 的新增/已修改文件。\",\"未修改文件(unmodified)：如名。\",\"未追踪文件(Untracked)：在Git工作区中存在，但尚未添加到Git版本控制系统中的文件。\",\"忽略文件(Ignored)：.gitignore文件中指定的文件，这些文件不会被 Git 跟踪，也不会显示在 未追踪文件(Untracked) 中。\",\"# 使用git status 可查看到标颜色文件 git status \"]},\"125\":{\"h\":\"工作区(workspace)命令\",\"t\":[\"# 销毁 工作区(workspace) 文件变动/更改 # -d：同时删除未被跟踪的目录。 # -f 或 --force：强制执行删除操作，不再提示确认 git clean -df # 查看 工作区(workspace) 文件变动/更改 # 注: 使用该命令无法检测到 未追踪文件(Untracked file) git diff # -n: 用于查看未追踪文件(Untracked)列表 git clean -n \"]},\"126\":{\"h\":\"暂存区(stage)命令\",\"t\":[\"# 将 暂存区(stage) 文件变动/更改回退至 工作区(workspace) git reset git restore --staged . # 销毁 暂存区(stage) 内容 git stash git stash drop # 查看 暂存区(stage) 内容(对比 暂存区(stage) 与 工作区(workspace) 的差异) git diff [--staged | --cached] # 查看某个文件在 暂存区(stage) 与 工作区(workspace) 的差异 git diff [--staged | --cached] <file-path> \"]},\"127\":{\"h\":\"本地仓库(Repository)命令\",\"t\":[\"# 比较本地分支与远程分支差异 # 注: 注意两点比较和三点比较的区别 git diff main..origin/main \"]},\"128\":{\"h\":\"清除远程分支引用\",\"t\":[\"# 清理本地仓库中已被删除的远程分支引用，可使用以下2条命令的任意一条 git remote prune origin git fetch --prune \"]},\"129\":{\"h\":\"参考文献\",\"t\":[\"https://stackoverflow.com/questions/7251477/what-are-the-differences-between-double-dot-and-triple-dot-in-git-dif\",\"https://stackoverflow.com/questions/462974/what-are-the-differences-between-double-dot-and-triple-dot-in-git-com\",\"https://juejin.cn/post/6869519303864123399\"]},\"130\":{\"c\":[\"中间件\"]},\"131\":{\"c\":[\"git\"]},\"132\":{\"h\":\"git rebase命令详解\",\"t\":[\"浅析git rebase命令的作用、使用方法、适用场景以及和merge命令的区别\"]},\"133\":{\"h\":\"一、文章梗概\"},\"134\":{\"h\":\"二、rebase(变基)与merge(合并)区别\",\"t\":[\"在开发过程中，经常遇到的一个场景是要将个人开发的feature分支 pull request 到master分支，但master分支又已经有了新的变更，pull request存在代码冲突(conflict)。面对这种情况通常有2种处理方式:\",\"将master分支的最新提交 合并(merge) 到feature分支， 合并(merge) 过程中解决冲突。\",\"在feature分支上执行 变基(rebase master)，变基(rebase master) 过程中解决冲突。\",\"rebase与merge对比\",\"合并(merge) 操作会执行三路合并(c1、c4、c6)，并在feature分支生成一个合并后的新commit提交节点(c7)。 分支的合并痕迹可在git graph(执行命令 git log --oneline --graph --decorate)查看。\",\"变基(rebase) 操作会将feature分支的commit提交节点暂存下来，并以master分支的最新提交(HEAD)为新的基(base)，将暂存下的commit提交节点接到新的 基(base) 上，实现 变基(rebase)操作(c1 -> c6)。 可以看到，rebase操作没有新增commit提交，并且即使通过git graph查看也感知不到有将master分支最新提交整合至feature分支的操作。\",\"由于代码评审时，commit提交节点愈清晰愈好，且不应在feature分支增加不属于feature分支本身的commit提交；所以，在整合个人开发的feature分支时，推荐使用rebase，而非merge。: 只要冲突(conflict)处理方式相同，那么分别执行 merge(c7) 和 rebase(c4') 后的节点内容是完全相同的。\"]},\"135\":{\"h\":\"三、交互式rebase\",\"t\":[\"在日常开发中，rebase操作的正确使用姿态是 —— 使用交互式rebase，使用交互式rebase可以让操作执行者参与到git rebase操作的整个过程，更加精确的实现commit提交的压缩、拆分、重排、修改和丢弃等操作。\"]},\"136\":{\"h\":\"3.1、rebase操作命令\",\"t\":[\"在feature分支上执行 git rebase -i master 后会出现如下内容： 其中 c2、c3、c4 分别表示feature分支创建后的3次新commit提交。 通过修改文件内容可以实现：\",\"调整commit提交顺序\",\"销毁某次commit提交(drop)\",\"合并多个commit提交(squash) squash命令会将当前commit提交合并(压缩)到上一个commit提交中，合并后的“新”commit提交会有新的commit哈希值。\",\"修改commit提交的描述信息(reword)\",\"修改commit提交的描述信息和内容(edit)\",\"不希望真正执行变基, 但又需要整理commit提交历史的场景(伪变基)\",\"可根据实际情况将上述操作结合使用\"]},\"137\":{\"h\":\"3.2、rebase: edit命令与reword命令区别\",\"t\":[\"reword： 使用 reword 命令，可以修改提交的描述信息(msg)，但无法修改提交内容。 使用 reword 命令时，git会打开一个编辑器，可在编辑器内修改commit提交的描述信息。完成后，git会创建一个替换原commit提交的hash值不同的“新”提交。\",\"edit： 使用 edit 命令，可以修改提交的描述信息(msg)以及提交内容。edit命令不同使用场景处理方法：\",\"没有修改commit提交内容(如新增、修改和删除文件内容等)，但要修改commit提交的描述信息(msg)处理方法: 此时只能通过 git commit --amend 修改提交描述信息。\",\"修改了commit提交内容(已通过 git add 添加至 暂存区(stage))，同时要修改commit提交的描述信息(msg)处理方法(2种): \",\"执行 git commit --amend 修改提交描述信息，然后执行 git rebase --continue 命令继续rebase操作。\",\"直接执行 git rebase --continue 命令，如果之前没有执行过 git commit --amend 命令，则git会打开一个编辑器，可在编辑器内修改commit提交的描述信息。\",\"补充说明： 使用 edit 命令时，git 会暂停 rebase 过程，并将当前分支的 HEAD 指向选中提交。此时，可以使用 git commit --amend 命令修改选中提交的描述信息。: --amend 参数项只能修改 最近一次提交(HEAD) 的描述信息，但由于 HEAD 此时正指向 edit 命令对应的提交，所以，可以使用 --amend 参数项。\"]},\"138\":{\"h\":\"四、场景实践\"},\"139\":{\"h\":\"4.1、伪变基-修改指定分支的commit提交描述信息(reword)\",\"t\":[\"# 命令解释: # commitId: 要修改提交信息的commit提交的哈希值 # ~1: git引用操作符，表示选择该提交的父提交作为基来进行伪变基操作 git rebase -i [commitId]~1 \",\"e.g. 修改commitId为 1c6ce75 的提交描述信息\",\"操作流程如下:\"]},\"140\":{\"h\":\"4.2、标记commit提交，实现rebase自动编排\",\"t\":[\"# 命令解释: # 使用 --fixup 或 --squash 参数项可对commit提交进行额外标记 git commit --fixup=[commitId] -m \\\"提交描述信息\\\" git commit --squash=[commitId] -m \\\"提交描述信息\\\" # 使用 --autosquash 参数项可对已标记的commit提交自动完成指令组装，将有标记的commit提交合并(压缩)到 --fixup 或 --squash 参数项对应的commit提交 git rebase -i [commitId] --autosquash \"]},\"141\":{\"h\":\"五、rebase优缺点\"},\"142\":{\"h\":\"优点\",\"t\":[\"整合master分支时，不会增加不属于feature分支本身的提交\",\"rebase可以使分支的提交历史变得整洁\",\"可以使用交互式rebase，更加精确的实现commit提交的压缩、拆分、重排、修改和丢弃等操作，掌控代码开发的全流程\"]},\"143\":{\"h\":\"缺点\",\"t\":[\"rebase会更改git提交历史，使得git操作历史难以回溯\",\"在公共分支上执行rebase可能会导致提交日志记录发生混乱(相同作者、时间、内容的commit重复出现等情况)\"]},\"144\":{\"h\":\"六、使用法则\",\"t\":[\"在个人开发的feature分支上执行 rebase(变基)，在公共分支上执行 merge(合并)。: 永远不要在多人协作(已被其他人引用)的公共分支(e.g. master分支)上执行rebase！！\"]},\"145\":{\"h\":\"七、参考文献\",\"t\":[\"https://www.bilibili.com/video/BV1Xb4y1773F/?spm_id_from=333.788\"]},\"146\":{\"c\":[\"中间件\"]},\"147\":{\"c\":[\"git\"]},\"148\":{\"h\":\"零拷贝\",\"t\":[\"描述零拷贝的底层原理\"]},\"149\":{\"h\":\"一、问题背景\",\"t\":[\"如何在磁盘IO成为性能瓶颈时，优化文件传输性能 ?\"]},\"150\":{\"h\":\"二、传统文件传输\"},\"151\":{\"h\":\"2.1、传统文件传输的问题\",\"t\":[\"早期的IO操作(传统文件传输)，内存与磁盘的数据传输都是由CPU来完成的，而此时CPU不能执行其他任务，会特别浪费CPU。\",\"服务端 → 客户端 文件传输\",\"4次「用户态」与「内核态」的上下文切换\",\"4次数据拷贝(2次DMA + 2次CPU拷贝)\"]},\"152\":{\"h\":\"2.2、可优化点\",\"t\":[\"减少「用户态与内核态的上下文切换」，即减少 系统调用 次数\",\"减少「内存拷贝」次数，用户缓冲区 在整个过程中是没有不必要存在的\"]},\"153\":{\"h\":\"三、零拷贝\",\"t\":[\"零拷贝-实现方式：\",\"mmap + write\",\"sendfile\",\"SG-DMA + sendfile\"]},\"154\":{\"h\":\"3.1、\",\"t\":[\"mmap系统调用会直接把内核缓冲区中的数据 映射 到 用户空间，这样 操作系统内核 和 用户空间 就不需要再进行任何的 数据拷贝 操作。\",\"mmap替换read，可减少1次数据拷贝过程。\",\"共需 4次上下文切换 + 3次数据拷贝(2次DMA + 1次CPU拷贝)。\",\"alt text\"]},\"155\":{\"h\":\"3.2、sendfile\",\"t\":[\"使用 sendfile 替代 read 和 write 两个系统调用，合并磁盘读取 + 网络发送两个操作，该系统调用可以直接把 内核缓冲区 中的数据拷贝至 Socket缓冲区，而无需拷贝至 用户空间。\",\"sendfile 替换 read & write，可减少 2次上下文切换 以及 1次数据拷贝。\",\"共需 2次上下文切换 + 3次数据拷贝(2次DMA拷贝 + 1次CPU拷贝)。\",\"然而以上均不是真正的零拷贝技术。\"]},\"156\":{\"h\":\"3.3、真正的零拷贝\",\"t\":[\"网卡支持 SG-DMA技术，可进一步减少通过CPU将 内核缓冲区 中的数据拷贝至 Socket缓冲区 的过程。\",\"共需要 2次上下文切换 + 2次数据拷贝(2次DMA拷贝)\",\"SG-DMA + sendfile 只需 2次数据拷贝，全程没有通过CPU来搬运数据，所有数据都是通过DMA传输。\",\"注意：零拷贝技术不允许进程对文件内容做进一步加工。\"]},\"157\":{\"h\":\"四、零拷贝应用\",\"t\":[\"消息队列中间件 Kafka\",\"负载均衡中间件 Nginx\"]},\"158\":{\"h\":\"五、参考文献\",\"t\":[\"https://xiaolincoding.com/os/8_network_system/zero_copy.html#_9-1-什么是零拷贝\"]},\"159\":{\"c\":[\"中间件\"]},\"160\":{\"c\":[\"os\"]},\"161\":{\"h\":\"SQL调优\"},\"162\":{\"h\":\"零、SQL优化-思维导图\"},\"163\":{\"h\":\"一、SQL优化原则\",\"t\":[\"核心优化原则/目标只有1条，，尤其是在对性能要求非常苛刻的情况下，最好将 计算逻辑/数据操作 交给java/python/Go等程序语言来实现。 SQL优化的本质是减少机器的 IO 和 CPU 的资源消耗。\"]},\"164\":{\"h\":\"二、常见SQL优化方法\",\"t\":[\"优化业务逻辑，减少查询范围 e.g. \",\"IN关键字后的元素个数不要太多\",\"范围查询 → 单次查询，转化为for训练批量请求\",\"DML尽量短小(Between … AND …)\",\"只返回必要字段(使用覆盖索引)，避免出现 **select ***\",\"优先考虑在 where & order by 涉及的列建立索引 应减少使用 order by：否则，若 索引不合适 & 符合条件记录较多 时，排序会消耗大量CPU、IO等资源，易引发性能问题\",\"避免在索引列上做 运算(>、+、- 、=) 或 使用 SQL函数操作(SUM、MAX)，应使用java/python/Go程序实现SQL函数逻辑\",\"避免使用 like\",\"避免使用 join\",\"优先用 JOIN 代替 IN 子查询\",\"update/delete 尽量根据 主键/唯一键 操作\",\"避免 隐式转换(类似于Java造型) 隐式转换会造成索引失效，常见情况: int 与 string 比较时发生；字符串不加单引号 会 隐式转换。 SQL数量类型 优先级由高到低\",\"Datetime > Float > Int > Text > Varchar > Binary \",\"少用 or(注: 使用OR的时候SQL可能仍然会走OR前后的所有索引)\",\"不要使用大偏移量的limit分页(如果业务逻辑需要支持大偏移量的limit分页，参见深分页问题)\",\"使用 != 或 <> 会导致全表扫描\",\"使用 group by 时，若无排序需求，建议加 ORDER BY NULL\",\"性能非常紧张时，最好不使用 group by、distinct、order by 等关键字，使用java/python/Go程序实现数据操作逻辑\",\"当已在where条件中正确使用索引 & 操作的数据量非常大时，使用 GROUP BY/distinct/ORDER BY 等仍然会产生额外的数据IO时间开销，导致数据库在处理大量数据时增加额外的计算成本，即使GROUP BY等操作在索引列上使用也不例外。故在性能非常紧张时，不要使用 GROUP BY/distinct/ORDER BY 等关键字，而是使用java/python/Go程序实现数据操作逻辑。\"]},\"165\":{\"c\":[\"db\"]},\"166\":{\"c\":[\"sql调优\"]},\"167\":{\"h\":\"MySQL索引\",\"t\":[\"描述MySQL的索引结构、创建原则、优化实践经验\"]},\"168\":{\"h\":\"零、MySQL索引思维导图\"},\"169\":{\"h\":\"一、基础概念\",\"t\":[\"操作系统-页(Page): 操作系统会将 物理/虚拟内存 分割成大小相等的 页(Page)，用于内存管理和分配。常见页(Page)大小通常为4KB、8KB等。\",\"MySQL-页(Page): MySQL中的页通常指的是InnoDB存储引擎中的数据页，每个数据页中包含多条 行记录。常见页(Page)大小为16KB。\",\"局部性原理: 程序在访问某个数据/指令时，很可能会紧接着访问相邻的数据/指令。\",\"预读: 根据\\\"局部性原理\\\"，操作系统常会在进行磁盘IO时，会进行\\\"预读\\\"；即1次磁盘IO操作不光会读取请求的目标数据块(block0)到内存，还会读取与目标数据块相邻的数据块(block1、block2)到内存，以提升数据访问效率。\",\"磁盘&内存IO速度差异: \"]},\"170\":{\"h\":\"二、索引分类\"},\"171\":{\"h\":\"2.1、按 划分\",\"t\":[\"InnoDB中B+树索引可以分为聚集索引 和 辅助索引，区别在于 叶子结点存储的是否是完整的行记录。\",\"主键索引(聚集索引) 聚集索引 按照表的 主键(PK) 构造一棵B+树，叶子结点 存储一条完整的行记录，聚集索引的 1个叶子结点 就是MySQL的 1个数据页；同时，每个 叶子结点 之间都通过 双向链表 进行连接。 因此，使用主键索引执行 主键排序 和 主键范围查找 的速度很快。\",\"二级索引(辅助索引) 二级索引 按照 用户指定列(单/多列) 构造一棵B+树，叶子结点只存储一条行记录的部分数据(主键(PK) + 用户指定列)，存储引擎会先在辅助索引中定位到具体的叶子结点，然后获取到叶子结点中存储的主键(PK)值，最后，再通过回表(如有必要)，在主键索引获取到一条完整的行记录。\"]},\"172\":{\"h\":\"2.2、按 划分\",\"t\":[\"普通索引\",\"唯一索引(unique index)\",\"复合(联合)索引: 区分度越高的列越应该放在前面，最左匹配原则(索引创建原则)\",\"前缀索引\",\"虚拟列索引\"]},\"173\":{\"h\":\"2.3、回表 & 覆盖索引\",\"t\":[\"回表 指通过辅助索引无法查询到本次要查询的所有字段，则根据辅助索引叶子结点中的主键(PK)值，再到主键索引中进行一次查询，获取到叶子结点的一条完整的行记录。这个操作称为「回表」。\",\"覆盖索引 覆盖索引是一种 数据查询方式，不是具体的哪一类索引。若辅助索引中包含本次查询的所有字段，只通过 辅助索引 就能拿到结果，而 无需「回表」。则称本次查询使用了覆盖索引。\",\"-- 建立复合索引(name, age) CREATE INDEX idx_name_age ON user(username, age); -- 覆盖索引查询: 要查询的字段均存在于索引树结点的数据项中 select username, age from user where username = 'lihua'; -- phone_number列值不在 idx_name_age复合索引中, 故需「回表」 select username, age, phone_number from user where username = 'lihua'; \"]},\"174\":{\"h\":\"三、索引结构\",\"t\":[\"下面分析几种索引结构的差异。\"]},\"175\":{\"h\":\"3.1、Hash索引\",\"t\":[\"InnoDB中支持的Hash索引是 自适应的，InnoDB会根据表的使用情况自动为表生成 Hash索引；不能人为干预是否在一张表中生成 Hash索引。InnoDB会监控对表上辅助索引的查找，若发现某辅助索引被频繁访问，则辅助索引会成为热🔥数据；并建立哈希索引，提升访问速度。\",\"特点:\",\"无序，无树高\",\"降低对辅助索引的访问频次\",\"自适应\",\"缺点:\",\"会占用 InnoDB buffer pool 资源\",\"仅支持等值查询，不支持范围查找\",\"无法用于排序\",\"有冲突可能\"]},\"176\":{\"h\":\"3.2、B树索引\",\"t\":[\"所有键值分布在整个树中\",\"任何关键字出现且只出现在一个节点中\",\"搜索有可能在非叶子节点结束\",\"在关键字全集内做一次查找，性能逼近二分查找算法\",\"操作系统页大小=MySQL页大小时的B树\",\"B+树与B树的不同 （1）B+树将完整行记录存储在叶子节点，非叶子节点只存储索引结点数据。 （2）B+树的叶子节点之间使用双向链表进行连接。\"]},\"177\":{\"h\":\"3.3、B+树索引\",\"t\":[\"B+树的每个结点都是1个InnoDB页\",\"只有叶子结点存储真实数据，非叶子结点存储指针(非真实数据) 因为1页磁盘块大小固定，因此一旦把真实数据放到非叶子结点，那么树高势必会增加；这也是为什么索引字段应该尽量小的原因\",\"1次IO操作 读取 1个B+树结点(即，1个操作系统-页(Page))\",\"IO次数取决于B+树的高度h，若当前表的数据大小为N，1页磁盘块的数据项的数量为m，则 树高 为 h=logm+1N​；当数据量N一定时，m越大，h越小\",\"索引的最左匹配特性 若B+树的索引结构为 复合索引(e.g. id, name, age)；则B+树会按照从左至右顺序建树，只有先确定id，才能确定name；若查询条件只有(id, age)，则索引会在id匹配完后停止匹配\"]},\"178\":{\"h\":\"四、不同存储引擎下的索引结构\"},\"179\":{\"h\":\"4.1、MyISAM引擎\",\"t\":[\"MyISAM引擎下，表可以没有主键。\"]},\"180\":{\"h\":\"4.1.1、聚集索引\",\"t\":[\"MyISAM引擎使用B+Tree作为索引结构，叶子节点的data域存放的是数据记录的地址。\"]},\"181\":{\"h\":\"4.1.2、辅助索引\",\"t\":[\"在MyISAM中，主索引和辅助索引在结构上没有任何区别，只是 主索引要求key是唯一的，而辅助索引的key可以重复。\"]},\"182\":{\"h\":\"4.2、InnoDB引擎\",\"t\":[\"InnoDB要求 表必须有主键。\"]},\"183\":{\"h\":\"4.2.1、聚集索引\",\"t\":[\"，叶子节点的data域包含 完整的行记录数据。\"]},\"184\":{\"h\":\"4.2.2、辅助索引\",\"t\":[\"InnoDB的辅助索引，引用主键(PK)作为叶子结点的data域。\"]},\"185\":{\"h\":\"4.3、InnoDB和MyISAM引擎区别\",\"t\":[\"主键(PK)\",\"MySQL引擎 表必须有索引\",\"MyISAM引擎 表可以没有索引\",\"索引\",\"聚集索引： \",\"InnoDB引擎 数据文件本身就是索引文件\",\"MyISAM引擎 索引和数据是分开的\",\"辅助索引： \",\"InnoDB的辅助索引data域存储相应记录主键的值而不是地址\",\"MyISAM的辅助索引和主索引没有多大区别\"]},\"186\":{\"h\":\"五、FAQ\"},\"187\":{\"h\":\"5.1、复合(联合)索引是如何构建B+树的?\",\"t\":[\"ans: 下图出自《高性能MySQL 3rd Edition》\",\"e.g. 表结构 为(a int, b int, c int)，索引结构 为(a, b)，则联合索引结构如下。\"]},\"188\":{\"h\":\"5.2、索引与索引个数的关系?\",\"t\":[\"ans:\",\"建立复合索引只会建立1棵B+树，若复合索引顺序 或 字段不同，则会建立多棵B+树。\",\"多个列分别建立索引，则每个列会分别建立一棵B+树，有几个列就有几个B+树。\"]},\"189\":{\"h\":\"5.3、索引下推是什么?\",\"t\":[\"ans: 在有限范围内进行比较，减少回表次数。\"]},\"190\":{\"h\":\"5.4、SQL字符串如何比较大小?\",\"t\":[\"ans: 从字符串的第一个字符开始比较ASCII码值，如果相等则看下一个，以此类推; 小写字母的ASCII码 > 大写字母的ASCII码 > 数字 的ASCII码。\"]},\"191\":{\"h\":\"六、参考文献\",\"t\":[\"https://zhuanlan.zhihu.com/p/447472435\",\"https://blog.csdn.net/m0_49161353/article/details/120270845\",\"https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html\",\"https://dev.mysql.com/doc/refman/5.7/en/index-merge-optimization.html\",\"https://mp.weixin.qq.com/s/iVDIlhM94loH0b632fhJxw?poc_token=HOFQaWajEzk8t18tSgOpWJ37A40IBQcqZJB6foMb\",\"https://juejin.cn/post/6844903921450745863\",\"https://tech.meituan.com/2014/08/20/innodb-lock.html\",\"https://www.aneasystone.com/archives/2017/12/solving-dead-locks-three.html\",\"http://blog.codinglabs.org/articles/theory-of-mysql-index.html\",\"https://juejin.cn/post/6844904073955639304\",\"https://www.cs.usfca.edu/~galles/visualization/Algorithms.html\",\"https://juejin.cn/post/7129490960169304095\"]},\"192\":{\"c\":[\"中间件\"]},\"193\":{\"c\":[\"db\"]},\"194\":{\"h\":\"消息队列(MQ)-基础知识\",\"t\":[\"MQ基础知识、概念整理\"]},\"195\":{\"h\":\"一、使用场景\",\"t\":[\"异步处理\",\"流量控制\",\"服务解耦\",\"MQ缺点:\",\"增加延迟\",\"增加系统复杂度\",\"可能产生数据不一致问题\"]},\"196\":{\"h\":\"二、主流产品\"},\"197\":{\"h\":\"2.1、第一梯队\",\"t\":[\"RabbitMQ\",\"优点\",\"开箱即用(轻量级)\",\"Exchange模块(交换机)，支持路由配置\",\"客户端支持最多的编程语言\",\"支持AMQP协议\",\"缺点\",\"对消息积压支持不好，大量消息积压时性能急剧下降\",\"性能最差(几万～十几万/秒)\",\"开发语言Erlang学习曲线陡峭\",\"RocketMQ\",\"优点： \",\"性能(几十万/秒)、稳定性和可靠性都不错\",\"响应时延低(低延迟)\",\"金融级稳定性\",\"适合 在线业务\",\"缺点： \",\"周边生态系统相对较差\",\"Kafka\",\"优点： \",\"周边生态系统兼容性最好！\",\"异步收发性能最好(吞吐量高)！\",\"适合日志、监控、大数据、流计算\",\"缺点： \",\"同步响应时延较高(攒一波再发送/处理)\",\"不太适合在线业务\"]},\"198\":{\"h\":\"2.2、第二梯队\",\"t\":[\"ActiveMQ 最老牌消息队列，仅用于兼容旧系统\",\"ZeroMQ 更适合称为“基于消息队列的多线程网络库”\",\"Pulsar 特点: 存储 & 计算分离\"]},\"199\":{\"h\":\"三、消息模型\"},\"200\":{\"h\":\"3.1、队列模型\",\"t\":[\"任何一条消息只能被其中的一个消费者收到\"]},\"201\":{\"h\":\"3.2、发布-订阅模型(Publish-Subscribe Pattern)\",\"t\":[\"与队列模型最大区别：一份消息数据能不能被消费多次的问题\"]},\"202\":{\"h\":\"四、RabbitMQ消息模型\",\"t\":[\"使用 队列模型，通过 Exchange模块 实现发布-订阅模型功能。\",\" See Detail 使用 队列模型，通过 Exchange模块 实现 “发布-订阅模型” 中 “一份数据可被多个订阅者消费的的功能”。 \",\"Exchange模块决定将消息投递到哪个队列中，若同一份消息有多个消费者，则Exchange模块会将消息发送至多个队列。\"]},\"203\":{\"h\":\"五、RocketMQ/Kafka消息模型\",\"t\":[\"使用 发布-订阅模型\",\"每个 主题(Topic) 包含多个队列(Queue)/分区(Partition)，通过多个队列来实现多实例并行生产和消费。\",\"消息有序性：只能保证 队列层面 的消息有序性，主题层面无法保证消息严格有序。\",\"消息可靠性：“请求-确认”机制。\",\"生产 和 消费 过程中，分别有1次请求-确认机制。\"]},\"204\":{\"h\":\"六、消息队列基本概念\",\"t\":[\"生产者(Producer): 发布者(Publisher)\",\"消费组(Consumer Group): 订阅者(Subscriber)\",\"每个 消费组(Consumer Group) 都消费 主题(Topic) 中一份完整的消息(所有队列的全部消息)，不同消费组之间消费进度不受影响\",\"一个消费组中包含多个 消费者(Consumer)实例，同一组内的消费者是竞争消费关系\",\"同一消费组在每个队列上只能串行消费，多个队列加在一起就是并行消费，并行度就是队列数量\",\"某个队列在同一消费组中最多只能由一个消费者实例占用\",\"接4，分区 → 消费者: 1 : 1，消费者 → 分区: 1 : N\",\"Consumer Group 对应 Topic，Consumer对应Queue\",\"消费者(Consumer): 消费组下的消费实例\",\"消费位置(Consumer Offset): 记录消费组在当前队列的消费位置 \",\"每个消费组在每个队列上维护一个消费位置(注: 消费位置和消费者无关)\",\"消费位置一般保存在Broker中(RocketMQ/Kafka)\",\"主题(Topic): 服务端存放消息的容器\",\"队列(Queue)/分区(Partition): 一个主题包含多个队列/分区，通过队列/分区实现多实例并行生产和消费\",\"服务端(Broker): 存储队列的服务器\"]},\"205\":{\"h\":\"七、分布式事务\",\"t\":[\"常见分布式事务实现\",\"两阶段提交-2PC(Two-phase Commit)\",\"TCC(Try-Confirm-Cancel)\",\"事务消息\",\"消息队列通过 事务消息 实现分布式事务。\",\"步骤4 提交/回滚失败处理方案\",\"Kafka会直接抛出异常，用户自行解决，重试 or 其他。\",\"RocketMQ增加 事务反查机制 解决(业务代码提供反查接口)。\"]},\"206\":{\"h\":\"八、消息丢失 & 重复 & 积压\"},\"207\":{\"h\":\"消息丢失处理(消息可靠性传递)\"},\"208\":{\"h\":\"检测消息丢失的方法\",\"t\":[\"利用消息队列的 有序性 验证是否有消息丢失(使用 拦截器机制)\",\"注：\",\"多实例Producer，则每个Producer生成各自消息序号(带Producer标识)\",\"需指定队列/分区(Partition)，每个分区单独检测\",\"Consumer端按Producer检测序号连续性，Consumer实例数要与分区数量一致\"]},\"209\":{\"h\":\"消息生产-消费流程\",\"t\":[\"生产阶段 编写发送消息代码时，正确处理返回值或捕捉异常，即可保证消息不丢失\",\"存储阶段 将消息写入磁盘后，再给Producer返回确认响应 多Broker节点集群，则需至少将消息发送到2个以上节点，再给Producer返回响应\",\"消费阶段 执行完消费逻辑后，再返回消费确认响应\"]},\"210\":{\"h\":\"九、重复消息处理\",\"t\":[\"消息重复不可避免, 服务质量标准：\",\"At most once：至多一次(消息最多送达一次)，没有消息可靠性保证，允许丢消息\",\"At least once：至少一次，不允许丢失消息，但允许少量重复消息出现\",\"Exactly once：恰好一次，只会被送达一次，不允许丢失 & 重复\"]},\"211\":{\"h\":\"\",\"t\":[\"At least once + 幂等消费 = Exactly once\"]},\"212\":{\"h\":\"\",\"t\":[\"从消费业务逻辑设计入手，将 消费业务逻辑 设计成具备幂等性的操作，包括\",\"设置数据库唯一约束(unique key)\",\"为更新的数据设置前置条件(增加 版本号属性)\",\"记录并检查操作(Token机制 或 GUID) ，一般不建议使用\"]},\"213\":{\"h\":\"十、消息积压处理\"},\"214\":{\"h\":\"优化性能\",\"t\":[\"发送端：增加批量(提高吞吐量)、提高并发(降低时延) 消费端：\",\"系统设计时，保证消费性能高于生产端发送性能\",\"水平扩容，增加consumer实例，并与 队列/分区(Partition) 数量保持一致\"]},\"215\":{\"h\":\"问题排查\",\"t\":[\"问题：排查是否是消费失败(如消息格式异常)导致的一条消息反复消费的情况 ? 解决方案：消息队列中间件提供 “死信队列” 功能，自动把反复消费失败的消息丢到死信队列中，避免一条消息卡住队列。\"]},\"216\":{\"h\":\"十一、FAQ\"},\"217\":{\"h\":\"1、单个队列并行消费如何实现 ?\",\"t\":[\"此时，将 队列 : 消费者 置成 1 : N 即可。\",\"问题：消息空洞(e.g. 3个消费者实例读1个队列(Queue)中的5、6、7三条消息，6、7 ACK 返回但 5 ACK 未返回)\",\"解决方案：消息队列中间件提供 “重试队列” 功能，将5这条消息复制到重试队列，更新消费位置为8，继续消费。下次拉消息时，优先把重试队列中的消息给消费者。\"]},\"218\":{\"h\":\"2、如何保证消息的严格顺序 ？\",\"t\":[\"全局严格顺序：将队列数置为1即可。局部严格顺序：通过一致性哈希算法指定队列发送消息实现。\",\"http://juconcurrent.com/books-jksj-71-80/\",\"https://cwiki.apache.org/confluence/display/KAFKA/Kafka+Improvement+Proposals\",\"https://kafka.apache.org/documentation/#introduction\"]},\"219\":{\"c\":[\"中间件\"]},\"220\":{\"c\":[\"mq\"]},\"221\":{\"h\":\"\",\"t\":[\"404 Not Found\"]},\"222\":{\"h\":\"二分法\"},\"223\":{\"h\":\"抽样算法\"},\"224\":{\"h\":\"Docker\"},\"225\":{\"h\":\"哈希算法\"},\"226\":{\"h\":\"中断\"},\"227\":{\"h\":\"分页问题\"},\"228\":{\"h\":\"快速幂\"},\"229\":{\"h\":\"数学技巧\"},\"230\":{\"h\":\"Git基础知识\"},\"231\":{\"h\":\"Git\"},\"232\":{\"h\":\"Rebase使用解析\"},\"233\":{\"h\":\"零拷贝\"},\"234\":{\"h\":\"操作系统\"},\"235\":{\"h\":\"SQL优化\"},\"236\":{\"h\":\"数据库\"},\"237\":{\"h\":\"索引\"},\"238\":{\"h\":\"消息队列基础\"},\"239\":{\"h\":\"消息队列\"}},\"dirtCount\":0,\"index\":[[\"局部严格顺序\",{\"1\":{\"218\":1}}],[\"局部性原理\",{\"1\":{\"169\":2}}],[\"置成\",{\"1\":{\"217\":1}}],[\"置为false\",{\"1\":{\"81\":1,\"82\":1}}],[\"置为true\",{\"1\":{\"80\":1}}],[\"置为\",{\"1\":{\"79\":1}}],[\"功能\",{\"1\":{\"215\":1,\"217\":1}}],[\"功能尚未开发完成且不想进行commit\",{\"1\":{\"114\":1}}],[\"死信队列\",{\"1\":{\"215\":1}}],[\"水平扩容\",{\"1\":{\"214\":1}}],[\"保证消费性能高于生产端发送性能\",{\"1\":{\"214\":1}}],[\"保存所有commit记录\",{\"1\":{\"117\":1}}],[\"保存当前\",{\"1\":{\"114\":1}}],[\"保存\",{\"1\":{\"111\":2}}],[\"降低时延\",{\"1\":{\"214\":1}}],[\"降低对辅助索引的访问频次\",{\"1\":{\"175\":1}}],[\"十一\",{\"0\":{\"216\":1}}],[\"十\",{\"0\":{\"213\":1}}],[\"版本号属性\",{\"1\":{\"212\":1}}],[\"设置数据库唯一约束\",{\"1\":{\"212\":1}}],[\"设计成具备幂等性的操作\",{\"1\":{\"212\":1}}],[\"恰好一次\",{\"1\":{\"210\":1}}],[\"允许丢消息\",{\"1\":{\"210\":1}}],[\"九\",{\"0\":{\"210\":1}}],[\"编写发送消息代码时\",{\"1\":{\"209\":1}}],[\"拦截器机制\",{\"1\":{\"208\":1}}],[\"验证是否有消息丢失\",{\"1\":{\"208\":1}}],[\"利用消息队列的\",{\"1\":{\"208\":1}}],[\"检测消息丢失的方法\",{\"0\":{\"208\":1}}],[\"积压\",{\"0\":{\"206\":1}}],[\"八\",{\"0\":{\"206\":1}}],[\"业务代码提供反查接口\",{\"1\":{\"205\":1}}],[\"事务反查机制\",{\"1\":{\"205\":1}}],[\"事务消息\",{\"1\":{\"205\":2}}],[\"步骤4\",{\"1\":{\"205\":1}}],[\"步骤1\",{\"1\":{\"29\":1}}],[\"接4\",{\"1\":{\"204\":1}}],[\"某个队列在同一消费组中最多只能由一个消费者实例占用\",{\"1\":{\"204\":1}}],[\"某个commit的更改更为合适\",{\"1\":{\"118\":1}}],[\"订阅者\",{\"1\":{\"204\":1}}],[\"订阅模型功能\",{\"1\":{\"202\":1}}],[\"订阅模型\",{\"0\":{\"201\":1},\"1\":{\"202\":1,\"203\":1}}],[\"消费端\",{\"1\":{\"214\":1}}],[\"消费业务逻辑\",{\"1\":{\"212\":1}}],[\"消费阶段\",{\"1\":{\"209\":1}}],[\"消费流程\",{\"0\":{\"209\":1}}],[\"消费位置一般保存在broker中\",{\"1\":{\"204\":1}}],[\"消费位置和消费者无关\",{\"1\":{\"204\":1}}],[\"消费位置\",{\"1\":{\"204\":1}}],[\"消费者\",{\"1\":{\"204\":4,\"217\":1}}],[\"消费组下的消费实例\",{\"1\":{\"204\":1}}],[\"消费组\",{\"1\":{\"204\":2}}],[\"消费\",{\"1\":{\"203\":1}}],[\"消息空洞\",{\"1\":{\"217\":1}}],[\"消息积压处理\",{\"0\":{\"213\":1}}],[\"消息最多送达一次\",{\"1\":{\"210\":1}}],[\"消息重复不可避免\",{\"1\":{\"210\":1}}],[\"消息生产\",{\"0\":{\"209\":1}}],[\"消息丢失处理\",{\"0\":{\"207\":1}}],[\"消息丢失\",{\"0\":{\"206\":1}}],[\"消息可靠性传递\",{\"0\":{\"207\":1}}],[\"消息可靠性\",{\"1\":{\"203\":1}}],[\"消息有序性\",{\"1\":{\"203\":1}}],[\"消息模型\",{\"0\":{\"199\":1}}],[\"消息队列基础\",{\"0\":{\"238\":1}}],[\"消息队列基本概念\",{\"0\":{\"204\":1}}],[\"消息队列通过\",{\"1\":{\"205\":1}}],[\"消息队列\",{\"0\":{\"194\":1,\"239\":1}}],[\"消息队列中间件提供\",{\"1\":{\"215\":1,\"217\":1}}],[\"消息队列中间件\",{\"1\":{\"157\":1}}],[\"生产阶段\",{\"1\":{\"209\":1}}],[\"生产者\",{\"1\":{\"204\":1}}],[\"生产\",{\"1\":{\"203\":1}}],[\"生成一个范围在\",{\"1\":{\"30\":1}}],[\"机制\",{\"1\":{\"203\":1}}],[\"机器上的总数据量是不变的\",{\"1\":{\"46\":1}}],[\"确认机制\",{\"1\":{\"203\":1}}],[\"确认\",{\"1\":{\"203\":1}}],[\"请求\",{\"1\":{\"203\":1}}],[\"队列\",{\"1\":{\"204\":1,\"214\":1,\"217\":1}}],[\"队列层面\",{\"1\":{\"203\":1}}],[\"队列模型\",{\"0\":{\"200\":1},\"1\":{\"202\":2}}],[\"包含多个队列\",{\"1\":{\"203\":1}}],[\"包括\",{\"1\":{\"212\":1}}],[\"包括commitid\",{\"1\":{\"119\":1}}],[\"包括使用\",{\"1\":{\"117\":1}}],[\"发送端\",{\"1\":{\"214\":1}}],[\"发布者\",{\"1\":{\"204\":1}}],[\"发布\",{\"0\":{\"201\":1},\"1\":{\"202\":1,\"203\":1}}],[\"发现类中引用了尚未被加载至jvm中的类\",{\"1\":{\"73\":1}}],[\"任何一条消息只能被其中的一个消费者收到\",{\"1\":{\"200\":1}}],[\"任何关键字出现且只出现在一个节点中\",{\"1\":{\"176\":1}}],[\"攒一波再发送\",{\"1\":{\"197\":1}}],[\"同一消费组在每个队列上只能串行消费\",{\"1\":{\"204\":1}}],[\"同一组内的消费者是竞争消费关系\",{\"1\":{\"204\":1}}],[\"同步响应时延较高\",{\"1\":{\"197\":1}}],[\"同时要修改commit提交的描述信息\",{\"1\":{\"137\":1}}],[\"同时删除未被跟踪的目录\",{\"1\":{\"125\":1}}],[\"同时将线程中断标识置为\",{\"1\":{\"79\":1}}],[\"同时\",{\"1\":{\"46\":1,\"171\":1}}],[\"流计算\",{\"1\":{\"197\":1}}],[\"流量控制\",{\"1\":{\"195\":1}}],[\"监控\",{\"1\":{\"197\":1}}],[\"吞吐量高\",{\"1\":{\"197\":1}}],[\"周边生态系统兼容性最好\",{\"1\":{\"197\":1}}],[\"周边生态系统相对较差\",{\"1\":{\"197\":1}}],[\"金融级稳定性\",{\"1\":{\"197\":1}}],[\"低延迟\",{\"1\":{\"197\":1}}],[\"响应时延低\",{\"1\":{\"197\":1}}],[\"响应中断\",{\"1\":{\"81\":1,\"82\":1}}],[\"稳定性和可靠性都不错\",{\"1\":{\"197\":1}}],[\"几十万\",{\"1\":{\"197\":1}}],[\"几万～十几万\",{\"1\":{\"197\":1}}],[\"秒\",{\"1\":{\"197\":2}}],[\"支持amqp协议\",{\"1\":{\"197\":1}}],[\"支持路由配置\",{\"1\":{\"197\":1}}],[\"轻量级\",{\"1\":{\"197\":1}}],[\"开发语言erlang学习曲线陡峭\",{\"1\":{\"197\":1}}],[\"开箱即用\",{\"1\":{\"197\":1}}],[\"开始\",{\"1\":{\"30\":1}}],[\"服务质量标准\",{\"1\":{\"210\":1}}],[\"服务解耦\",{\"1\":{\"195\":1}}],[\"服务端存放消息的容器\",{\"1\":{\"204\":1}}],[\"服务端\",{\"1\":{\"151\":1,\"204\":1}}],[\"异步收发性能最好\",{\"1\":{\"197\":1}}],[\"异步处理\",{\"1\":{\"195\":1}}],[\"异常后\",{\"1\":{\"82\":1}}],[\"概念整理\",{\"1\":{\"194\":1}}],[\"~galles\",{\"1\":{\"191\":2}}],[\"~1\",{\"1\":{\"139\":2}}],[\"小写字母的ascii码\",{\"1\":{\"190\":1}}],[\"小于\",{\"1\":{\"24\":5}}],[\"字段不同\",{\"1\":{\"188\":1}}],[\"字符串不加单引号\",{\"1\":{\"164\":1}}],[\"字符串字面量是什么时候进入到字符串常量池\",{\"0\":{\"62\":1}}],[\"高性能mysql\",{\"1\":{\"187\":1}}],[\"高精度\",{\"1\":{\"104\":1}}],[\"作为叶子结点的data域\",{\"1\":{\"184\":1}}],[\"作用\",{\"1\":{\"80\":1,\"114\":1,\"115\":3}}],[\"引用主键\",{\"1\":{\"184\":1}}],[\"引入虚拟结点后\",{\"1\":{\"46\":1}}],[\"引入\",{\"1\":{\"46\":1}}],[\"完整的行记录数据\",{\"1\":{\"183\":1}}],[\"完成后\",{\"1\":{\"137\":1}}],[\"叶子节点的data域包含\",{\"1\":{\"183\":1}}],[\"叶子节点的data域存放的是数据记录的地址\",{\"1\":{\"180\":1}}],[\"叶子结点只存储一条行记录的部分数据\",{\"1\":{\"171\":1}}],[\"叶子结点\",{\"1\":{\"171\":2}}],[\"叶子结点存储的是否是完整的行记录\",{\"1\":{\"171\":1}}],[\"树高\",{\"1\":{\"177\":1}}],[\"读取\",{\"1\":{\"177\":1}}],[\"因为1页磁盘块大小固定\",{\"1\":{\"177\":1}}],[\"因此一旦把真实数据放到非叶子结点\",{\"1\":{\"177\":1}}],[\"因此\",{\"1\":{\"11\":1,\"29\":1,\"171\":1}}],[\"非真实数据\",{\"1\":{\"177\":1}}],[\"非叶子结点存储指针\",{\"1\":{\"177\":1}}],[\"非叶子节点只存储索引结点数据\",{\"1\":{\"176\":1}}],[\"资源\",{\"1\":{\"175\":1}}],[\"特点\",{\"1\":{\"175\":1,\"198\":1}}],[\"提高并发\",{\"1\":{\"214\":1}}],[\"提高吞吐量\",{\"1\":{\"214\":1}}],[\"提升访问速度\",{\"1\":{\"175\":1}}],[\"提交描述信息\",{\"1\":{\"140\":2}}],[\"提交人和提交时间描述等\",{\"1\":{\"119\":1}}],[\"提交\",{\"1\":{\"115\":1,\"137\":1,\"205\":1}}],[\"要查询的字段均存在于索引树结点的数据项中\",{\"1\":{\"173\":1}}],[\"要修改提交信息的commit提交的哈希值\",{\"1\":{\"139\":1}}],[\"建立复合索引只会建立1棵b+树\",{\"1\":{\"188\":1}}],[\"建立复合索引\",{\"1\":{\"173\":1}}],[\"建议加\",{\"1\":{\"164\":1}}],[\"获取到叶子结点的一条完整的行记录\",{\"1\":{\"173\":1}}],[\"联合\",{\"0\":{\"187\":1},\"1\":{\"172\":1}}],[\"复合索引\",{\"1\":{\"177\":1}}],[\"复合\",{\"0\":{\"187\":1},\"1\":{\"172\":1}}],[\"普通索引\",{\"1\":{\"172\":1}}],[\"双向链表\",{\"1\":{\"171\":1}}],[\"构造一棵b+树\",{\"1\":{\"171\":2}}],[\"聚集索引的\",{\"1\":{\"171\":1}}],[\"聚集索引\",{\"0\":{\"180\":1,\"183\":1},\"1\":{\"171\":2,\"185\":1}}],[\"辅助索引\",{\"0\":{\"181\":1,\"184\":1},\"1\":{\"171\":2,\"173\":1,\"185\":1}}],[\"划分\",{\"0\":{\"171\":1,\"172\":1}}],[\"按照\",{\"1\":{\"171\":1}}],[\"按照表的\",{\"1\":{\"171\":1}}],[\"按\",{\"0\":{\"171\":1,\"172\":1}}],[\"磁盘\",{\"1\":{\"169\":1}}],[\"还会读取与目标数据块相邻的数据块\",{\"1\":{\"169\":1}}],[\"还原现场\",{\"1\":{\"114\":1}}],[\"预读\",{\"1\":{\"169\":2}}],[\"很可能会紧接着访问相邻的数据\",{\"1\":{\"169\":1}}],[\"行记录\",{\"1\":{\"169\":1}}],[\"虚拟列索引\",{\"1\":{\"172\":1}}],[\"虚拟内存\",{\"1\":{\"169\":1}}],[\"虚拟节点\",{\"1\":{\"46\":2}}],[\"物理\",{\"1\":{\"169\":1}}],[\"物理机\",{\"1\":{\"46\":1}}],[\"页\",{\"1\":{\"169\":3,\"177\":1}}],[\"创建原则\",{\"1\":{\"167\":1}}],[\"导致的一条消息反复消费的情况\",{\"1\":{\"215\":1}}],[\"导致数据库在处理大量数据时增加额外的计算成本\",{\"1\":{\"164\":1}}],[\"导致出现while死循环\",{\"1\":{\"81\":1}}],[\"性能\",{\"1\":{\"197\":1}}],[\"性能最差\",{\"1\":{\"197\":1}}],[\"性能逼近二分查找算法\",{\"1\":{\"176\":1}}],[\"性能非常紧张时\",{\"1\":{\"164\":1}}],[\"性能瓶颈\",{\"1\":{\"87\":1}}],[\"少用\",{\"1\":{\"164\":1}}],[\"类似于java造型\",{\"1\":{\"164\":1}}],[\"类加载如何加载\",{\"1\":{\"73\":1}}],[\"类加载器结构\",{\"0\":{\"66\":1}}],[\"类加载流程\",{\"0\":{\"52\":1}}],[\"隐式转换会造成索引失效\",{\"1\":{\"164\":1}}],[\"隐式转换\",{\"1\":{\"164\":2}}],[\"隐式响应\",{\"1\":{\"81\":1}}],[\"唯一索引\",{\"1\":{\"172\":1}}],[\"唯一键\",{\"1\":{\"164\":1}}],[\"唯一一个可将线程\",{\"1\":{\"79\":1}}],[\"尽量根据\",{\"1\":{\"164\":1}}],[\"代替\",{\"1\":{\"164\":1}}],[\"代码切换至指定commitid版本\",{\"1\":{\"115\":1}}],[\"易引发性能问题\",{\"1\":{\"164\":1}}],[\"符合条件记录较多\",{\"1\":{\"164\":1}}],[\"索引下推是什么\",{\"0\":{\"189\":1}}],[\"索引与索引个数的关系\",{\"0\":{\"188\":1}}],[\"索引是如何构建b+树的\",{\"0\":{\"187\":1}}],[\"索引和数据是分开的\",{\"1\":{\"185\":1}}],[\"索引的最左匹配特性\",{\"1\":{\"177\":1}}],[\"索引结构\",{\"0\":{\"174\":1},\"1\":{\"187\":1}}],[\"索引创建原则\",{\"1\":{\"172\":1}}],[\"索引\",{\"0\":{\"237\":1},\"1\":{\"172\":1,\"185\":1}}],[\"索引分类\",{\"0\":{\"170\":1}}],[\"索引不合适\",{\"1\":{\"164\":1}}],[\"索引列\",{\"1\":{\"88\":1}}],[\"涉及的列建立索引\",{\"1\":{\"164\":1}}],[\"转化为for训练批量请求\",{\"1\":{\"164\":1}}],[\"范围查询\",{\"1\":{\"164\":1}}],[\"范围内的每个\",{\"1\":{\"29\":1}}],[\"常见分布式事务实现\",{\"1\":{\"205\":1}}],[\"常见页\",{\"1\":{\"169\":2}}],[\"常见情况\",{\"1\":{\"164\":1}}],[\"常见sql优化方法\",{\"0\":{\"164\":1}}],[\"常量池\",{\"2\":{\"64\":1}}],[\"计算分离\",{\"1\":{\"198\":1}}],[\"计算逻辑\",{\"1\":{\"163\":1}}],[\"计算anmodm\",{\"1\":{\"103\":1}}],[\"尤其是在对性能要求非常苛刻的情况下\",{\"1\":{\"163\":1}}],[\"负载均衡中间件\",{\"1\":{\"157\":1}}],[\"负载均衡层\",{\"0\":{\"43\":1}}],[\"所有队列的全部消息\",{\"1\":{\"204\":1}}],[\"所有键值分布在整个树中\",{\"1\":{\"176\":1}}],[\"所有数据都是通过dma传输\",{\"1\":{\"156\":1}}],[\"所以\",{\"1\":{\"134\":1,\"137\":1}}],[\"所以不会触发越界情况\",{\"1\":{\"24\":1}}],[\"所以满足条件的\",{\"1\":{\"24\":1}}],[\"全局严格顺序\",{\"1\":{\"218\":1}}],[\"全程没有通过cpu来搬运数据\",{\"1\":{\"156\":1}}],[\"全部\",{\"1\":{\"115\":3}}],[\"然而以上均不是真正的零拷贝技术\",{\"1\":{\"155\":1}}],[\"然后获取到叶子结点中存储的主键\",{\"1\":{\"171\":1}}],[\"然后执行\",{\"1\":{\"137\":1}}],[\"然后再与\",{\"1\":{\"94\":1}}],[\"然后再交给主表\",{\"1\":{\"93\":1}}],[\"替换\",{\"1\":{\"155\":1}}],[\"替代\",{\"1\":{\"155\":1}}],[\"该系统调用可以直接把\",{\"1\":{\"155\":1}}],[\"网卡支持\",{\"1\":{\"156\":1}}],[\"网络发送两个操作\",{\"1\":{\"155\":1}}],[\"网上流传的原图都包浆了\",{\"1\":{\"121\":1}}],[\"共需要\",{\"1\":{\"156\":1}}],[\"共需\",{\"1\":{\"154\":1,\"155\":1}}],[\"次数\",{\"1\":{\"152\":2}}],[\"系统调用\",{\"1\":{\"152\":1}}],[\"系统设计时\",{\"1\":{\"214\":1}}],[\"系统设计\",{\"2\":{\"96\":1}}],[\"减少回表次数\",{\"1\":{\"189\":1}}],[\"减少查询范围\",{\"1\":{\"164\":1}}],[\"减少\",{\"1\":{\"152\":2}}],[\"减少了回表次数\",{\"1\":{\"93\":1}}],[\"客户端支持最多的编程语言\",{\"1\":{\"197\":1}}],[\"客户端\",{\"1\":{\"151\":1}}],[\"内核缓冲区\",{\"1\":{\"155\":1,\"156\":1}}],[\"内核态\",{\"1\":{\"151\":1}}],[\"内存io速度差异\",{\"1\":{\"169\":1}}],[\"内存拷贝\",{\"1\":{\"152\":1}}],[\"内存与磁盘的数据传输都是由cpu来完成的\",{\"1\":{\"151\":1}}],[\"内容的commit重复出现等情况\",{\"1\":{\"143\":1}}],[\"内容\",{\"1\":{\"126\":2}}],[\"早期的io操作\",{\"1\":{\"151\":1}}],[\"传统文件传输的问题\",{\"0\":{\"151\":1}}],[\"传统文件传输\",{\"0\":{\"150\":1},\"1\":{\"151\":1}}],[\"传递中断\",{\"1\":{\"81\":3}}],[\"优先把重试队列中的消息给消费者\",{\"1\":{\"217\":1}}],[\"优先级由高到低\",{\"1\":{\"164\":1}}],[\"优先用\",{\"1\":{\"164\":1}}],[\"优先考虑在\",{\"1\":{\"164\":1}}],[\"优化性能\",{\"0\":{\"214\":1}}],[\"优化实践经验\",{\"1\":{\"167\":1}}],[\"优化业务逻辑\",{\"1\":{\"164\":1}}],[\"优化文件传输性能\",{\"1\":{\"149\":1}}],[\"优点\",{\"0\":{\"142\":1},\"1\":{\"197\":3}}],[\"七\",{\"0\":{\"145\":1,\"205\":1}}],[\"永远不要在多人协作\",{\"1\":{\"144\":1}}],[\"六\",{\"0\":{\"144\":1,\"191\":1,\"204\":1}}],[\"相同作者\",{\"1\":{\"143\":1}}],[\"使得git操作历史难以回溯\",{\"1\":{\"143\":1}}],[\"使用主键索引执行\",{\"1\":{\"171\":1}}],[\"使用java\",{\"1\":{\"164\":1}}],[\"使用or的时候sql可能仍然会走or前后的所有索引\",{\"1\":{\"164\":1}}],[\"使用覆盖索引\",{\"1\":{\"164\":1}}],[\"使用法则\",{\"0\":{\"144\":1}}],[\"使用交互式rebase可以让操作执行者参与到git\",{\"1\":{\"135\":1}}],[\"使用交互式rebase\",{\"1\":{\"135\":1}}],[\"使用方法\",{\"1\":{\"132\":1}}],[\"使用该命令无法检测到\",{\"1\":{\"125\":1}}],[\"使用git\",{\"1\":{\"124\":1}}],[\"使用注意事项⚠️\",{\"1\":{\"115\":1}}],[\"使用了覆盖索引\",{\"1\":{\"93\":1}}],[\"使用interrupt\",{\"1\":{\"81\":1}}],[\"使用自定义类加载器加载string\",{\"1\":{\"73\":1}}],[\"使用自定义类加载器解析mybatis注解\",{\"0\":{\"69\":1}}],[\"使用\",{\"1\":{\"46\":1,\"82\":1,\"93\":1,\"94\":1,\"111\":3,\"118\":1,\"137\":4,\"140\":2,\"155\":1,\"164\":4,\"202\":2,\"203\":1,\"208\":1}}],[\"使用场景以及处理原则\",{\"1\":{\"77\":1}}],[\"使用场景\",{\"0\":{\"195\":1},\"1\":{\"43\":1,\"114\":1,\"115\":1}}],[\"使用二分答案写法思维难度更低\",{\"1\":{\"24\":1}}],[\"缺点\",{\"0\":{\"143\":1},\"1\":{\"175\":1,\"197\":3}}],[\"掌控代码开发的全流程\",{\"1\":{\"142\":1}}],[\"整合master分支时\",{\"1\":{\"142\":1}}],[\"整数n的二进制位数\",{\"1\":{\"100\":1}}],[\"标记commit提交\",{\"0\":{\"140\":1}}],[\"参见深分页问题\",{\"1\":{\"164\":1}}],[\"参数项对应的commit提交\",{\"1\":{\"140\":1}}],[\"参数项可对已标记的commit提交自动完成指令组装\",{\"1\":{\"140\":1}}],[\"参数项可对commit提交进行额外标记\",{\"1\":{\"140\":1}}],[\"参数项\",{\"1\":{\"137\":1}}],[\"参数项只能修改\",{\"1\":{\"137\":1}}],[\"参考文献\",{\"0\":{\"4\":1,\"19\":1,\"25\":1,\"36\":1,\"48\":1,\"55\":1,\"74\":1,\"83\":1,\"95\":1,\"105\":1,\"129\":1,\"145\":1,\"158\":1,\"191\":1}}],[\"补充说明\",{\"1\":{\"137\":1}}],[\"直接执行\",{\"1\":{\"137\":1}}],[\"直至bootstrapclassloader调用findloadedclass方法时\",{\"1\":{\"73\":1}}],[\"直至两者相等\",{\"1\":{\"24\":2}}],[\"直至与right相等\",{\"1\":{\"24\":2}}],[\"伪变基\",{\"0\":{\"139\":1},\"1\":{\"136\":1}}],[\"新\",{\"1\":{\"136\":1,\"137\":1}}],[\"新增\",{\"1\":{\"46\":1,\"111\":1}}],[\"压缩\",{\"1\":{\"136\":1,\"140\":1}}],[\"调整commit提交顺序\",{\"1\":{\"136\":1}}],[\"修改commitid为\",{\"1\":{\"139\":1}}],[\"修改commit提交的描述信息和内容\",{\"1\":{\"136\":1}}],[\"修改commit提交的描述信息\",{\"1\":{\"136\":1}}],[\"修改指定分支的commit提交描述信息\",{\"0\":{\"139\":1}}],[\"修改了commit提交内容\",{\"1\":{\"137\":1}}],[\"修改提交描述信息\",{\"1\":{\"137\":2}}],[\"修改和删除文件内容等\",{\"1\":{\"137\":1}}],[\"修改和丢弃等操作\",{\"1\":{\"135\":1,\"142\":1}}],[\"修改文件\",{\"1\":{\"111\":1}}],[\"拆分\",{\"1\":{\"135\":1,\"142\":1}}],[\"交给java\",{\"1\":{\"163\":1}}],[\"交互式rebase\",{\"0\":{\"135\":1}}],[\"交换机\",{\"1\":{\"197\":1}}],[\"交换\",{\"1\":{\"29\":1,\"30\":1}}],[\"基于消息队列的多线程网络库\",{\"1\":{\"198\":1}}],[\"基础知识\",{\"0\":{\"194\":1}}],[\"基础概念\",{\"0\":{\"169\":1}}],[\"基\",{\"1\":{\"134\":1}}],[\"基本原理\",{\"1\":{\"99\":1}}],[\"过程中\",{\"1\":{\"203\":1}}],[\"过程中解决冲突\",{\"1\":{\"134\":2}}],[\"过程\",{\"1\":{\"137\":1}}],[\"过大\",{\"1\":{\"87\":1}}],[\"面对这种情况通常有2种处理方式\",{\"1\":{\"134\":1}}],[\"经常遇到的一个场景是要将个人开发的feature分支\",{\"1\":{\"134\":1}}],[\"合并磁盘读取\",{\"1\":{\"155\":1}}],[\"合并后的\",{\"1\":{\"136\":1}}],[\"合并多个commit提交\",{\"1\":{\"136\":1}}],[\"合并\",{\"0\":{\"134\":1},\"1\":{\"134\":3,\"144\":1}}],[\"变基\",{\"0\":{\"134\":1},\"1\":{\"134\":4,\"144\":1}}],[\"变动\",{\"1\":{\"111\":1,\"115\":3}}],[\"文章梗概\",{\"0\":{\"133\":1}}],[\"文件传输\",{\"1\":{\"151\":1}}],[\"文件变动\",{\"1\":{\"125\":2,\"126\":1}}],[\"文件可以分为以下几类\",{\"1\":{\"124\":1}}],[\"文件信息\",{\"1\":{\"111\":1}}],[\"适合日志\",{\"1\":{\"197\":1}}],[\"适合\",{\"1\":{\"197\":1}}],[\"适用场景以及和merge命令的区别\",{\"1\":{\"132\":1}}],[\"适配不同搜索区间的不同情况\",{\"1\":{\"24\":1}}],[\"强制执行删除操作\",{\"1\":{\"125\":1}}],[\"强制推送\",{\"1\":{\"113\":1}}],[\"销毁某次commit提交\",{\"1\":{\"136\":1}}],[\"销毁\",{\"1\":{\"125\":1,\"126\":1}}],[\"销毁暂存内容\",{\"1\":{\"114\":1}}],[\"也不会显示在\",{\"1\":{\"124\":1}}],[\"也可替换成空转的for消除try\",{\"1\":{\"80\":1}}],[\"也可基于思维难度更低的\",{\"1\":{\"24\":1}}],[\"也可不加\",{\"1\":{\"2\":1}}],[\"跟踪\",{\"1\":{\"124\":1}}],[\"忽略文件\",{\"1\":{\"124\":1}}],[\"未返回\",{\"1\":{\"217\":1}}],[\"未追踪文件\",{\"1\":{\"124\":2,\"125\":1}}],[\"未修改文件\",{\"1\":{\"124\":1}}],[\"未在蓄水池\",{\"1\":{\"30\":1}}],[\"体现在交换顺序后\",{\"1\":{\"123\":1}}],[\"结果完全一致\",{\"1\":{\"123\":1}}],[\"结束条件\",{\"1\":{\"24\":4}}],[\"结束条件为\",{\"1\":{\"24\":2}}],[\"比较时发生\",{\"1\":{\"164\":1}}],[\"比较本地分支与远程分支差异\",{\"1\":{\"127\":1}}],[\"比较等价\",{\"1\":{\"122\":1}}],[\"比较的两个分支\",{\"1\":{\"121\":1}}],[\"太丑了\",{\"1\":{\"121\":1}}],[\"展示\",{\"1\":{\"120\":1,\"121\":1}}],[\"前缀索引\",{\"1\":{\"172\":1}}],[\"前后不能有空格\",{\"1\":{\"119\":1,\"122\":1}}],[\"前k个样本\",{\"1\":{\"30\":1}}],[\"点\",{\"1\":{\"119\":1,\"122\":1}}],[\"错误❌\",{\"1\":{\"119\":1,\"122\":1}}],[\"正确处理返回值或捕捉异常\",{\"1\":{\"209\":1}}],[\"正确✅\",{\"1\":{\"119\":1,\"122\":1}}],[\"正确性证明\",{\"1\":{\"29\":1}}],[\"空格\",{\"1\":{\"119\":1,\"122\":1}}],[\"命令解释\",{\"1\":{\"139\":1,\"140\":1}}],[\"命令对应的提交\",{\"1\":{\"137\":1}}],[\"命令修改选中提交的描述信息\",{\"1\":{\"137\":1}}],[\"命令继续rebase操作\",{\"1\":{\"137\":1}}],[\"命令时\",{\"1\":{\"137\":2}}],[\"命令\",{\"0\":{\"125\":1,\"126\":1,\"127\":1},\"1\":{\"137\":4}}],[\"命令添加到\",{\"1\":{\"124\":1}}],[\"命令格式\",{\"1\":{\"119\":1,\"122\":1}}],[\"命令将\",{\"1\":{\"111\":3}}],[\"记录并检查操作\",{\"1\":{\"212\":1}}],[\"记录消费组在当前队列的消费位置\",{\"1\":{\"204\":1}}],[\"记录信息\",{\"1\":{\"119\":1}}],[\"记录上次查询结果\",{\"1\":{\"92\":1}}],[\"区别在于\",{\"1\":{\"171\":1}}],[\"区别\",{\"0\":{\"134\":1},\"1\":{\"118\":1}}],[\"区分度越高的列越应该放在前面\",{\"1\":{\"172\":1}}],[\"区分不同情况下的越界判断条件\",{\"1\":{\"24\":1}}],[\"区分越界条件\",{\"1\":{\"24\":1}}],[\"用户自行解决\",{\"1\":{\"205\":1}}],[\"用户指定列\",{\"1\":{\"171\":2}}],[\"用户空间\",{\"1\":{\"154\":2,\"155\":1}}],[\"用户缓冲区\",{\"1\":{\"152\":1}}],[\"用户态与内核态的上下文切换\",{\"1\":{\"152\":1}}],[\"用户态\",{\"1\":{\"151\":1}}],[\"用户可进一步调整后再手动commit\",{\"1\":{\"118\":1}}],[\"用于内存管理和分配\",{\"1\":{\"169\":1}}],[\"用于查看未追踪文件\",{\"1\":{\"125\":1}}],[\"用于保存现场\",{\"1\":{\"114\":1}}],[\"用于加快枚举速度\",{\"1\":{\"18\":1}}],[\"自动把反复消费失败的消息丢到死信队列中\",{\"1\":{\"215\":1}}],[\"自动commit至远程分支\",{\"1\":{\"118\":1}}],[\"自适应\",{\"1\":{\"175\":1}}],[\"自适应的\",{\"1\":{\"175\":1}}],[\"自定义类加载器\",{\"0\":{\"67\":1}}],[\"连续执行两次就和什么也没有执行是一样的\",{\"1\":{\"118\":1}}],[\"理解为\",{\"1\":{\"118\":1}}],[\"撤销↩️\",{\"1\":{\"118\":3}}],[\"撤回\",{\"1\":{\"115\":1,\"118\":1}}],[\"找到\",{\"1\":{\"117\":1}}],[\"找到commitid版本并恢复\",{\"1\":{\"115\":1}}],[\"才能确定name\",{\"1\":{\"177\":1}}],[\"才会有效果\",{\"1\":{\"115\":1}}],[\"才可以判断出string\",{\"1\":{\"73\":1}}],[\"尚未添加\",{\"1\":{\"115\":1}}],[\"默认\",{\"1\":{\"115\":1}}],[\"什么是零拷贝\",{\"1\":{\"158\":1}}],[\"什么是一致性哈希\",{\"1\":{\"48\":1}}],[\"什么也不会发生\",{\"1\":{\"115\":1}}],[\"|\",{\"1\":{\"115\":7,\"119\":4,\"122\":6,\"126\":2}}],[\"||\",{\"1\":{\"24\":2}}],[\"至少一次\",{\"1\":{\"210\":1}}],[\"至多一次\",{\"1\":{\"210\":1}}],[\"至暂存区\",{\"1\":{\"115\":1}}],[\"至\",{\"1\":{\"115\":4,\"118\":1}}],[\"至指定commitid版本\",{\"1\":{\"115\":2,\"118\":1}}],[\"至于收到中断信号的线程如何响应\",{\"1\":{\"80\":1}}],[\"回表\",{\"0\":{\"173\":1},\"1\":{\"173\":4}}],[\"回撤\",{\"1\":{\"116\":1}}],[\"回滚失败处理方案\",{\"1\":{\"205\":1}}],[\"回滚git\",{\"1\":{\"115\":1}}],[\"回滚\",{\"1\":{\"115\":5,\"118\":2}}],[\"回退的commit记录仍然可以通过\",{\"1\":{\"117\":1}}],[\"回退至\",{\"1\":{\"115\":1}}],[\"回退\",{\"1\":{\"115\":3,\"118\":1}}],[\"操作系统页大小=mysql页大小时的b树\",{\"1\":{\"176\":1}}],[\"操作系统常会在进行磁盘io时\",{\"1\":{\"169\":1}}],[\"操作系统会将\",{\"1\":{\"169\":1}}],[\"操作系统\",{\"0\":{\"234\":1},\"1\":{\"169\":1}}],[\"操作系统内核\",{\"1\":{\"154\":1}}],[\"操作的数据量非常大时\",{\"1\":{\"164\":1}}],[\"操作流程如下\",{\"1\":{\"139\":1}}],[\"操作会将feature分支的commit提交节点暂存下来\",{\"1\":{\"134\":1}}],[\"操作会执行三路合并\",{\"1\":{\"134\":1}}],[\"操作会\",{\"1\":{\"118\":1}}],[\"操作\",{\"1\":{\"115\":5,\"134\":1,\"154\":1,\"164\":1}}],[\"操作或处于睡眠状态的线程\",{\"1\":{\"82\":1}}],[\"推荐使用rebase\",{\"1\":{\"134\":1}}],[\"推荐使用场景\",{\"1\":{\"92\":1}}],[\"推送到\",{\"1\":{\"113\":1}}],[\"指通过辅助索引无法查询到本次要查询的所有字段\",{\"1\":{\"173\":1}}],[\"指令\",{\"1\":{\"169\":1}}],[\"指令时\",{\"1\":{\"169\":1}}],[\"指定commitid版本的提交\",{\"1\":{\"118\":1}}],[\"指定commitid的更改\",{\"1\":{\"118\":1}}],[\"指向选中提交\",{\"1\":{\"137\":1}}],[\"指向\",{\"1\":{\"111\":1}}],[\"指针\",{\"1\":{\"111\":1}}],[\"头\",{\"1\":{\"111\":1}}],[\"远程仓库的\",{\"1\":{\"113\":1}}],[\"远程仓库\",{\"1\":{\"111\":2}}],[\"待提交\",{\"1\":{\"111\":1}}],[\"临时存放文件的变动\",{\"1\":{\"111\":1}}],[\"暂存区\",{\"0\":{\"126\":1},\"1\":{\"111\":3,\"114\":1,\"115\":3,\"118\":2,\"124\":2,\"126\":5,\"137\":1}}],[\"工作区\",{\"0\":{\"125\":1},\"1\":{\"111\":3,\"115\":2,\"124\":1,\"125\":2,\"126\":3}}],[\"求解数字a的n次方\",{\"1\":{\"104\":1}}],[\"求base的exp次方\",{\"1\":{\"101\":1}}],[\"括号\",{\"1\":{\"103\":1}}],[\"运算\",{\"1\":{\"103\":1,\"164\":1}}],[\"运行结果\",{\"1\":{\"80\":1,\"81\":1,\"82\":2}}],[\"运行时常量池\",{\"1\":{\"62\":1}}],[\"幂等消费\",{\"1\":{\"211\":1}}],[\"幂取模\",{\"0\":{\"103\":1}}],[\"幂次分解\",{\"1\":{\"99\":1}}],[\"应使用java\",{\"1\":{\"164\":1}}],[\"应减少使用\",{\"1\":{\"164\":1}}],[\"应用1\",{\"0\":{\"103\":1}}],[\"应该将中断传递给被中断线程\",{\"1\":{\"81\":1}}],[\"题目描述\",{\"1\":{\"101\":1}}],[\"题源\",{\"1\":{\"101\":1}}],[\"牛客\",{\"1\":{\"101\":1}}],[\"快速幂应用\",{\"0\":{\"102\":1}}],[\"快速幂\",{\"0\":{\"101\":1,\"228\":1},\"1\":{\"104\":1},\"2\":{\"107\":1}}],[\"快速幂时间复杂度\",{\"0\":{\"100\":1},\"1\":{\"100\":1}}],[\"快速幂基本原理\",{\"0\":{\"99\":1}}],[\"快速幂算法\",{\"0\":{\"98\":1}}],[\"五\",{\"0\":{\"95\":1,\"141\":1,\"158\":1,\"186\":1,\"203\":1}}],[\"以此类推\",{\"1\":{\"190\":1}}],[\"以提升数据访问效率\",{\"1\":{\"169\":1}}],[\"以及提交内容\",{\"1\":{\"137\":1}}],[\"以及\",{\"1\":{\"121\":1,\"155\":1}}],[\"以下2条sql等价\",{\"1\":{\"94\":1}}],[\"以等概率选出k个样本\",{\"1\":{\"30\":1}}],[\"以等可能概率生成\",{\"1\":{\"29\":1}}],[\"详见此处\",{\"1\":{\"94\":1}}],[\"详解符号引用转直接引用\",{\"1\":{\"62\":1}}],[\"详解jvm公共内存域\",{\"0\":{\"54\":1}}],[\"详解jvm线程私有域\",{\"0\":{\"53\":1}}],[\"得物官方使用此方案解决深分页问题\",{\"1\":{\"94\":1}}],[\"做级联\",{\"1\":{\"94\":1}}],[\"值\",{\"1\":{\"94\":1,\"171\":1,\"173\":1}}],[\"覆盖索引查询\",{\"1\":{\"173\":1}}],[\"覆盖索引是一种\",{\"1\":{\"173\":1}}],[\"覆盖索引\",{\"0\":{\"173\":1},\"1\":{\"94\":1,\"173\":1}}],[\"关于深分页问题的解法\",{\"1\":{\"94\":1}}],[\"关键在于思想\",{\"1\":{\"24\":1}}],[\"关键看返回什么\",{\"1\":{\"24\":2}}],[\"阿里巴巴java开发手册\",{\"1\":{\"94\":1}}],[\"级联子查询\",{\"0\":{\"94\":1}}],[\"仍然有oom风险\",{\"1\":{\"93\":1}}],[\"京东认为\",{\"1\":{\"93\":1}}],[\"京东解法\",{\"1\":{\"93\":1}}],[\"没有消息可靠性保证\",{\"1\":{\"210\":1}}],[\"没有修改commit提交内容\",{\"1\":{\"137\":1}}],[\"没有这种写法\",{\"1\":{\"119\":1}}],[\"没有充分利用好子查询的定位\",{\"1\":{\"93\":1}}],[\"没有页码\",{\"1\":{\"92\":1}}],[\"这也是为什么索引字段应该尽量小的原因\",{\"1\":{\"177\":1}}],[\"这个操作称为\",{\"1\":{\"173\":1}}],[\"这样\",{\"1\":{\"154\":1}}],[\"这些文件不会被\",{\"1\":{\"124\":1}}],[\"这些方法时\",{\"1\":{\"81\":1}}],[\"这种也是更加方便的\",{\"1\":{\"116\":1}}],[\"这种做法\",{\"1\":{\"93\":1}}],[\"个版本\",{\"1\":{\"116\":1}}],[\"个人认为不够好\",{\"1\":{\"93\":1}}],[\"个元素\",{\"1\":{\"30\":1}}],[\"主题层面无法保证消息严格有序\",{\"1\":{\"203\":1}}],[\"主题\",{\"1\":{\"203\":1,\"204\":2}}],[\"主流产品\",{\"0\":{\"196\":1}}],[\"主索引要求key是唯一的\",{\"1\":{\"181\":1}}],[\"主索引和辅助索引在结构上没有任何区别\",{\"1\":{\"181\":1}}],[\"主键范围查找\",{\"1\":{\"171\":1}}],[\"主键排序\",{\"1\":{\"171\":1}}],[\"主键\",{\"1\":{\"164\":1,\"171\":2,\"185\":1}}],[\"主键列\",{\"1\":{\"93\":1}}],[\"主键索引\",{\"1\":{\"93\":1,\"171\":1}}],[\"主要是为了论证\",{\"1\":{\"29\":1}}],[\"子查询改造\",{\"1\":{\"93\":2}}],[\"子查询\",{\"0\":{\"93\":1},\"1\":{\"94\":1,\"95\":1,\"164\":1}}],[\"滑动加载下一页\",{\"1\":{\"92\":1}}],[\"通过一致性哈希算法指定队列发送消息实现\",{\"1\":{\"218\":1}}],[\"通过队列\",{\"1\":{\"204\":1}}],[\"通过多个队列来实现多实例并行生产和消费\",{\"1\":{\"203\":1}}],[\"通过\",{\"1\":{\"202\":2}}],[\"通过修改文件内容可以实现\",{\"1\":{\"136\":1}}],[\"通过点击页码数字跳转\",{\"1\":{\"92\":1}}],[\"通知\",{\"1\":{\"80\":2}}],[\"跳页\",{\"1\":{\"92\":1}}],[\"跳石头\",{\"0\":{\"14\":1}}],[\"条件\",{\"0\":{\"92\":1}}],[\"带producer标识\",{\"1\":{\"208\":1}}],[\"带\",{\"0\":{\"92\":1}}],[\"带虚拟结点\",{\"1\":{\"46\":2}}],[\"带虚拟节点的一致性哈希算法\",{\"0\":{\"46\":1}}],[\"表结构\",{\"1\":{\"187\":1}}],[\"表可以没有索引\",{\"1\":{\"185\":1}}],[\"表可以没有主键\",{\"1\":{\"179\":1}}],[\"表必须有索引\",{\"1\":{\"185\":1}}],[\"表必须有主键\",{\"1\":{\"182\":1}}],[\"表示选择该提交的父提交作为基来进行伪变基操作\",{\"1\":{\"139\":1}}],[\"表示当前版本\",{\"1\":{\"116\":1}}],[\"表主键id连续\",{\"0\":{\"91\":1}}],[\"表述\",{\"1\":{\"29\":1}}],[\"多broker节点集群\",{\"1\":{\"209\":1}}],[\"多实例producer\",{\"1\":{\"208\":1}}],[\"多个队列加在一起就是并行消费\",{\"1\":{\"204\":1}}],[\"多个列分别建立索引\",{\"1\":{\"188\":1}}],[\"多列\",{\"1\":{\"171\":1}}],[\"多分表\",{\"1\":{\"89\":1}}],[\"多mysql实例\",{\"1\":{\"89\":1}}],[\"场景实践\",{\"0\":{\"138\":1}}],[\"场景限制\",{\"1\":{\"92\":1}}],[\"场景\",{\"1\":{\"89\":2}}],[\"单个队列并行消费如何实现\",{\"0\":{\"217\":1}}],[\"单\",{\"1\":{\"171\":1}}],[\"单次查询\",{\"1\":{\"164\":1}}],[\"单机单表\",{\"1\":{\"89\":1}}],[\"单调性\",{\"1\":{\"24\":1}}],[\"再返回消费确认响应\",{\"1\":{\"209\":1}}],[\"再给producer返回响应\",{\"1\":{\"209\":1}}],[\"再给producer返回确认响应\",{\"1\":{\"209\":1}}],[\"再到主键索引中进行一次查询\",{\"1\":{\"173\":1}}],[\"再通过回表\",{\"1\":{\"171\":1}}],[\"再定位查找1遍\",{\"1\":{\"93\":1}}],[\"再比如\",{\"1\":{\"89\":1}}],[\"再在内存中聚合排序各分表的查询结果\",{\"1\":{\"89\":1}}],[\"✅\",{\"1\":{\"89\":1}}],[\"❌\",{\"1\":{\"89\":1}}],[\"原sql\",{\"1\":{\"93\":1}}],[\"原执行结果\",{\"1\":{\"89\":2}}],[\"原分页sql语句\",{\"1\":{\"89\":1}}],[\"改写后的正确sql\",{\"1\":{\"89\":1}}],[\"改写后的分页sql语句\",{\"1\":{\"89\":1}}],[\"改写分页sql语句\",{\"1\":{\"89\":1}}],[\"改为\",{\"1\":{\"46\":1}}],[\"下次拉消息时\",{\"1\":{\"217\":1}}],[\"下图出自\",{\"1\":{\"187\":1}}],[\"下面分析几种索引结构的差异\",{\"1\":{\"174\":1}}],[\"下一页按钮\",{\"1\":{\"92\":1}}],[\"下推到各个mysql实例的分表中执行\",{\"1\":{\"89\":1}}],[\"下标范围为\",{\"1\":{\"30\":1}}],[\"下标范围\",{\"1\":{\"29\":1}}],[\"下标为j\",{\"1\":{\"30\":1}}],[\"下标为k\",{\"1\":{\"29\":1}}],[\"下标为i\",{\"1\":{\"29\":2,\"30\":1}}],[\"下标\",{\"1\":{\"24\":20}}],[\"之间都通过\",{\"1\":{\"171\":1}}],[\"之间的随机数\",{\"1\":{\"30\":1}}],[\"之中\",{\"1\":{\"89\":1}}],[\"否则\",{\"1\":{\"164\":1}}],[\"否则无论怎样优化sql\",{\"1\":{\"88\":1}}],[\"否则会导致上层调⽤栈什么信息也获取不到\",{\"1\":{\"81\":1}}],[\"否则会出现查询不到数据的问题\",{\"1\":{\"44\":1}}],[\"必须早于\",{\"1\":{\"115\":2}}],[\"必须是\",{\"1\":{\"88\":1}}],[\"必须迁移改变了映射关系的数据\",{\"1\":{\"44\":1}}],[\"且不应在feature分支增加不属于feature分支本身的commit提交\",{\"1\":{\"134\":1}}],[\"且\",{\"1\":{\"115\":1}}],[\"且order\",{\"1\":{\"88\":1}}],[\"且中断标识为\",{\"1\":{\"79\":1}}],[\"排查是否是消费失败\",{\"1\":{\"215\":1}}],[\"排序会消耗大量cpu\",{\"1\":{\"164\":1}}],[\"排序字段要加索引\",{\"1\":{\"87\":1}}],[\"排列\",{\"1\":{\"29\":1}}],[\"语法\",{\"1\":{\"87\":1}}],[\"语句后吞掉了异常\",{\"1\":{\"81\":1}}],[\"查看某个文件在\",{\"1\":{\"126\":1}}],[\"查看\",{\"1\":{\"125\":1,\"126\":1,\"134\":1}}],[\"查看仓库分支的提交\",{\"1\":{\"119\":1}}],[\"查出符合条件的sql语句\",{\"1\":{\"94\":1}}],[\"查出符合条件的主键\",{\"1\":{\"94\":1}}],[\"查询结果\",{\"1\":{\"93\":1}}],[\"查询\",{\"0\":{\"92\":1}}],[\"查询性能都很难提升\",{\"1\":{\"88\":1}}],[\"查询偏移量\",{\"1\":{\"87\":1}}],[\"查找目标元素左边界\",{\"1\":{\"24\":1}}],[\"较大的时\",{\"1\":{\"87\":1}}],[\"偏移量\",{\"1\":{\"87\":1}}],[\"定义\",{\"1\":{\"87\":2}}],[\"浅分页\",{\"1\":{\"87\":2}}],[\"浅析git\",{\"1\":{\"132\":1}}],[\"浅析java线程中断机制\",{\"0\":{\"77\":1}}],[\"浅析jvm常量池\",{\"0\":{\"58\":1}}],[\"浅析二分答案问题模型\",{\"0\":{\"10\":1}}],[\"等仍然会产生额外的数据io时间开销\",{\"1\":{\"164\":1}}],[\"等关键字\",{\"1\":{\"164\":2}}],[\"等价于\",{\"1\":{\"87\":1}}],[\"等待\",{\"1\":{\"82\":1}}],[\"等方法判断中断状态\",{\"1\":{\"82\":1}}],[\"等于\",{\"1\":{\"24\":1}}],[\"释放锁\",{\"1\":{\"82\":2}}],[\"退出临界区\",{\"1\":{\"82\":2}}],[\"显示处理中断\",{\"1\":{\"82\":2}}],[\"显示响应\",{\"1\":{\"81\":1}}],[\"尝试获取锁\",{\"1\":{\"82\":2}}],[\"已被其他人引用\",{\"1\":{\"144\":1}}],[\"已通过\",{\"1\":{\"124\":1,\"137\":1}}],[\"已暂存文件\",{\"1\":{\"124\":1}}],[\"已修改文件\",{\"1\":{\"124\":2}}],[\"已添加\",{\"1\":{\"115\":1}}],[\"已提交\",{\"1\":{\"111\":1}}],[\"已进入临界区的程序\",{\"1\":{\"82\":1}}],[\"已进入临界区的线程无法被直接中断\",{\"1\":{\"82\":1}}],[\"已进⼊临界区的线程能否被中断\",{\"1\":{\"82\":1}}],[\"已在蓄水池中的元素\",{\"1\":{\"30\":1}}],[\"处于死锁状态的线程无法直接被中断\",{\"1\":{\"82\":1}}],[\"处在死锁状态的线程是否可以被中断\",{\"1\":{\"82\":1}}],[\"处理\",{\"1\":{\"197\":1}}],[\"处理方式相同\",{\"1\":{\"134\":1}}],[\"处理方法\",{\"1\":{\"81\":1,\"137\":2}}],[\"处理exp为负的情况\",{\"1\":{\"101\":1}}],[\"处理剩余的元素\",{\"1\":{\"30\":1}}],[\"吗\",{\"1\":{\"82\":1}}],[\"向⽅法调⽤栈的上层抛出受检异常\",{\"1\":{\"81\":1}}],[\"受检异常\",{\"1\":{\"81\":1}}],[\"就能拿到结果\",{\"1\":{\"173\":1}}],[\"就是mysql的\",{\"1\":{\"171\":1}}],[\"就不需要再进行任何的\",{\"1\":{\"154\":1}}],[\"就直接返回\",{\"1\":{\"93\":1}}],[\"就会抛出\",{\"1\":{\"81\":1}}],[\"就自动关闭\",{\"1\":{\"34\":1}}],[\"测试\",{\"1\":{\"81\":1}}],[\"避免一条消息卡住队列\",{\"1\":{\"215\":1}}],[\"避免\",{\"1\":{\"164\":1}}],[\"避免使用\",{\"1\":{\"164\":2}}],[\"避免在索引列上做\",{\"1\":{\"164\":1}}],[\"避免出现\",{\"1\":{\"164\":1}}],[\"避免忽略中断\",{\"1\":{\"81\":1}}],[\"避免溢出\",{\"1\":{\"2\":1}}],[\"重复消息处理\",{\"0\":{\"210\":1}}],[\"重复\",{\"0\":{\"206\":1},\"1\":{\"210\":1}}],[\"重试队列\",{\"1\":{\"217\":1}}],[\"重试\",{\"1\":{\"205\":1}}],[\"重排\",{\"1\":{\"135\":1,\"142\":1}}],[\"重新绘制\",{\"1\":{\"121\":1}}],[\"重新设置线程中断标识\",{\"1\":{\"81\":1}}],[\"重置中断标识\",{\"1\":{\"81\":1}}],[\"重置为\",{\"1\":{\"80\":1}}],[\"继续消费\",{\"1\":{\"217\":1}}],[\"继续向⽅法调⽤栈的上层抛出\",{\"1\":{\"81\":1}}],[\"继续执行\",{\"1\":{\"80\":1}}],[\"执行完消费逻辑后\",{\"1\":{\"209\":1}}],[\"执行命令\",{\"1\":{\"134\":1}}],[\"执行命令run一个容器\",{\"1\":{\"34\":1}}],[\"执行分页查询的sql语句称为\",{\"1\":{\"87\":1}}],[\"执行临界区操作\",{\"1\":{\"82\":2}}],[\"执行\",{\"1\":{\"81\":1,\"137\":1}}],[\"执行响应逻辑\",{\"1\":{\"81\":1}}],[\"程序在访问某个数据\",{\"1\":{\"169\":1}}],[\"程序中捕获的任何受检异常都不应该被吞掉\",{\"1\":{\"81\":1}}],[\"程序中捕获的interruptedexception中断异常\",{\"1\":{\"81\":1}}],[\"程序catch到受检异常interruptedexception后\",{\"1\":{\"81\":1}}],[\"程序逻辑中使用\",{\"1\":{\"81\":1}}],[\"程序示例\",{\"1\":{\"80\":1,\"81\":1,\"82\":2}}],[\"需指定队列\",{\"1\":{\"208\":1}}],[\"需使用\",{\"1\":{\"115\":1}}],[\"需要切换到其他分支处理问题\",{\"1\":{\"114\":1}}],[\"需要加\",{\"1\":{\"103\":1}}],[\"需要配合程序逻辑实现\",{\"1\":{\"92\":1}}],[\"需要\",{\"1\":{\"89\":1}}],[\"需要将\",{\"1\":{\"89\":1}}],[\"需要特别说明\",{\"1\":{\"80\":1}}],[\"需特别记忆\",{\"1\":{\"24\":1}}],[\"抛出interruptedexception受检异常\",{\"1\":{\"82\":1}}],[\"抛出interruptedexception异常后\",{\"1\":{\"80\":1}}],[\"抛出\",{\"1\":{\"80\":2,\"82\":1}}],[\"后会出现如下内容\",{\"1\":{\"136\":1}}],[\"后的节点内容是完全相同的\",{\"1\":{\"134\":1}}],[\"后\",{\"1\":{\"80\":2,\"118\":1}}],[\"均可感知到中断标识变化\",{\"1\":{\"80\":1}}],[\"凡是在方法声明中抛出\",{\"1\":{\"80\":1}}],[\"取决于代码对中断的响应\",{\"1\":{\"80\":1}}],[\"具体实现\",{\"1\":{\"92\":1}}],[\"具体执行怎样的逻辑\",{\"1\":{\"80\":1}}],[\"具备\",{\"1\":{\"24\":1}}],[\"无树高\",{\"1\":{\"175\":1}}],[\"无序\",{\"1\":{\"175\":1}}],[\"无需\",{\"1\":{\"173\":1}}],[\"无法用于排序\",{\"1\":{\"175\":1}}],[\"无法找到提交痕迹\",{\"1\":{\"115\":1}}],[\"无法响应中断\",{\"1\":{\"82\":1}}],[\"无法终止线程运行\",{\"1\":{\"80\":1}}],[\"无论是否使用带虚拟结点的一致性hash算法\",{\"1\":{\"46\":1}}],[\"挂起等\",{\"1\":{\"80\":1}}],[\"终止\",{\"1\":{\"80\":1}}],[\"协调\",{\"1\":{\"80\":1}}],[\"清理本地仓库中已被删除的远程分支引用\",{\"1\":{\"128\":1}}],[\"清除远程分支引用\",{\"0\":{\"128\":1}}],[\"清除\",{\"1\":{\"79\":1,\"115\":2}}],[\"清楚结束条件\",{\"1\":{\"24\":1}}],[\"分布式事务\",{\"0\":{\"205\":1}}],[\"分布式场景下\",{\"1\":{\"89\":1}}],[\"分布式场景下的分页查询\",{\"0\":{\"89\":1}}],[\"分别有1次请求\",{\"1\":{\"203\":1}}],[\"分别表示feature分支创建后的3次新commit提交\",{\"1\":{\"136\":1}}],[\"分区实现多实例并行生产和消费\",{\"1\":{\"204\":1}}],[\"分区\",{\"1\":{\"203\":1,\"204\":4,\"208\":1,\"214\":1}}],[\"分割成大小相等的\",{\"1\":{\"169\":1}}],[\"分支的合并痕迹可在git\",{\"1\":{\"134\":1}}],[\"分支a拥有而分支b没有的所有提交\",{\"1\":{\"121\":1}}],[\"分支b拥有而分支a没有的所有提交\",{\"1\":{\"120\":1,\"121\":1}}],[\"分支\",{\"1\":{\"113\":2}}],[\"分表\",{\"1\":{\"89\":1}}],[\"分页问题\",{\"0\":{\"227\":1}}],[\"分页问题优化前提\",{\"0\":{\"88\":1}}],[\"分页\",{\"1\":{\"91\":1},\"2\":{\"97\":1}}],[\"分页sql语句\",{\"1\":{\"89\":1}}],[\"分页查询\",{\"1\":{\"89\":1,\"92\":1}}],[\"分页场景下必须加\",{\"1\":{\"88\":1}}],[\"分析java线程中断的作用\",{\"1\":{\"77\":1}}],[\"分界点\",{\"1\":{\"24\":1}}],[\"yxhuang\",{\"1\":{\"74\":1}}],[\"yangliuhbhd\",{\"1\":{\"74\":1}}],[\"yates\",{\"0\":{\"29\":1}}],[\"当数据量n一定时\",{\"1\":{\"177\":1}}],[\"当已在where条件中正确使用索引\",{\"1\":{\"164\":1}}],[\"当前正在feature分支开发需求中\",{\"1\":{\"114\":1}}],[\"当前分支最新commit\",{\"1\":{\"115\":1}}],[\"当前分支\",{\"1\":{\"111\":1}}],[\"当前线程的中断标识会被清除\",{\"1\":{\"81\":1}}],[\"当可保证\",{\"1\":{\"91\":1}}],[\"当执行\",{\"1\":{\"89\":1}}],[\"当sql分页查询的\",{\"1\":{\"87\":1}}],[\"当offset值较小时\",{\"1\":{\"87\":1}}],[\"当线程被阻塞在\",{\"1\":{\"81\":1}}],[\"当其他线程调用另一个线程的\",{\"1\":{\"81\":1}}],[\"当自定义类加载需要加载的类中出现string\",{\"1\":{\"73\":1}}],[\"当使用appclassloader加载器加载某个类时\",{\"1\":{\"73\":1}}],[\"那么树高势必会增加\",{\"1\":{\"177\":1}}],[\"那么分别执行\",{\"1\":{\"134\":1}}],[\"那么是不是每次都需要基于双亲委派模型递归遍历\",{\"1\":{\"73\":1}}],[\"那么数据迁移量不是更大了嘛\",{\"1\":{\"46\":1}}],[\"线程状态\",{\"1\":{\"80\":1}}],[\"线程\",{\"1\":{\"80\":1}}],[\"线程中断标识一定会被清空\",{\"1\":{\"82\":1}}],[\"线程中断标识\",{\"1\":{\"79\":1}}],[\"线程上下文类加载器\",{\"0\":{\"70\":1}}],[\"线性筛\",{\"0\":{\"3\":1}}],[\"实例\",{\"1\":{\"204\":1}}],[\"实现分布式事务\",{\"1\":{\"205\":1}}],[\"实现发布\",{\"1\":{\"202\":1}}],[\"实现方式\",{\"1\":{\"153\":1}}],[\"实现rebase自动编排\",{\"0\":{\"140\":1}}],[\"实现\",{\"1\":{\"134\":1,\"202\":1}}],[\"实现函数\",{\"1\":{\"101\":1}}],[\"实际上它只是一个文件\",{\"1\":{\"111\":1}}],[\"实际节点\",{\"1\":{\"46\":1}}],[\"实践证明\",{\"1\":{\"80\":1}}],[\"实战学习\",{\"0\":{\"68\":1}}],[\"深刻理解\",{\"1\":{\"118\":1}}],[\"深分页优化\",{\"0\":{\"90\":1}}],[\"深分页\",{\"1\":{\"87\":2}}],[\"深分页问题\",{\"0\":{\"86\":1}}],[\"深度解析jvm类加载机制\",{\"0\":{\"65\":1}}],[\"深拷贝\",{\"1\":{\"29\":1}}],[\"usfca\",{\"1\":{\"191\":2}}],[\"username\",{\"1\":{\"173\":5}}],[\"user\",{\"1\":{\"173\":3}}],[\"using\",{\"1\":{\"103\":1,\"104\":1}}],[\"update\",{\"1\":{\"164\":1}}],[\"unique\",{\"1\":{\"172\":1,\"212\":1}}],[\"untracked\",{\"1\":{\"124\":2,\"125\":2}}],[\"unmodified\",{\"1\":{\"124\":1}}],[\"unlock\",{\"1\":{\"82\":2}}],[\"understanding\",{\"1\":{\"55\":1}}],[\"utm\",{\"1\":{\"36\":2,\"74\":1}}],[\"util\",{\"1\":{\"30\":1}}],[\"q\",{\"1\":{\"82\":4}}],[\"queue\",{\"1\":{\"203\":1,\"204\":1,\"217\":1}}],[\"question\",{\"1\":{\"62\":2}}],[\"questions\",{\"1\":{\"55\":1,\"62\":1,\"129\":2}}],[\"quickstart\",{\"1\":{\"55\":1}}],[\"qq\",{\"1\":{\"48\":1,\"55\":3,\"74\":2,\"95\":1,\"191\":1}}],[\"zeromq\",{\"1\":{\"198\":1}}],[\"zero\",{\"1\":{\"158\":1}}],[\"zewgkvrcyvagglmeseas7g\",{\"1\":{\"95\":1}}],[\"zuodaoyong\",{\"1\":{\"74\":1}}],[\"zxh1991811\",{\"1\":{\"74\":1}}],[\"zl\",{\"1\":{\"48\":1}}],[\"zhuanlan\",{\"1\":{\"191\":1}}],[\"zhihu\",{\"1\":{\"62\":2,\"191\":1}}],[\"zh\",{\"1\":{\"4\":1,\"25\":1}}],[\"四\",{\"0\":{\"48\":1,\"90\":1,\"138\":1,\"157\":1,\"178\":1,\"202\":1}}],[\"三\",{\"0\":{\"47\":1,\"89\":1,\"105\":1,\"135\":1,\"153\":1,\"174\":1,\"199\":1}}],[\"只会被送达一次\",{\"1\":{\"210\":1}}],[\"只能保证\",{\"1\":{\"203\":1}}],[\"只通过\",{\"1\":{\"173\":1}}],[\"只返回必要字段\",{\"1\":{\"164\":1}}],[\"只需\",{\"1\":{\"156\":1}}],[\"只要冲突\",{\"1\":{\"134\":1}}],[\"只起协同\",{\"1\":{\"80\":1}}],[\"只起阻塞作用\",{\"1\":{\"80\":1}}],[\"只是\",{\"1\":{\"46\":1,\"181\":1}}],[\"只有先确定id\",{\"1\":{\"177\":1}}],[\"只有叶子结点存储真实数据\",{\"1\":{\"177\":1}}],[\"只有上\",{\"1\":{\"92\":1}}],[\"只有左边界会越界\",{\"1\":{\"24\":1}}],[\"只有右边界会越界\",{\"1\":{\"24\":2}}],[\"更新消费位置为8\",{\"1\":{\"217\":1}}],[\"更适合称为\",{\"1\":{\"198\":1}}],[\"更加精确的实现commit提交的压缩\",{\"1\":{\"135\":1,\"142\":1}}],[\"更改回退至\",{\"1\":{\"126\":1}}],[\"更改\",{\"1\":{\"111\":1,\"114\":1,\"115\":1,\"125\":2}}],[\"更接近于\",{\"1\":{\"80\":1}}],[\"更短了\",{\"1\":{\"46\":1}}],[\"更具逻辑性\",{\"1\":{\"24\":1}}],[\"段长\",{\"1\":{\"46\":1}}],[\"剔除大量虚拟结点\",{\"1\":{\"46\":1}}],[\"都消费\",{\"1\":{\"204\":1}}],[\"都会\",{\"1\":{\"46\":1}}],[\"都映射到一个首尾相连的哈希环上\",{\"1\":{\"45\":1}}],[\"删除\",{\"1\":{\"46\":1,\"111\":1}}],[\"到内存\",{\"1\":{\"169\":2}}],[\"到上一个commit提交中\",{\"1\":{\"136\":1}}],[\"到feature分支\",{\"1\":{\"134\":1}}],[\"到master分支\",{\"1\":{\"134\":1}}],[\"到\",{\"1\":{\"46\":1,\"140\":1,\"154\":1}}],[\"→\",{\"1\":{\"46\":1,\"151\":1,\"164\":1,\"204\":2}}],[\"真正的零拷贝\",{\"0\":{\"156\":1}}],[\"真实节点\",{\"1\":{\"46\":1}}],[\"真值命题p\",{\"1\":{\"24\":1}}],[\"节点数量越多\",{\"1\":{\"46\":1}}],[\"让节点相对均匀的分布在哈希环\",{\"1\":{\"46\":1}}],[\"目标只有1条\",{\"1\":{\"163\":1}}],[\"目标元素的元素的最大\",{\"1\":{\"24\":2}}],[\"目标元素的元素的最小\",{\"1\":{\"24\":3}}],[\"目标元素不存在时\",{\"1\":{\"24\":10}}],[\"目标元素存在时\",{\"1\":{\"24\":10}}],[\"目标元素\",{\"1\":{\"24\":7}}],[\"目标元素时的分支也要写清楚\",{\"1\":{\"24\":1}}],[\"目的\",{\"1\":{\"46\":1}}],[\"映射到哈希环上\",{\"1\":{\"46\":2}}],[\"映射\",{\"1\":{\"46\":2,\"154\":1}}],[\"但允许少量重复消息出现\",{\"1\":{\"210\":1}}],[\"但由于\",{\"1\":{\"137\":1}}],[\"但要修改commit提交的描述信息\",{\"1\":{\"137\":1}}],[\"但无法修改提交内容\",{\"1\":{\"137\":1}}],[\"但又需要整理commit提交历史的场景\",{\"1\":{\"136\":1}}],[\"但master分支又已经有了新的变更\",{\"1\":{\"134\":1}}],[\"但尚未添加到git版本控制系统中的文件\",{\"1\":{\"124\":1}}],[\"但尚未添加到\",{\"1\":{\"124\":1}}],[\"但实际执行返回结果是不同的\",{\"1\":{\"123\":1}}],[\"但diff两点比较\",{\"1\":{\"123\":1}}],[\"但仍有细微差别\",{\"1\":{\"123\":1}}],[\"但临时遭遇突发情况\",{\"1\":{\"114\":1}}],[\"但是\",{\"1\":{\"89\":1}}],[\"但可以在临界区程序中使用\",{\"1\":{\"82\":1}}],[\"但可以使用isinterrupted\",{\"1\":{\"82\":1}}],[\"但两个虚拟结点间的\",{\"1\":{\"46\":1}}],[\"但存在节点分布不均匀的问题\",{\"1\":{\"45\":1}}],[\"但此处返回\",{\"1\":{\"24\":2}}],[\"仅支持等值查询\",{\"1\":{\"175\":1}}],[\"仅用于兼容旧系统\",{\"1\":{\"198\":1}}],[\"仅用于\",{\"1\":{\"115\":2}}],[\"仅影响该节点在哈希环上顺时针相邻的后继节点\",{\"1\":{\"45\":1}}],[\"仅此而已\",{\"1\":{\"18\":1}}],[\"移除\",{\"1\":{\"45\":1}}],[\"增加consumer实例\",{\"1\":{\"214\":1}}],[\"增加批量\",{\"1\":{\"214\":1}}],[\"增加系统复杂度\",{\"1\":{\"195\":1}}],[\"增加延迟\",{\"1\":{\"195\":1}}],[\"增加\",{\"1\":{\"45\":1,\"212\":1}}],[\"存储阶段\",{\"1\":{\"209\":1}}],[\"存储队列的服务器\",{\"1\":{\"204\":1}}],[\"存储\",{\"1\":{\"198\":1}}],[\"存储引擎会先在辅助索引中定位到具体的叶子结点\",{\"1\":{\"171\":1}}],[\"存储一条完整的行记录\",{\"1\":{\"171\":1}}],[\"存储节点\",{\"1\":{\"45\":2}}],[\"存在问题\",{\"1\":{\"45\":1}}],[\"存取进行哈希\",{\"1\":{\"45\":1}}],[\"进而减少了大量io操作\",{\"1\":{\"93\":1}}],[\"进行连接\",{\"1\":{\"171\":1}}],[\"进行\",{\"1\":{\"91\":1,\"92\":1}}],[\"进行哈希\",{\"1\":{\"45\":1}}],[\"进击的奶牛\",{\"0\":{\"13\":1}}],[\"哈希环\",{\"1\":{\"45\":1}}],[\"哈希算法\",{\"0\":{\"44\":1,\"225\":1}}],[\"数学技巧\",{\"0\":{\"229\":1}}],[\"数量保持一致\",{\"1\":{\"214\":1}}],[\"数字\",{\"1\":{\"190\":1}}],[\"数据库\",{\"0\":{\"236\":1}}],[\"数据文件本身就是索引文件\",{\"1\":{\"185\":1}}],[\"数据查询方式\",{\"1\":{\"173\":1}}],[\"数据操作\",{\"1\":{\"163\":1}}],[\"数据拷贝\",{\"1\":{\"154\":1}}],[\"数据\",{\"1\":{\"45\":2}}],[\"数组遍历完成\",{\"1\":{\"29\":1}}],[\"数组\",{\"1\":{\"29\":6}}],[\"是向前的\",{\"1\":{\"118\":1}}],[\"是向后的\",{\"1\":{\"118\":1}}],[\"是没有任何效果的\",{\"1\":{\"115\":1}}],[\"是索引列\",{\"1\":{\"87\":1}}],[\"是的\",{\"1\":{\"82\":1}}],[\"是否会吞掉异常\",{\"1\":{\"81\":1}}],[\"是否相等\",{\"1\":{\"73\":1}}],[\"是\",{\"1\":{\"46\":1}}],[\"是指将\",{\"1\":{\"45\":1}}],[\"是质数\",{\"1\":{\"3\":1}}],[\"痛点\",{\"1\":{\"44\":1}}],[\"加权轮询\",{\"0\":{\"43\":1}}],[\"如消息格式异常\",{\"1\":{\"215\":1}}],[\"如有必要\",{\"1\":{\"171\":1}}],[\"如新增\",{\"1\":{\"137\":1}}],[\"如名\",{\"1\":{\"124\":1}}],[\"如果相等则看下一个\",{\"1\":{\"190\":1}}],[\"如果业务逻辑需要支持大偏移量的limit分页\",{\"1\":{\"164\":1}}],[\"如果之前没有执行过\",{\"1\":{\"137\":1}}],[\"如果希望正在等待锁\",{\"1\":{\"82\":1}}],[\"如果已进⼊临界区的线程不能被中断\",{\"1\":{\"82\":1}}],[\"如果被中断\",{\"1\":{\"81\":1}}],[\"如果随机数j落在蓄水池的范围内\",{\"1\":{\"30\":1}}],[\"如何保证消息的严格顺序\",{\"0\":{\"218\":1}}],[\"如何在磁盘io成为性能瓶颈时\",{\"1\":{\"149\":1}}],[\"如何判断两个类\",{\"1\":{\"73\":1}}],[\"如何合理分配客户端对网站后台服务器集群的大量请求\",{\"1\":{\"41\":1}}],[\"思维导图\",{\"0\":{\"40\":1,\"162\":1}}],[\"思想实现算法\",{\"1\":{\"24\":1}}],[\"描述mysql的索引结构\",{\"1\":{\"167\":1}}],[\"描述mysql深分页问题\",{\"1\":{\"86\":1}}],[\"描述零拷贝的底层原理\",{\"1\":{\"148\":1}}],[\"描述快速幂算法原理\",{\"1\":{\"98\":1}}],[\"描述一致性哈希算法的基本原理\",{\"1\":{\"39\":1}}],[\"描述洗牌算法和随机抽样算法的底层原理和实现\",{\"1\":{\"28\":1}}],[\"h越小\",{\"1\":{\"177\":1}}],[\"h=logm+1n​\",{\"1\":{\"177\":1}}],[\"h\",{\"1\":{\"119\":1}}],[\"head~0等价于head\",{\"1\":{\"116\":1}}],[\"head~n\",{\"1\":{\"116\":1}}],[\"head^^^\",{\"1\":{\"116\":1}}],[\"head^^\",{\"1\":{\"116\":1}}],[\"head^\",{\"1\":{\"116\":1}}],[\"head类似一个\",{\"1\":{\"111\":1}}],[\"head\",{\"1\":{\"111\":1,\"115\":7,\"116\":1,\"118\":1,\"134\":1,\"137\":3}}],[\"h>\",{\"1\":{\"103\":1,\"104\":1}}],[\"high\",{\"1\":{\"95\":1}}],[\"how\",{\"1\":{\"55\":1}}],[\"houbb\",{\"1\":{\"55\":1}}],[\"http\",{\"1\":{\"191\":1,\"218\":1}}],[\"https\",{\"1\":{\"4\":2,\"25\":2,\"36\":1,\"48\":2,\"55\":9,\"62\":11,\"74\":2,\"83\":1,\"95\":3,\"105\":2,\"129\":3,\"145\":1,\"158\":1,\"191\":11,\"218\":2}}],[\"htmlhttps\",{\"1\":{\"74\":1}}],[\"html\",{\"1\":{\"48\":1,\"55\":3,\"62\":5,\"83\":1,\"95\":1,\"158\":1,\"191\":6}}],[\"hard\",{\"1\":{\"115\":5,\"117\":1}}],[\"hash索引\",{\"0\":{\"175\":1},\"1\":{\"175\":2}}],[\"hash\",{\"1\":{\"48\":1},\"2\":{\"50\":1}}],[\"haokelaicds\",{\"1\":{\"36\":1}}],[\"方法可以让正在阻塞等待获取锁\",{\"1\":{\"82\":1}}],[\"方法判断中断状态\",{\"1\":{\"82\":1}}],[\"方法判断中断标识\",{\"1\":{\"81\":1}}],[\"方法虽然不可响应中断\",{\"1\":{\"82\":1}}],[\"方法2\",{\"1\":{\"81\":1}}],[\"方法1\",{\"1\":{\"81\":1}}],[\"方法\",{\"1\":{\"81\":1,\"82\":1}}],[\"方法中断它时\",{\"1\":{\"81\":1}}],[\"方法声明中包含\",{\"1\":{\"81\":1}}],[\"方法会可以感知中断\",{\"1\":{\"80\":1}}],[\"方法只会将线程的中断标识置为true\",{\"1\":{\"80\":1}}],[\"方法后\",{\"1\":{\"79\":1}}],[\"方案1无效解决方案\",{\"1\":{\"35\":1}}],[\"方案1无效\",{\"1\":{\"35\":1}}],[\"方便记忆\",{\"1\":{\"24\":2}}],[\"添加至\",{\"1\":{\"137\":1}}],[\"添加至质数表\",{\"1\":{\"3\":1}}],[\"添加\",{\"1\":{\"35\":1}}],[\"名\",{\"1\":{\"34\":1,\"35\":2}}],[\"镜像\",{\"1\":{\"34\":1,\"35\":2}}],[\"容器名\",{\"1\":{\"34\":1,\"35\":2}}],[\"容器生成后发现既没有任何报错也没有消息提示\",{\"1\":{\"34\":1}}],[\"现象描述\",{\"0\":{\"34\":1}}],[\"解决\",{\"1\":{\"205\":1}}],[\"解决方案\",{\"0\":{\"35\":1,\"42\":1},\"1\":{\"86\":1,\"215\":1,\"217\":1}}],[\"解决办法\",{\"0\":{\"33\":1}}],[\"解题关键\",{\"0\":{\"17\":1}}],[\"抽样算法\",{\"0\":{\"223\":1}}],[\"抽样\",{\"2\":{\"32\":1}}],[\"80\",{\"1\":{\"218\":1}}],[\"80614\",{\"1\":{\"105\":1}}],[\"8kb等\",{\"1\":{\"169\":1}}],[\"81022057https\",{\"1\":{\"74\":1}}],[\"8394c560eec0\",{\"1\":{\"62\":2}}],[\"8\",{\"1\":{\"30\":1,\"48\":1,\"158\":1}}],[\"6844904073955639304\",{\"1\":{\"191\":1}}],[\"6844903921450745863\",{\"1\":{\"191\":1}}],[\"6869519303864123399\",{\"1\":{\"129\":1}}],[\"6985478936683610149\",{\"1\":{\"95\":1}}],[\"60220158\",{\"1\":{\"55\":1}}],[\"6\",{\"1\":{\"30\":1,\"217\":2}}],[\"50\",{\"1\":{\"104\":1}}],[\"500\",{\"1\":{\"104\":9}}],[\"50258991\",{\"1\":{\"62\":1}}],[\"54973413https\",{\"1\":{\"74\":1}}],[\"51335493\",{\"1\":{\"62\":1}}],[\"5\",{\"0\":{\"187\":1,\"188\":1,\"189\":1,\"190\":1},\"1\":{\"30\":2,\"191\":1,\"217\":1}}],[\"被选中的概率都是\",{\"1\":{\"30\":1}}],[\"每次\",{\"1\":{\"46\":1}}],[\"每次随机生成1个范围在\",{\"1\":{\"30\":1}}],[\"每个分区单独检测\",{\"1\":{\"208\":1}}],[\"每个消费组在每个队列上维护一个消费位置\",{\"1\":{\"204\":1}}],[\"每个\",{\"1\":{\"171\":1,\"203\":1,\"204\":1}}],[\"每个数据页中包含多条\",{\"1\":{\"169\":1}}],[\"每个节点存储的数据相同的情况\",{\"1\":{\"43\":1}}],[\"每个元素\",{\"1\":{\"30\":1}}],[\"链表随机结点算法实现\",{\"1\":{\"30\":1}}],[\"选中样本集中各个元素的概率均为\",{\"1\":{\"30\":1}}],[\"元素时\",{\"1\":{\"30\":1}}],[\"元素序列的所有元素时\",{\"1\":{\"24\":7}}],[\"它被选中的概率同样是k\",{\"1\":{\"30\":1}}],[\"它被选入蓄水池的概率是\",{\"1\":{\"30\":1}}],[\"则需至少将消息发送到2个以上节点\",{\"1\":{\"209\":1}}],[\"则每个producer生成各自消息序号\",{\"1\":{\"208\":1}}],[\"则每个列会分别建立一棵b+树\",{\"1\":{\"188\":1}}],[\"则exchange模块会将消息发送至多个队列\",{\"1\":{\"202\":1}}],[\"则会建立多棵b+树\",{\"1\":{\"188\":1}}],[\"则联合索引结构如下\",{\"1\":{\"187\":1}}],[\"则索引会在id匹配完后停止匹配\",{\"1\":{\"177\":1}}],[\"则b+树会按照从左至右顺序建树\",{\"1\":{\"177\":1}}],[\"则\",{\"1\":{\"177\":1}}],[\"则辅助索引会成为热🔥数据\",{\"1\":{\"175\":1}}],[\"则称本次查询使用了覆盖索引\",{\"1\":{\"173\":1}}],[\"则根据辅助索引叶子结点中的主键\",{\"1\":{\"173\":1}}],[\"则git会打开一个编辑器\",{\"1\":{\"137\":1}}],[\"则调用\",{\"1\":{\"79\":1}}],[\"则无法使用加权轮询\",{\"1\":{\"43\":1}}],[\"则在\",{\"1\":{\"35\":1}}],[\"则替换蓄水池中的第j个元素\",{\"1\":{\"30\":1}}],[\"则将\",{\"1\":{\"30\":1}}],[\"则选择范围是\",{\"1\":{\"29\":3}}],[\"≤\",{\"1\":{\"30\":1}}],[\"若同一份消息有多个消费者\",{\"1\":{\"202\":1}}],[\"若复合索引顺序\",{\"1\":{\"188\":1}}],[\"若查询条件只有\",{\"1\":{\"177\":1}}],[\"若b+树的索引结构为\",{\"1\":{\"177\":1}}],[\"若当前表的数据大小为n\",{\"1\":{\"177\":1}}],[\"若发现某辅助索引被频繁访问\",{\"1\":{\"175\":1}}],[\"若辅助索引中包含本次查询的所有字段\",{\"1\":{\"173\":1}}],[\"若无排序需求\",{\"1\":{\"164\":1}}],[\"若操作失误则\",{\"1\":{\"115\":1}}],[\"若该类中出现string\",{\"1\":{\"73\":1}}],[\"若节点数量发生变化\",{\"1\":{\"44\":1}}],[\"若数据分布式的存储在不同的节点的上\",{\"1\":{\"43\":1}}],[\"若\",{\"1\":{\"30\":2,\"45\":1,\"164\":1}}],[\"若i是\",{\"1\":{\"3\":1}}],[\"间的\",{\"1\":{\"30\":1}}],[\"第二梯队\",{\"0\":{\"198\":1}}],[\"第一梯队\",{\"0\":{\"197\":1}}],[\"第一次出现位置\",{\"1\":{\"24\":2}}],[\"第n\",{\"1\":{\"30\":1}}],[\"第i个元素\",{\"1\":{\"30\":1}}],[\"第\",{\"1\":{\"30\":1}}],[\"蓄水池\",{\"1\":{\"30\":1}}],[\"蓄水池抽样\",{\"0\":{\"30\":1}}],[\"蓄水池抽样算法\",{\"0\":{\"28\":1}}],[\"放到\",{\"1\":{\"30\":1}}],[\"≥\",{\"1\":{\"30\":1}}],[\"key\",{\"1\":{\"212\":1}}],[\"kafka+improvement+proposals\",{\"1\":{\"218\":1}}],[\"kafka会直接抛出异常\",{\"1\":{\"205\":1}}],[\"kafka消息模型\",{\"0\":{\"203\":1}}],[\"kafka\",{\"1\":{\"157\":1,\"197\":1,\"204\":1,\"218\":2}}],[\"k++\",{\"1\":{\"82\":2}}],[\"k\",{\"1\":{\"29\":2,\"30\":16,\"82\":4}}],[\"knuth洗牌算法可以从\",{\"1\":{\"29\":1}}],[\"knuth洗牌算法\",{\"0\":{\"29\":1},\"1\":{\"29\":2}}],[\"会占用\",{\"1\":{\"175\":1}}],[\"会进行\",{\"1\":{\"169\":1}}],[\"会导致全表扫描\",{\"1\":{\"164\":1}}],[\"会导致数据库出现\",{\"1\":{\"87\":1}}],[\"会\",{\"1\":{\"164\":1}}],[\"会特别浪费cpu\",{\"1\":{\"151\":1}}],[\"会暂停\",{\"1\":{\"137\":1}}],[\"会将当前commit的更改保存至暂存区\",{\"1\":{\"118\":1}}],[\"会将代码\",{\"1\":{\"115\":1}}],[\"会在当前代码基础上撤回指定commit的更改\",{\"1\":{\"118\":1}}],[\"会吞掉异常\",{\"1\":{\"81\":1}}],[\"会返回\",{\"1\":{\"79\":1}}],[\"会随机产生\",{\"1\":{\"29\":1}}],[\"会看到这篇文章的\",{\"1\":{\"11\":1}}],[\"从消费业务逻辑设计入手\",{\"1\":{\"212\":1}}],[\"从字符串的第一个字符开始比较ascii码值\",{\"1\":{\"190\":1}}],[\"从数据流中随机抽取k个样本\",{\"1\":{\"30\":1}}],[\"从未知容量大小\",{\"1\":{\"30\":1}}],[\"从\",{\"1\":{\"29\":1,\"30\":1}}],[\"从下标范围\",{\"1\":{\"29\":1}}],[\"打乱数组算法实现\",{\"1\":{\"29\":1}}],[\"上执行rebase\",{\"1\":{\"144\":1}}],[\"上\",{\"1\":{\"134\":1}}],[\"上上上一个版本\",{\"1\":{\"116\":1}}],[\"上上一个版本\",{\"1\":{\"116\":1}}],[\"上一个版本\",{\"1\":{\"116\":1}}],[\"上文中以\",{\"1\":{\"29\":1}}],[\"上界\",{\"1\":{\"2\":1,\"3\":1}}],[\"含重复元素\",{\"1\":{\"29\":1}}],[\"含义是right始终保持不动\",{\"1\":{\"24\":2}}],[\"含义是left逐渐逼近元素序列右边界\",{\"1\":{\"24\":2}}],[\"达成了算法目标\",{\"1\":{\"29\":1,\"30\":1}}],[\"种组合\",{\"1\":{\"29\":1}}],[\"种选择\",{\"1\":{\"29\":1}}],[\"种排列组合中\",{\"1\":{\"29\":1}}],[\"有序性\",{\"1\":{\"208\":1}}],[\"有几个列就有几个b+树\",{\"1\":{\"188\":1}}],[\"有冲突可能\",{\"1\":{\"175\":1}}],[\"有什么办法可以响应中断吗\",{\"1\":{\"82\":1}}],[\"有效性\",{\"1\":{\"29\":1}}],[\"有1种随机选法\",{\"1\":{\"29\":1}}],[\"有n\",{\"1\":{\"29\":1}}],[\"有空可补充\",{\"1\":{\"24\":1}}],[\"根据\",{\"1\":{\"169\":1}}],[\"根据参数项\",{\"1\":{\"115\":1}}],[\"根据knuth算法流程\",{\"1\":{\"29\":1}}],[\"根据排列组合\",{\"1\":{\"29\":1}}],[\"而辅助索引的key可以重复\",{\"1\":{\"181\":1}}],[\"而是使用java\",{\"1\":{\"164\":1}}],[\"而是先抛出题目\",{\"1\":{\"11\":1}}],[\"而无需拷贝至\",{\"1\":{\"155\":1}}],[\"而此时cpu不能执行其他任务\",{\"1\":{\"151\":1}}],[\"而非merge\",{\"1\":{\"134\":1}}],[\"而\",{\"1\":{\"118\":1,\"173\":1}}],[\"而不是仅在子查询已经定位到满足offset的第一条记录的id后\",{\"1\":{\"93\":1}}],[\"而算法目标就是从这\",{\"1\":{\"29\":1}}],[\"其中\",{\"1\":{\"136\":1}}],[\"其他\",{\"1\":{\"205\":1}}],[\"其他会抛出\",{\"1\":{\"80\":1}}],[\"其他情况同理\",{\"1\":{\"24\":1}}],[\"其余数据不受影响\",{\"1\":{\"45\":1}}],[\"其总排列数为n\",{\"1\":{\"29\":1}}],[\"洗牌\",{\"1\":{\"29\":1}}],[\"洗牌算法\",{\"0\":{\"28\":1}}],[\"对应\",{\"1\":{\"204\":1}}],[\"对消息积压支持不好\",{\"1\":{\"197\":1}}],[\"对比\",{\"1\":{\"126\":1}}],[\"对节点数量进行取模运算\",{\"1\":{\"44\":1}}],[\"对\",{\"1\":{\"29\":1,\"45\":2}}],[\"对于每个类\",{\"1\":{\"73\":1}}],[\"对于string\",{\"1\":{\"73\":1}}],[\"对于已在蓄水池中的元素\",{\"1\":{\"30\":1}}],[\"对于下标i\",{\"1\":{\"29\":1}}],[\"对于下标n\",{\"1\":{\"29\":1}}],[\"对于下标1\",{\"1\":{\"29\":1}}],[\"对于下标0\",{\"1\":{\"29\":1}}],[\"对于\",{\"1\":{\"29\":2,\"30\":1}}],[\"对于1个含n个无重复元素的\",{\"1\":{\"29\":2}}],[\"遍历\",{\"1\":{\"29\":1}}],[\"与队列模型最大区别\",{\"1\":{\"201\":1}}],[\"与merge\",{\"0\":{\"134\":1}}],[\"与中文语境中中断的含义略有不同\",{\"1\":{\"80\":1}}],[\"与\",{\"1\":{\"29\":1,\"30\":1,\"118\":1,\"123\":2,\"126\":2,\"151\":1,\"164\":1}}],[\"中一份完整的消息\",{\"1\":{\"204\":1}}],[\"中的5\",{\"1\":{\"217\":1}}],[\"中的数据拷贝至\",{\"1\":{\"155\":1,\"156\":1}}],[\"中的每个元素执行\",{\"1\":{\"29\":1}}],[\"中已修改\",{\"1\":{\"124\":1}}],[\"中断线程\",{\"1\":{\"82\":2}}],[\"中断\",{\"0\":{\"226\":1},\"1\":{\"80\":3},\"2\":{\"85\":1}}],[\"中断标识就⼀定被清除\",{\"1\":{\"82\":1}}],[\"中断标识会被清除\",{\"1\":{\"80\":1}}],[\"中断标识会被置为false\",{\"1\":{\"80\":1}}],[\"中断标识\",{\"1\":{\"79\":3}}],[\"中间件\",{\"2\":{\"37\":1,\"49\":1,\"130\":1,\"146\":1,\"159\":1,\"192\":1,\"219\":1}}],[\"中\",{\"1\":{\"29\":3,\"30\":1,\"124\":2,\"202\":1}}],[\"随机数\",{\"1\":{\"30\":1}}],[\"随机选出1种排列\",{\"1\":{\"29\":1}}],[\"随机选出1个元素与nums\",{\"1\":{\"29\":1}}],[\"随机选出1个排列\",{\"1\":{\"29\":1}}],[\"随机选出1个\",{\"1\":{\"29\":1}}],[\"随机排列\",{\"1\":{\"29\":1},\"2\":{\"32\":1}}],[\"随机打乱\",{\"1\":{\"29\":1}}],[\"列表同样适用\",{\"1\":{\"29\":1}}],[\"列表\",{\"1\":{\"29\":6,\"125\":1}}],[\"或\",{\"1\":{\"29\":6,\"45\":1,\"80\":1,\"115\":1,\"125\":1,\"140\":2,\"164\":2,\"188\":1,\"212\":1}}],[\"二级索引\",{\"1\":{\"171\":2}}],[\"二\",{\"0\":{\"25\":1,\"30\":1,\"42\":1,\"88\":1,\"102\":1,\"134\":1,\"150\":1,\"164\":1,\"170\":1,\"196\":1}}],[\"二分答案思想\",{\"1\":{\"24\":1}}],[\"二分答案思想实现二分查找\",{\"1\":{\"24\":1}}],[\"二分答案写法\",{\"1\":{\"24\":1}}],[\"二分答案算法全景图\",{\"0\":{\"23\":1}}],[\"二分答案\",{\"0\":{\"22\":1},\"1\":{\"24\":1}}],[\"二分答案问题模型\",{\"1\":{\"11\":1}}],[\"二分查找要点\",{\"1\":{\"24\":1}}],[\"二分查找主要有以下3种实现方式\",{\"1\":{\"24\":1}}],[\"二分查找标准模版\",{\"1\":{\"24\":1}}],[\"二分查找\",{\"0\":{\"22\":1,\"23\":1,\"24\":1},\"1\":{\"22\":1}}],[\"二分\",{\"2\":{\"21\":1}}],[\"二分法\",{\"0\":{\"222\":1},\"2\":{\"27\":1}}],[\"二分法在此处仅仅只是手段\",{\"1\":{\"18\":1}}],[\"二分法的作用\",{\"0\":{\"18\":1}}],[\"灵山府二分文章\",{\"1\":{\"24\":1}}],[\"寻找目标元素右边界\",{\"1\":{\"24\":1}}],[\"寻找目标元素左边界\",{\"1\":{\"24\":3}}],[\"94554897\",{\"1\":{\"36\":1}}],[\"9\",{\"1\":{\"24\":10,\"30\":1,\"48\":1,\"158\":1}}],[\"999\",{\"1\":{\"4\":1}}],[\"71\",{\"1\":{\"218\":1}}],[\"7129490960169304095\",{\"1\":{\"191\":1}}],[\"7三条消息\",{\"1\":{\"217\":1}}],[\"788\",{\"1\":{\"145\":1}}],[\"7251477\",{\"1\":{\"129\":1}}],[\"72217806https\",{\"1\":{\"74\":1}}],[\"7\",{\"1\":{\"24\":3,\"30\":1,\"89\":1,\"191\":1,\"217\":1}}],[\"404\",{\"1\":{\"221\":1}}],[\"49161353\",{\"1\":{\"191\":1}}],[\"447472435\",{\"1\":{\"191\":1}}],[\"44543508\",{\"1\":{\"74\":1}}],[\"4次上下文切换\",{\"1\":{\"154\":1}}],[\"4次数据拷贝\",{\"1\":{\"151\":1}}],[\"4次\",{\"1\":{\"151\":1}}],[\"462974\",{\"1\":{\"129\":1}}],[\"46761060\",{\"1\":{\"74\":1}}],[\"4242\",{\"1\":{\"36\":1}}],[\"4\",{\"0\":{\"46\":1,\"91\":1,\"92\":1,\"93\":1,\"94\":2,\"139\":1,\"140\":1,\"179\":1,\"180\":1,\"181\":1,\"182\":1,\"183\":1,\"184\":1,\"185\":1,\"190\":1},\"1\":{\"24\":4,\"30\":1,\"48\":1,\"62\":3,\"89\":2}}],[\"guid\",{\"1\":{\"212\":1}}],[\"go程序实现数据操作逻辑\",{\"1\":{\"164\":2}}],[\"go程序实现sql函数逻辑\",{\"1\":{\"164\":1}}],[\"go等程序语言来实现\",{\"1\":{\"163\":1}}],[\"group\",{\"1\":{\"164\":4,\"204\":3}}],[\"graph查看也感知不到有将master分支最新提交整合至feature分支的操作\",{\"1\":{\"134\":1}}],[\"graph\",{\"1\":{\"134\":2}}],[\"great\",{\"1\":{\"58\":1}}],[\"get\",{\"1\":{\"82\":10}}],[\"getname\",{\"1\":{\"82\":6}}],[\"getstate\",{\"1\":{\"80\":1,\"82\":2}}],[\"general\",{\"1\":{\"10\":1,\"51\":1,\"65\":1}}],[\"git基础知识\",{\"0\":{\"230\":1}}],[\"git基础知识及易混淆概念整理\",{\"1\":{\"108\":1}}],[\"git引用操作符\",{\"1\":{\"139\":1}}],[\"git会创建一个替换原commit提交的hash值不同的\",{\"1\":{\"137\":1}}],[\"git会打开一个编辑器\",{\"1\":{\"137\":1}}],[\"gitignore文件中指定的文件\",{\"1\":{\"124\":1}}],[\"git\",{\"0\":{\"121\":1,\"132\":1,\"231\":1},\"1\":{\"111\":4,\"113\":2,\"114\":3,\"115\":18,\"117\":2,\"118\":10,\"119\":8,\"121\":1,\"122\":6,\"123\":4,\"124\":4,\"125\":3,\"126\":6,\"127\":1,\"128\":2,\"129\":2,\"134\":1,\"136\":1,\"137\":8,\"139\":1,\"140\":3},\"2\":{\"131\":1,\"147\":1}}],[\"git核心基础知识\",{\"0\":{\"108\":1}}],[\"gitbook\",{\"1\":{\"74\":1}}],[\"github\",{\"1\":{\"25\":1,\"55\":3,\"62\":1}}],[\"g1\",{\"1\":{\"55\":1}}],[\"gc\",{\"1\":{\"55\":2}}],[\"gqil2dg\",{\"1\":{\"48\":1}}],[\"g\",{\"1\":{\"24\":1,\"87\":2,\"89\":1,\"139\":1,\"144\":1,\"164\":1,\"177\":1,\"187\":1,\"217\":1}}],[\"两阶段提交\",{\"1\":{\"205\":1}}],[\"两个系统调用\",{\"1\":{\"155\":1}}],[\"两点diff\",{\"1\":{\"122\":1}}],[\"两点log\",{\"1\":{\"119\":1}}],[\"两点\",{\"1\":{\"119\":1}}],[\"两层\",{\"1\":{\"46\":1}}],[\"两侧的处理逻辑\",{\"1\":{\"24\":1}}],[\"两种不同写法的理解\",{\"1\":{\"24\":2}}],[\"xxxez8r5knd6kj8nv\",{\"1\":{\"55\":2}}],[\"xiaolincoding\",{\"1\":{\"48\":1,\"158\":1}}],[\"xie\",{\"1\":{\"25\":1}}],[\"x1\",{\"1\":{\"29\":1}}],[\"x\",{\"1\":{\"24\":2,\"29\":7}}],[\"虽然逻辑结果相同\",{\"1\":{\"123\":1}}],[\"虽然二者逻辑结果相同\",{\"1\":{\"123\":1}}],[\"虽然迁移的虚拟结点数量增多了\",{\"1\":{\"46\":1}}],[\"虽然结束条件是left\",{\"1\":{\"24\":1}}],[\"虽然会出现\",{\"1\":{\"24\":1}}],[\"时间\",{\"1\":{\"143\":1}}],[\"时间复杂度为\",{\"1\":{\"2\":1,\"3\":1}}],[\"时\",{\"1\":{\"24\":1,\"89\":1,\"91\":1,\"164\":2}}],[\"故需\",{\"1\":{\"173\":1}}],[\"故需要返回\",{\"1\":{\"24\":1}}],[\"故在性能非常紧张时\",{\"1\":{\"164\":1}}],[\"故建议子查询只作为应急过渡方案\",{\"1\":{\"93\":1}}],[\"故迁移的数量是不变的\",{\"1\":{\"46\":1}}],[\"故当遍历至\",{\"1\":{\"30\":1}}],[\"故\",{\"1\":{\"29\":1,\"87\":1,\"93\":1}}],[\"故有n种随机选法\",{\"1\":{\"29\":1}}],[\"故此处left可替换为right\",{\"1\":{\"24\":2}}],[\"故也可返回\",{\"1\":{\"24\":4}}],[\"此时正指向\",{\"1\":{\"137\":1}}],[\"此时\",{\"1\":{\"137\":1,\"217\":1}}],[\"此时只能通过\",{\"1\":{\"137\":1}}],[\"此时搜索区间为\",{\"1\":{\"24\":2}}],[\"此方案数据查询量级较大时\",{\"1\":{\"93\":1}}],[\"此处sleep\",{\"1\":{\"80\":1}}],[\"此处只举例说明\",{\"1\":{\"24\":1}}],[\"此处需特别注意⚠️\",{\"1\":{\"24\":1}}],[\"此处写成\",{\"1\":{\"24\":4}}],[\"此处\",{\"1\":{\"24\":2,\"115\":1}}],[\"此处是为了清晰程序的可达性\",{\"1\":{\"24\":2}}],[\"此处可加\",{\"1\":{\"2\":1}}],[\"由被中断线程自己决定\",{\"1\":{\"80\":1}}],[\"由2^32个点组成\",{\"1\":{\"45\":1}}],[\"由于代码评审时\",{\"1\":{\"134\":1}}],[\"由于子查询中select选出字段只有\",{\"1\":{\"93\":1}}],[\"由于数据存在于多个\",{\"1\":{\"89\":1}}],[\"由于结束条件是left\",{\"1\":{\"24\":2}}],[\"由于\",{\"1\":{\"24\":5}}],[\"由浅入深的加深对问题的理解\",{\"1\":{\"11\":1}}],[\"最老牌消息队列\",{\"1\":{\"198\":1}}],[\"最左匹配原则\",{\"1\":{\"172\":1}}],[\"最好不使用\",{\"1\":{\"164\":1}}],[\"最好将\",{\"1\":{\"163\":1}}],[\"最好写成\",{\"1\":{\"24\":2}}],[\"最近一次提交\",{\"1\":{\"137\":1}}],[\"最新commit\",{\"1\":{\"111\":1}}],[\"最后\",{\"1\":{\"171\":1}}],[\"最后返回\",{\"1\":{\"89\":1}}],[\"最后一次出现位置\",{\"1\":{\"24\":3}}],[\"最大\",{\"1\":{\"24\":1}}],[\"最小化回表次数+io操作次数\",{\"1\":{\"94\":1}}],[\"最小\",{\"1\":{\"24\":1}}],[\"和三点diff\",{\"1\":{\"119\":1,\"122\":1}}],[\"和\",{\"1\":{\"24\":2,\"45\":1,\"80\":1,\"119\":1,\"122\":1,\"134\":1,\"154\":1,\"155\":1,\"163\":1,\"171\":2,\"203\":1}}],[\"为更新的数据设置前置条件\",{\"1\":{\"212\":1}}],[\"为新的基\",{\"1\":{\"134\":1}}],[\"为了保证分页查询数据的正确性\",{\"1\":{\"89\":1}}],[\"为什么我看不到appclassloader的源码\",{\"1\":{\"73\":1}}],[\"为\",{\"1\":{\"24\":1,\"100\":1,\"177\":1,\"187\":2}}],[\"为提高程序健壮性\",{\"1\":{\"24\":2}}],[\"为清晰逻辑\",{\"1\":{\"24\":1}}],[\"大数据\",{\"1\":{\"197\":1}}],[\"大量消息积压时性能急剧下降\",{\"1\":{\"197\":1}}],[\"大写字母的ascii码\",{\"1\":{\"190\":1}}],[\"大小为16kb\",{\"1\":{\"169\":1}}],[\"大小通常为4kb\",{\"1\":{\"169\":1}}],[\"大于\",{\"1\":{\"24\":7}}],[\"大概率是对二分答案问题模型有了基本了解\",{\"1\":{\"11\":1}}],[\"<>\",{\"1\":{\"164\":1}}],[\"<file\",{\"1\":{\"126\":1}}],[\"<commit>\",{\"1\":{\"119\":4,\"122\":6}}],[\"<branch>\",{\"1\":{\"119\":4,\"122\":6}}],[\"<<\",{\"1\":{\"103\":2,\"104\":4}}],[\"<\",{\"1\":{\"24\":16,\"29\":1,\"30\":3,\"82\":10,\"101\":2,\"104\":8}}],[\"<=>\",{\"1\":{\"87\":2}}],[\"<=l\",{\"1\":{\"3\":1}}],[\"<=\",{\"1\":{\"2\":3,\"3\":2,\"24\":2,\"91\":1}}],[\"en\",{\"1\":{\"191\":1}}],[\"endl\",{\"1\":{\"103\":1,\"104\":2}}],[\"endlesscheng\",{\"1\":{\"25\":1}}],[\"edu\",{\"1\":{\"191\":2}}],[\"edition\",{\"1\":{\"187\":1}}],[\"edit命令不同使用场景处理方法\",{\"1\":{\"137\":1}}],[\"edit命令与reword命令区别\",{\"0\":{\"137\":1}}],[\"edit\",{\"1\":{\"136\":1,\"137\":4}}],[\"exactly\",{\"1\":{\"210\":1,\"211\":1}}],[\"exchange模块决定将消息投递到哪个队列中\",{\"1\":{\"202\":1}}],[\"exchange模块\",{\"1\":{\"197\":1,\"202\":2}}],[\"exception\",{\"1\":{\"80\":1}}],[\"exp可能为负\",{\"1\":{\"101\":1}}],[\"exp\",{\"1\":{\"101\":6}}],[\"executing\",{\"1\":{\"82\":2}}],[\"elements\",{\"1\":{\"30\":1}}],[\"else\",{\"1\":{\"24\":9,\"104\":2}}],[\"e\",{\"1\":{\"24\":1,\"80\":4,\"81\":6,\"82\":2,\"87\":2,\"89\":1,\"139\":1,\"144\":1,\"164\":1,\"177\":1,\"187\":1,\"217\":1}}],[\"eulersifter\",{\"1\":{\"3\":3}}],[\"搜索有可能在非叶子节点结束\",{\"1\":{\"176\":1}}],[\"搜索\",{\"1\":{\"24\":1}}],[\"搜索区间\",{\"1\":{\"24\":11}}],[\"搜索区间决定结束条件\",{\"1\":{\"24\":1}}],[\"搜素\",{\"1\":{\"24\":7}}],[\"most\",{\"1\":{\"210\":1}}],[\"modified\",{\"1\":{\"124\":1}}],[\"mq缺点\",{\"1\":{\"195\":1}}],[\"mq基础知识\",{\"1\":{\"194\":1}}],[\"mq\",{\"0\":{\"194\":1},\"2\":{\"220\":1}}],[\"myisam的辅助索引和主索引没有多大区别\",{\"1\":{\"185\":1}}],[\"myisam引擎使用b+tree作为索引结构\",{\"1\":{\"180\":1}}],[\"myisam引擎下\",{\"1\":{\"179\":1}}],[\"myisam引擎\",{\"0\":{\"179\":1},\"1\":{\"185\":2}}],[\"mysql引擎\",{\"1\":{\"185\":1}}],[\"mysql中的页通常指的是innodb存储引擎中的数据页\",{\"1\":{\"169\":1}}],[\"mysql索引思维导图\",{\"0\":{\"168\":1}}],[\"mysql索引\",{\"0\":{\"167\":1}}],[\"mysql\",{\"0\":{\"71\":1},\"1\":{\"169\":1,\"191\":2}}],[\"m越大\",{\"1\":{\"177\":1}}],[\"mmap替换read\",{\"1\":{\"154\":1}}],[\"mmap系统调用会直接把内核缓冲区中的数据\",{\"1\":{\"154\":1}}],[\"mmap\",{\"1\":{\"153\":1}}],[\"mixed\",{\"1\":{\"115\":4}}],[\"mid=2247488905\",{\"1\":{\"74\":1}}],[\"mid\",{\"1\":{\"24\":55}}],[\"msg后\",{\"1\":{\"118\":1}}],[\"msg\",{\"1\":{\"111\":1,\"137\":4}}],[\"multiple\",{\"1\":{\"104\":2}}],[\"m++\",{\"1\":{\"82\":1}}],[\"m\",{\"1\":{\"82\":2,\"103\":4,\"111\":1,\"140\":2}}],[\"master分支\",{\"1\":{\"144\":1}}],[\"master\",{\"1\":{\"134\":2,\"136\":1}}],[\"map>\",{\"1\":{\"103\":1,\"104\":1}}],[\"max\",{\"1\":{\"82\":4,\"164\":1}}],[\"main\",{\"1\":{\"2\":1,\"3\":1,\"24\":4,\"30\":1,\"80\":1,\"81\":1,\"82\":2,\"103\":1,\"104\":1,\"127\":2}}],[\"m0\",{\"1\":{\"74\":1,\"191\":1}}],[\"meituan\",{\"1\":{\"191\":1}}],[\"merge\",{\"1\":{\"134\":4,\"144\":1,\"191\":1}}],[\"merges\",{\"1\":{\"119\":1}}],[\"memset\",{\"1\":{\"104\":4}}],[\"memory\",{\"1\":{\"62\":1}}],[\"medium=distribute\",{\"1\":{\"36\":1}}],[\"md\",{\"1\":{\"55\":1}}],[\"mp\",{\"1\":{\"48\":1,\"55\":3,\"74\":1,\"95\":1,\"191\":1}}],[\"左右均会越界\",{\"1\":{\"24\":2}}],[\"左\",{\"1\":{\"24\":11}}],[\"左闭\",{\"1\":{\"24\":13}}],[\"tcc\",{\"1\":{\"205\":1}}],[\"two\",{\"1\":{\"205\":1}}],[\"t2\",{\"1\":{\"94\":4}}],[\"t1\",{\"1\":{\"94\":6}}],[\"triple\",{\"1\":{\"129\":2}}],[\"try\",{\"1\":{\"80\":2,\"81\":2,\"82\":2,\"205\":1}}],[\"true\",{\"1\":{\"2\":2,\"3\":3,\"79\":3,\"81\":1,\"82\":2}}],[\"t\",{\"1\":{\"80\":2,\"81\":2,\"87\":1,\"89\":8,\"91\":1,\"92\":1,\"93\":3,\"94\":4}}],[\"three\",{\"1\":{\"191\":1}}],[\"thread\",{\"1\":{\"80\":9,\"81\":7,\"82\":19}}],[\"thread类中有3个与线程中断有关的方法\",{\"1\":{\"79\":1}}],[\"throws\",{\"1\":{\"81\":1,\"82\":2}}],[\"throw\",{\"1\":{\"80\":2,\"81\":2,\"82\":1}}],[\"theory\",{\"1\":{\"191\":1}}],[\"the\",{\"1\":{\"55\":1,\"62\":2,\"129\":2}}],[\"this\",{\"1\":{\"29\":1,\"58\":1}}],[\"token机制\",{\"1\":{\"212\":1}}],[\"token=hofqawajezk8t18tsgopwj37a40ibqcqzjb6fomb\",{\"1\":{\"191\":1}}],[\"topic\",{\"1\":{\"203\":1,\"204\":3}}],[\"top\",{\"1\":{\"83\":1}}],[\"to\",{\"1\":{\"55\":1,\"111\":1}}],[\"text\",{\"1\":{\"154\":1,\"164\":1}}],[\"testsun\",{\"1\":{\"119\":2,\"122\":2}}],[\"testmater\",{\"1\":{\"119\":2,\"122\":2}}],[\"teaho\",{\"1\":{\"74\":1}}],[\"tech\",{\"1\":{\"55\":1,\"191\":1}}],[\"temp\",{\"1\":{\"29\":2}}],[\"take\",{\"1\":{\"80\":1}}],[\"tangbean\",{\"1\":{\"55\":1}}],[\"task\",{\"1\":{\"36\":1}}],[\"targets\",{\"1\":{\"24\":6}}],[\"target\",{\"1\":{\"24\":44}}],[\"db\",{\"2\":{\"165\":1,\"193\":1}}],[\"dml尽量短小\",{\"1\":{\"164\":1}}],[\"dma技术\",{\"1\":{\"156\":1}}],[\"dma\",{\"1\":{\"153\":1,\"156\":1}}],[\"df\",{\"1\":{\"125\":1}}],[\"d\",{\"1\":{\"125\":1}}],[\"drop\",{\"1\":{\"114\":1,\"126\":1,\"136\":1}}],[\"driver\",{\"0\":{\"71\":1}}],[\"dayarch\",{\"1\":{\"83\":1}}],[\"datetime\",{\"1\":{\"164\":1}}],[\"date\",{\"1\":{\"24\":1}}],[\"dot\",{\"1\":{\"129\":4}}],[\"double\",{\"1\":{\"101\":5,\"129\":2}}],[\"documentation\",{\"1\":{\"218\":1}}],[\"doc\",{\"1\":{\"62\":1,\"191\":1}}],[\"docs\",{\"1\":{\"62\":2}}],[\"docker\",{\"0\":{\"224\":1},\"1\":{\"34\":1,\"35\":2},\"2\":{\"38\":1}}],[\"docker启动后自动退出\",{\"0\":{\"33\":1}}],[\"do\",{\"1\":{\"55\":1}}],[\"doocs\",{\"1\":{\"55\":1,\"62\":1}}],[\"detail\",{\"1\":{\"202\":1}}],[\"details\",{\"1\":{\"36\":1,\"74\":7,\"191\":1}}],[\"dead\",{\"1\":{\"191\":1}}],[\"dev\",{\"1\":{\"191\":1}}],[\"developer\",{\"1\":{\"74\":1}}],[\"delete\",{\"1\":{\"164\":1}}],[\"decorate\",{\"1\":{\"134\":1}}],[\"deep\",{\"1\":{\"95\":1}}],[\"default\",{\"1\":{\"36\":1}}],[\"design\",{\"0\":{\"9\":1}}],[\"display\",{\"1\":{\"218\":1}}],[\"distinct\",{\"1\":{\"164\":3}}],[\"dif\",{\"1\":{\"129\":1}}],[\"differences\",{\"1\":{\"129\":2}}],[\"diff\",{\"1\":{\"122\":6,\"123\":2,\"125\":1,\"126\":2,\"127\":1}}],[\"direct\",{\"1\":{\"55\":1}}],[\"di\",{\"1\":{\"25\":1}}],[\"可能产生数据不一致问题\",{\"1\":{\"195\":1}}],[\"可进一步减少通过cpu将\",{\"1\":{\"156\":1}}],[\"可减少\",{\"1\":{\"155\":1}}],[\"可减少1次数据拷贝过程\",{\"1\":{\"154\":1}}],[\"可优化点\",{\"0\":{\"152\":1}}],[\"可在编辑器内修改commit提交的描述信息\",{\"1\":{\"137\":2}}],[\"可在分支\",{\"1\":{\"122\":1}}],[\"可使用以下2条命令的任意一条\",{\"1\":{\"128\":1}}],[\"可查看到标颜色文件\",{\"1\":{\"124\":1}}],[\"可一定程度上降低oom概率\",{\"1\":{\"93\":1}}],[\"可通过\",{\"1\":{\"92\":1,\"115\":1}}],[\"可通过修改\",{\"1\":{\"24\":1}}],[\"可根据实际情况将上述操作结合使用\",{\"1\":{\"136\":1}}],[\"可根据\",{\"1\":{\"91\":1}}],[\"可响应中断\",{\"1\":{\"82\":1}}],[\"可以使用交互式rebase\",{\"1\":{\"142\":1}}],[\"可以使用\",{\"1\":{\"137\":2}}],[\"可以使用可重入锁\",{\"1\":{\"82\":1}}],[\"可以修改提交的描述信息\",{\"1\":{\"137\":2}}],[\"可以看到\",{\"1\":{\"80\":1,\"82\":1,\"134\":1}}],[\"可参考labuladong的一致性hash算法实现\",{\"1\":{\"47\":1}}],[\"可正确终止\",{\"1\":{\"24\":2}}],[\"可替换为\",{\"1\":{\"24\":2}}],[\"可写出不同情况下的二分查找算法\",{\"1\":{\"24\":1}}],[\"可基于对不同情况二分查找逻辑的理解确定\",{\"1\":{\"24\":1}}],[\"在线业务\",{\"1\":{\"197\":1}}],[\"在有限范围内进行比较\",{\"1\":{\"189\":1}}],[\"在myisam中\",{\"1\":{\"181\":1}}],[\"在关键字全集内做一次查找\",{\"1\":{\"176\":1}}],[\"在主键索引获取到一条完整的行记录\",{\"1\":{\"171\":1}}],[\"在整个过程中是没有不必要存在的\",{\"1\":{\"152\":1}}],[\"在整合个人开发的feature分支时\",{\"1\":{\"134\":1}}],[\"在公共分支上执行\",{\"1\":{\"144\":1}}],[\"在公共分支上执行rebase可能会导致提交日志记录发生混乱\",{\"1\":{\"143\":1}}],[\"在个人开发的feature分支上执行\",{\"1\":{\"144\":1}}],[\"在日常开发中\",{\"1\":{\"135\":1}}],[\"在feature分支上执行\",{\"1\":{\"134\":1,\"136\":1}}],[\"在开发过程中\",{\"1\":{\"134\":1}}],[\"在git工作区中存在\",{\"1\":{\"124\":1}}],[\"在当前代码基础上撤回指定commit更改后的代码\",{\"1\":{\"118\":1}}],[\"在文件更改已\",{\"1\":{\"115\":1}}],[\"在不执行提交commit的情况下\",{\"1\":{\"114\":1}}],[\"在不遵循双亲委派模型的情况下\",{\"1\":{\"73\":1}}],[\"在java语言中\",{\"1\":{\"80\":1}}],[\"在增删物理机时\",{\"1\":{\"46\":1}}],[\"在哈希环上的分布就越均匀\",{\"1\":{\"46\":1}}],[\"在一致性哈希算法中\",{\"1\":{\"45\":1}}],[\"在客户端请求量较大时\",{\"1\":{\"41\":1}}],[\"在\",{\"1\":{\"24\":8,\"94\":1,\"111\":1,\"124\":2}}],[\"在融汇以上3点的情况下\",{\"1\":{\"24\":1}}],[\"在解题的过程中由近及远\",{\"1\":{\"11\":1}}],[\"不允许丢失\",{\"1\":{\"210\":1}}],[\"不允许丢失消息\",{\"1\":{\"210\":1}}],[\"不同消费组之间消费进度不受影响\",{\"1\":{\"204\":1}}],[\"不同存储引擎下的索引结构\",{\"0\":{\"178\":1}}],[\"不太适合在线业务\",{\"1\":{\"197\":1}}],[\"不能人为干预是否在一张表中生成\",{\"1\":{\"175\":1}}],[\"不是具体的哪一类索引\",{\"1\":{\"173\":1}}],[\"不是质数\",{\"1\":{\"2\":1,\"3\":1}}],[\"不要使用\",{\"1\":{\"164\":1}}],[\"不要使用大偏移量的limit分页\",{\"1\":{\"164\":1}}],[\"不会增加不属于feature分支本身的提交\",{\"1\":{\"142\":1}}],[\"不希望真正执行变基\",{\"1\":{\"136\":1}}],[\"不再提示确认\",{\"1\":{\"125\":1}}],[\"不再将\",{\"1\":{\"46\":1}}],[\"不带水印\",{\"1\":{\"121\":1}}],[\"不一样\",{\"1\":{\"119\":1}}],[\"不如一次性在子查询中将满足偏移量的所有id全查出来\",{\"1\":{\"93\":1}}],[\"不支持范围查找\",{\"1\":{\"175\":1}}],[\"不支持\",{\"1\":{\"92\":1}}],[\"不可响应中断\",{\"1\":{\"82\":1}}],[\"不应被吞掉\",{\"1\":{\"81\":1}}],[\"不执行操作\",{\"1\":{\"30\":1}}],[\"不宜死记\",{\"1\":{\"24\":1}}],[\"rocketmq增加\",{\"1\":{\"205\":1}}],[\"rocketmq\",{\"0\":{\"203\":1},\"1\":{\"197\":1,\"204\":1}}],[\"rotated\",{\"1\":{\"25\":1}}],[\"r\",{\"1\":{\"103\":4}}],[\"running\",{\"1\":{\"81\":1}}],[\"runtimeexception\",{\"1\":{\"80\":2,\"81\":2,\"82\":1}}],[\"run\",{\"1\":{\"34\":1,\"35\":2}}],[\"rabbitmq消息模型\",{\"0\":{\"202\":1}}],[\"rabbitmq\",{\"1\":{\"197\":1}}],[\"rand\",{\"1\":{\"29\":2}}],[\"random\",{\"1\":{\"29\":2,\"30\":5}}],[\"raysunwhut\",{\"1\":{\"24\":1}}],[\"read\",{\"1\":{\"155\":2}}],[\"reword\",{\"0\":{\"139\":1},\"1\":{\"136\":1,\"137\":3}}],[\"request存在代码冲突\",{\"1\":{\"134\":1}}],[\"request\",{\"1\":{\"134\":1}}],[\"rebase使用解析\",{\"0\":{\"232\":1}}],[\"rebase会更改git提交历史\",{\"1\":{\"143\":1}}],[\"rebase可以使分支的提交历史变得整洁\",{\"1\":{\"142\":1}}],[\"rebase优缺点\",{\"0\":{\"141\":1}}],[\"rebase操作命令\",{\"0\":{\"136\":1}}],[\"rebase操作的整个过程\",{\"1\":{\"135\":1}}],[\"rebase操作的正确使用姿态是\",{\"1\":{\"135\":1}}],[\"rebase操作没有新增commit提交\",{\"1\":{\"134\":1}}],[\"rebase与merge对比\",{\"1\":{\"134\":1}}],[\"rebase\",{\"0\":{\"134\":1,\"137\":1},\"1\":{\"134\":5,\"136\":1,\"137\":3,\"139\":1,\"140\":1,\"144\":1}}],[\"rebase命令的作用\",{\"1\":{\"132\":1}}],[\"rebase命令详解\",{\"0\":{\"132\":1}}],[\"revert操作\",{\"1\":{\"118\":2}}],[\"revert\",{\"1\":{\"118\":9}}],[\"refman\",{\"1\":{\"191\":1}}],[\"reflog\",{\"1\":{\"115\":1,\"117\":1}}],[\"references\",{\"1\":{\"55\":2}}],[\"remote\",{\"1\":{\"111\":2,\"128\":1}}],[\"repository\",{\"0\":{\"127\":1},\"1\":{\"111\":3,\"115\":1}}],[\"reentrantlock\",{\"1\":{\"82\":5}}],[\"redirecthttps\",{\"1\":{\"74\":1}}],[\"relevant\",{\"1\":{\"36\":3}}],[\"restore\",{\"1\":{\"126\":1}}],[\"res\",{\"1\":{\"101\":4,\"104\":8}}],[\"resolve\",{\"1\":{\"55\":1}}],[\"result\",{\"1\":{\"30\":2}}],[\"reservoirsample\",{\"1\":{\"30\":2}}],[\"reservoirsampling\",{\"1\":{\"30\":1}}],[\"reservoir\",{\"0\":{\"30\":1},\"1\":{\"30\":4}}],[\"reset操作\",{\"1\":{\"118\":1}}],[\"reset\",{\"1\":{\"29\":1,\"115\":11,\"117\":1,\"118\":3,\"126\":1}}],[\"return\",{\"1\":{\"2\":1,\"3\":1,\"24\":22,\"29\":2,\"30\":1,\"101\":1,\"103\":1,\"104\":1}}],[\"right\",{\"1\":{\"24\":64}}],[\"明确搜索区间\",{\"1\":{\"24\":1}}],[\"3个消费者实例读1个队列\",{\"1\":{\"217\":1}}],[\"3rd\",{\"1\":{\"187\":1}}],[\"3次数据拷贝\",{\"1\":{\"154\":1,\"155\":1}}],[\"3000l\",{\"1\":{\"80\":1}}],[\"3001\",{\"1\":{\"36\":1}}],[\"30300585\",{\"1\":{\"62\":1}}],[\"3c789\",{\"1\":{\"25\":1}}],[\"37\",{\"1\":{\"24\":1}}],[\"3\",{\"0\":{\"45\":1,\"93\":1,\"101\":1,\"136\":1,\"137\":1,\"154\":1,\"155\":1,\"156\":2,\"173\":1,\"175\":1,\"176\":1,\"177\":2,\"185\":1,\"189\":1,\"200\":1,\"201\":1},\"1\":{\"24\":2,\"30\":1,\"89\":1}}],[\"右\",{\"1\":{\"24\":9}}],[\"右闭\",{\"1\":{\"24\":5}}],[\"右开\",{\"1\":{\"24\":8}}],[\"算法时间复杂度\",{\"1\":{\"30\":1}}],[\"算法正确性证明\",{\"1\":{\"30\":1}}],[\"算法\",{\"0\":{\"30\":1},\"1\":{\"29\":1}}],[\"算法流程\",{\"1\":{\"29\":1,\"30\":1}}],[\"算法目标\",{\"1\":{\"29\":1,\"30\":1}}],[\"算法模版\",{\"0\":{\"24\":1}}],[\"算法详情可参考\",{\"1\":{\"3\":1}}],[\"算法详情可参见wiki百科\",{\"1\":{\"2\":1}}],[\"一般不建议使用\",{\"1\":{\"212\":1}}],[\"一个主题包含多个队列\",{\"1\":{\"204\":1}}],[\"一个消费组中包含多个\",{\"1\":{\"204\":1}}],[\"一个节点\",{\"1\":{\"45\":1}}],[\"一份数据可被多个订阅者消费的的功能\",{\"1\":{\"202\":1}}],[\"一份消息数据能不能被消费多次的问题\",{\"1\":{\"201\":1}}],[\"一致性哈希算法实现\",{\"0\":{\"47\":1}}],[\"一致性哈希算法虽然减少了数据迁移量\",{\"1\":{\"45\":1}}],[\"一致性哈希算法流程\",{\"1\":{\"45\":1}}],[\"一致性哈希算法对2^32进行取模运算\",{\"1\":{\"45\":1}}],[\"一致性哈希算法\",{\"0\":{\"40\":1,\"45\":1}}],[\"一致性哈希\",{\"0\":{\"39\":1},\"1\":{\"45\":1}}],[\"一\",{\"0\":{\"24\":1,\"29\":1,\"41\":1,\"87\":1,\"99\":1,\"133\":1,\"149\":1,\"163\":1,\"169\":1,\"195\":1}}],[\"零拷贝应用\",{\"0\":{\"157\":1}}],[\"零拷贝技术不允许进程对文件内容做进一步加工\",{\"1\":{\"156\":1}}],[\"零拷贝\",{\"0\":{\"148\":1,\"153\":1,\"233\":1},\"1\":{\"153\":1}}],[\"零\",{\"0\":{\"23\":1,\"40\":1,\"162\":1,\"168\":1}}],[\"本地\",{\"1\":{\"113\":1}}],[\"本地仓库\",{\"0\":{\"127\":1},\"1\":{\"111\":3,\"115\":1}}],[\"本地idea启动springboot与服务器jar包形式运行springboot项目的区别是什么\",{\"1\":{\"73\":1}}],[\"本质\",{\"0\":{\"17\":1}}],[\"本文开篇暂不阐述\",{\"1\":{\"11\":1}}],[\"问题\",{\"1\":{\"215\":1,\"217\":1}}],[\"问题排查\",{\"0\":{\"215\":1}}],[\"问题描述\",{\"0\":{\"87\":1}}],[\"问题背景\",{\"0\":{\"41\":1,\"149\":1}}],[\"问题模型\",{\"2\":{\"21\":1}}],[\"问题模型阐述\",{\"0\":{\"16\":1}}],[\"问题核心\",{\"0\":{\"17\":1}}],[\"问题分析\",{\"0\":{\"11\":1}}],[\"路标设置\",{\"0\":{\"15\":1}}],[\"木材加工\",{\"0\":{\"12\":1}}],[\"核心优化原则\",{\"1\":{\"163\":1}}],[\"核心\",{\"1\":{\"11\":1}}],[\"并与\",{\"1\":{\"214\":1}}],[\"并行度就是队列数量\",{\"1\":{\"204\":1}}],[\"并建立哈希索引\",{\"1\":{\"175\":1}}],[\"并以master分支的最新提交\",{\"1\":{\"134\":1}}],[\"并在feature分支生成一个合并后的新commit提交节点\",{\"1\":{\"134\":1}}],[\"并在用户填写完commit\",{\"1\":{\"118\":1}}],[\"并会在线程中断标识发生变化\",{\"1\":{\"80\":1}}],[\"并抛出interruptedexception异常\",{\"1\":{\"80\":1}}],[\"并不是真正的将某个运行中的线程终止\",{\"1\":{\"80\":1}}],[\"并\",{\"1\":{\"79\":1}}],[\"并将当前分支的\",{\"1\":{\"137\":1}}],[\"并将指定commitid版本的提交回退至\",{\"1\":{\"118\":1}}],[\"并将指定commitid的更改\",{\"1\":{\"118\":1}}],[\"并将\",{\"1\":{\"46\":1}}],[\"并且即使通过git\",{\"1\":{\"134\":1}}],[\"并且\",{\"1\":{\"81\":1}}],[\"并且最终掌握二分答案问题模型的本质\",{\"1\":{\"11\":1}}],[\"并且想要进一步洞悉问题全貌的同学\",{\"1\":{\"11\":1}}],[\"并标记为false\",{\"1\":{\"3\":1}}],[\"首先\",{\"1\":{\"11\":1,\"29\":1}}],[\"典例精析\",{\"0\":{\"11\":1}}],[\"visualization\",{\"1\":{\"191\":2}}],[\"video\",{\"1\":{\"4\":1,\"105\":1,\"145\":1}}],[\"varchar\",{\"1\":{\"164\":1}}],[\"value\",{\"1\":{\"30\":2,\"82\":4}}],[\"vd\",{\"1\":{\"4\":1,\"105\":1}}],[\"void\",{\"1\":{\"2\":1,\"3\":1,\"24\":1,\"29\":1,\"30\":1,\"80\":1,\"81\":1,\"82\":2,\"104\":2}}],[\"cwiki\",{\"1\":{\"218\":1}}],[\"cs\",{\"1\":{\"191\":2}}],[\"csdn\",{\"1\":{\"36\":1,\"74\":7,\"191\":1}}],[\"create\",{\"1\":{\"173\":1}}],[\"cpu\",{\"1\":{\"163\":1}}],[\"c3\",{\"1\":{\"136\":1}}],[\"c2\",{\"1\":{\"136\":1}}],[\"c7\",{\"1\":{\"134\":2}}],[\"c6\",{\"1\":{\"134\":2}}],[\"c4\",{\"1\":{\"134\":2,\"136\":1}}],[\"c1\",{\"1\":{\"134\":2}}],[\"cd\",{\"1\":{\"119\":1}}],[\"cin\",{\"1\":{\"103\":1,\"104\":1}}],[\"c++实现\",{\"0\":{\"101\":1}}],[\"cancel\",{\"1\":{\"205\":1}}],[\"cana\",{\"1\":{\"62\":1}}],[\"cached\",{\"1\":{\"126\":2}}],[\"catch\",{\"1\":{\"80\":2,\"81\":2,\"82\":1}}],[\"catch语句\",{\"1\":{\"80\":1}}],[\"currentthread\",{\"1\":{\"80\":2,\"81\":1,\"82\":3}}],[\"c\",{\"1\":{\"80\":3,\"81\":4,\"104\":8,\"187\":1}}],[\"cqw\",{\"1\":{\"55\":2}}],[\"codinglabs\",{\"1\":{\"191\":1}}],[\"code\",{\"1\":{\"74\":1}}],[\"copy\",{\"1\":{\"158\":1}}],[\"cout\",{\"1\":{\"103\":1,\"104\":3}}],[\"col1\",{\"1\":{\"89\":4}}],[\"confluence\",{\"1\":{\"218\":1}}],[\"conflict\",{\"1\":{\"134\":2}}],[\"confirm\",{\"1\":{\"205\":1}}],[\"consumer实例数要与分区数量一致\",{\"1\":{\"208\":1}}],[\"consumer端按producer检测序号连续性\",{\"1\":{\"208\":1}}],[\"consumer对应queue\",{\"1\":{\"204\":1}}],[\"consumer\",{\"1\":{\"204\":6}}],[\"constantpool\",{\"1\":{\"62\":1}}],[\"constant\",{\"1\":{\"62\":2}}],[\"continue\",{\"1\":{\"137\":2}}],[\"container\",{\"1\":{\"34\":1}}],[\"concurrency\",{\"1\":{\"83\":1}}],[\"commit提交会有新的commit哈希值\",{\"1\":{\"136\":1}}],[\"commit提交节点愈清晰愈好\",{\"1\":{\"134\":1}}],[\"commit之间执行\",{\"1\":{\"122\":1}}],[\"commitid\",{\"1\":{\"115\":7,\"118\":5,\"139\":2,\"140\":3}}],[\"commit\",{\"1\":{\"111\":1,\"115\":4,\"119\":1,\"137\":4,\"140\":2,\"205\":1}}],[\"committed\",{\"1\":{\"111\":2}}],[\"compute\",{\"1\":{\"104\":2}}],[\"components\",{\"0\":{\"7\":1}}],[\"com\",{\"1\":{\"4\":1,\"48\":2,\"55\":6,\"62\":9,\"74\":5,\"95\":1,\"105\":2,\"129\":3,\"145\":1,\"158\":1,\"191\":5,\"218\":1}}],[\"clean\",{\"1\":{\"125\":2}}],[\"clone\",{\"1\":{\"29\":1}}],[\"classloader\",{\"2\":{\"76\":1}}],[\"class会发生什么\",{\"1\":{\"73\":1}}],[\"class时\",{\"1\":{\"73\":1}}],[\"class已被加载呢\",{\"1\":{\"73\":1}}],[\"class的话\",{\"1\":{\"73\":1}}],[\"class这样的由bootstrapclassloader加载的类\",{\"1\":{\"73\":1}}],[\"class或者object\",{\"1\":{\"73\":2}}],[\"class对象\",{\"1\":{\"73\":1}}],[\"class\",{\"1\":{\"2\":1,\"3\":1,\"24\":1,\"29\":1,\"30\":1,\"55\":1,\"62\":1,\"74\":1,\"80\":1,\"81\":1,\"82\":2,\"101\":1}}],[\"cn\",{\"1\":{\"25\":1,\"95\":2,\"105\":1,\"129\":1,\"191\":3}}],[\"write\",{\"1\":{\"153\":1,\"155\":2}}],[\"wait\",{\"1\":{\"80\":1,\"81\":1}}],[\"web\",{\"1\":{\"105\":1}}],[\"wechat\",{\"1\":{\"74\":1}}],[\"weixin\",{\"1\":{\"48\":1,\"55\":3,\"74\":1,\"95\":1,\"191\":1}}],[\"where\",{\"1\":{\"91\":1,\"92\":1,\"93\":1,\"94\":1,\"164\":1,\"173\":2}}],[\"what\",{\"1\":{\"62\":1,\"129\":2}}],[\"while\",{\"1\":{\"24\":5,\"81\":1,\"82\":2,\"101\":1,\"103\":1,\"104\":1}}],[\"workspace\",{\"0\":{\"125\":1},\"1\":{\"111\":3,\"115\":2,\"124\":1,\"125\":2,\"126\":3}}],[\"wo\",{\"1\":{\"25\":1}}],[\"www\",{\"1\":{\"4\":1,\"62\":4,\"74\":2,\"105\":2,\"145\":1,\"191\":3}}],[\"wiki\",{\"1\":{\"4\":1}}],[\"wikipedia\",{\"1\":{\"4\":1}}],[\"bplustree\",{\"1\":{\"191\":1}}],[\"b+树的每个结点都是1个innodb页\",{\"1\":{\"177\":1}}],[\"b+树的叶子节点之间使用双向链表进行连接\",{\"1\":{\"176\":1}}],[\"b+树索引\",{\"0\":{\"177\":1}}],[\"b+树将完整行记录存储在叶子节点\",{\"1\":{\"176\":1}}],[\"b+树与b树的不同\",{\"1\":{\"176\":1}}],[\"b树索引\",{\"0\":{\"176\":1}}],[\"buffer\",{\"1\":{\"175\":1}}],[\"block2\",{\"1\":{\"169\":1}}],[\"block1\",{\"1\":{\"169\":1}}],[\"block0\",{\"1\":{\"169\":1}}],[\"blogs\",{\"1\":{\"62\":1}}],[\"blog\",{\"1\":{\"36\":3,\"55\":1,\"74\":7,\"105\":1,\"191\":2}}],[\"broker\",{\"1\":{\"204\":1}}],[\"branchb\",{\"1\":{\"113\":2,\"119\":1}}],[\"brancha\",{\"1\":{\"113\":2,\"119\":1}}],[\"break\",{\"1\":{\"3\":2,\"81\":1,\"82\":2,\"104\":2}}],[\"between\",{\"1\":{\"129\":2,\"164\":1}}],[\"be\",{\"1\":{\"111\":1}}],[\"bv1xb4y1773f\",{\"1\":{\"145\":1}}],[\"bv16z4y1m7y1\",{\"1\":{\"105\":1}}],[\"bv1h8411e7hn\",{\"1\":{\"4\":1}}],[\"b\",{\"1\":{\"89\":2,\"104\":2,\"123\":4,\"187\":2}}],[\"books\",{\"1\":{\"218\":1}}],[\"book\",{\"1\":{\"83\":1}}],[\"boot\",{\"1\":{\"74\":2}}],[\"boolean\",{\"1\":{\"2\":2,\"3\":2,\"24\":1}}],[\"base\",{\"1\":{\"36\":1,\"101\":5,\"134\":2}}],[\"bash\",{\"1\":{\"35\":2}}],[\"baidulandingword~default\",{\"1\":{\"36\":1}}],[\"bfe1b\",{\"1\":{\"25\":1}}],[\"by等操作在索引列上使用也不例外\",{\"1\":{\"164\":1}}],[\"by的字段\",{\"1\":{\"88\":1}}],[\"by\",{\"1\":{\"25\":1,\"87\":1,\"88\":1,\"89\":4,\"91\":1,\"93\":2,\"94\":2,\"164\":10}}],[\"bits\",{\"1\":{\"104\":2}}],[\"biz=mzkwnzi0mzq2nq==\",{\"1\":{\"74\":1}}],[\"binary\",{\"1\":{\"164\":1}}],[\"binarysearch\",{\"1\":{\"24\":6}}],[\"bin\",{\"1\":{\"35\":2}}],[\"bilibili\",{\"1\":{\"4\":1,\"105\":1,\"145\":1}}],[\"的消息有序性\",{\"1\":{\"203\":1}}],[\"的ascii码\",{\"1\":{\"190\":1}}],[\"的速度很快\",{\"1\":{\"171\":1}}],[\"的资源消耗\",{\"1\":{\"163\":1}}],[\"的过程\",{\"1\":{\"156\":1}}],[\"的上下文切换\",{\"1\":{\"151\":1}}],[\"的公共分支\",{\"1\":{\"144\":1}}],[\"的提交描述信息\",{\"1\":{\"139\":1}}],[\"的描述信息\",{\"1\":{\"137\":1}}],[\"的差异\",{\"1\":{\"126\":2}}],[\"的新增\",{\"1\":{\"124\":1}}],[\"的效果是\",{\"1\":{\"118\":2}}],[\"的状态\",{\"1\":{\"115\":2}}],[\"的不同\",{\"1\":{\"115\":1}}],[\"的文件\",{\"1\":{\"124\":1}}],[\"的文件变更\",{\"1\":{\"114\":1}}],[\"的文件修改\",{\"1\":{\"111\":1}}],[\"的最新提交\",{\"1\":{\"113\":1}}],[\"的最后1条记录的id\",{\"1\":{\"92\":1}}],[\"的修改推送至\",{\"1\":{\"111\":1}}],[\"的修改保存至\",{\"1\":{\"111\":2}}],[\"的sql查询\",{\"1\":{\"94\":1}}],[\"的应用\",{\"1\":{\"92\":1}}],[\"的场景称为\",{\"1\":{\"87\":1}}],[\"的线程响应中断\",{\"1\":{\"82\":1}}],[\"的\",{\"1\":{\"82\":1,\"111\":1,\"119\":1,\"122\":1}}],[\"的作用\",{\"1\":{\"80\":1}}],[\"的方法会自动响应中断\",{\"1\":{\"81\":1}}],[\"的方法包括但不限于\",{\"1\":{\"80\":1}}],[\"的方法\",{\"1\":{\"79\":1,\"80\":1}}],[\"的方法逻辑以及\",{\"1\":{\"24\":1}}],[\"的一致性hash算法会让数据分布的更均匀\",{\"1\":{\"46\":1}}],[\"的一致性hash算法后\",{\"1\":{\"46\":1}}],[\"的样本集中\",{\"1\":{\"30\":1}}],[\"的正确性\",{\"1\":{\"29\":1}}],[\"的数组\",{\"1\":{\"29\":1}}],[\"的元素交换\",{\"1\":{\"29\":1}}],[\"的元素\",{\"1\":{\"29\":2,\"30\":3}}],[\"的1个\",{\"1\":{\"29\":1}}],[\"的真值命题p\",{\"1\":{\"24\":1}}],[\"的情况\",{\"1\":{\"24\":2}}],[\"的情况下\",{\"1\":{\"24\":1,\"94\":1,\"115\":1}}],[\"的右侧区间\",{\"1\":{\"24\":3}}],[\"的左侧区间\",{\"1\":{\"24\":5}}],[\"的概念\",{\"1\":{\"11\":1}}],[\"的质数与i相乘\",{\"1\":{\"3\":1}}],[\"的所有质数<br\",{\"1\":{\"3\":1}}],[\"的所有质数\",{\"1\":{\"2\":1}}],[\"将队列数置为1即可\",{\"1\":{\"218\":1}}],[\"将5这条消息复制到重试队列\",{\"1\":{\"217\":1}}],[\"将消息写入磁盘后\",{\"1\":{\"209\":1}}],[\"将有标记的commit提交合并\",{\"1\":{\"140\":1}}],[\"将暂存下的commit提交节点接到新的\",{\"1\":{\"134\":1}}],[\"将master分支的最新提交\",{\"1\":{\"134\":1}}],[\"将代码\",{\"1\":{\"115\":1,\"118\":1}}],[\"将head与commid之间的所有commit的文件更改\",{\"1\":{\"115\":3}}],[\"将head与commitid之间的所有commit提交的文件变动\",{\"1\":{\"115\":1}}],[\"将stage区文件变动暂存\",{\"1\":{\"114\":1}}],[\"将查询条件转移到\",{\"1\":{\"93\":1}}],[\"将前k个元素放入蓄水池\",{\"1\":{\"30\":1}}],[\"将样本集的\",{\"1\":{\"30\":1}}],[\"将1个\",{\"1\":{\"29\":1}}],[\"将\",{\"1\":{\"3\":1,\"46\":1,\"87\":1,\"113\":1,\"118\":1,\"126\":1,\"212\":1,\"217\":1}}],[\"将合数置为false\",{\"1\":{\"2\":1}}],[\">>\",{\"1\":{\"103\":4,\"104\":1}}],[\">>=\",{\"1\":{\"101\":1,\"104\":1}}],[\">\",{\"1\":{\"3\":2,\"24\":11,\"30\":3,\"80\":1,\"81\":1,\"82\":2,\"93\":1,\"123\":2,\"134\":1,\"164\":6,\"190\":2}}],[\">=\",{\"1\":{\"2\":2,\"24\":10,\"91\":1,\"92\":1,\"93\":1,\"104\":3}}],[\"又名线性筛\",{\"1\":{\"3\":1}}],[\"欧拉筛\",{\"0\":{\"3\":1},\"1\":{\"3\":2}}],[\"subscriber\",{\"1\":{\"204\":1}}],[\"subscribe\",{\"0\":{\"201\":1}}],[\"sum\",{\"1\":{\"82\":8,\"164\":1}}],[\"summary\",{\"1\":{\"10\":1,\"51\":1,\"65\":1}}],[\"sql字符串如何比较大小\",{\"0\":{\"190\":1}}],[\"sql数量类型\",{\"1\":{\"164\":1}}],[\"sql函数操作\",{\"1\":{\"164\":1}}],[\"sql优化的本质是减少机器的\",{\"1\":{\"163\":1}}],[\"sql优化原则\",{\"0\":{\"163\":1}}],[\"sql优化\",{\"0\":{\"162\":1,\"235\":1}}],[\"sql调优\",{\"0\":{\"161\":1},\"2\":{\"166\":1}}],[\"squash=\",{\"1\":{\"140\":1}}],[\"squash命令会将当前commit提交合并\",{\"1\":{\"136\":1}}],[\"squash\",{\"1\":{\"136\":1,\"140\":2}}],[\"sg\",{\"1\":{\"153\":1,\"156\":2}}],[\"share\",{\"1\":{\"105\":1}}],[\"shuffle\",{\"0\":{\"29\":1},\"1\":{\"29\":1}}],[\"since=\",{\"1\":{\"119\":1}}],[\"sizeof\",{\"1\":{\"104\":4}}],[\"similar\",{\"1\":{\"74\":1}}],[\"sleep\",{\"1\":{\"80\":4,\"81\":3,\"82\":4}}],[\"sleeptest\",{\"1\":{\"80\":1,\"81\":1}}],[\"sn=654ee37d8aaaa1415f30bdbf065de129\",{\"1\":{\"74\":1}}],[\"spring\",{\"1\":{\"74\":2}}],[\"space\",{\"1\":{\"62\":1}}],[\"specs\",{\"1\":{\"62\":2}}],[\"spm=1001\",{\"1\":{\"36\":1}}],[\"spm\",{\"1\":{\"4\":1,\"145\":1}}],[\"see\",{\"1\":{\"202\":1}}],[\"sendfile\",{\"0\":{\"155\":1},\"1\":{\"153\":2,\"155\":2,\"156\":1}}],[\"set>\",{\"1\":{\"103\":1,\"104\":1}}],[\"select\",{\"1\":{\"87\":1,\"89\":4,\"91\":1,\"92\":1,\"93\":3,\"94\":5,\"164\":1,\"173\":2}}],[\"se6\",{\"1\":{\"62\":1}}],[\"se17\",{\"1\":{\"62\":1}}],[\"segmentfault\",{\"1\":{\"62\":1,\"74\":1}}],[\"search\",{\"1\":{\"25\":1}}],[\"symbolic\",{\"1\":{\"55\":1}}],[\"system\",{\"0\":{\"9\":1},\"1\":{\"2\":1,\"3\":1,\"24\":7,\"30\":2,\"48\":1,\"80\":4,\"81\":2,\"82\":8,\"158\":1}}],[\"s\",{\"1\":{\"48\":1,\"55\":3,\"74\":1,\"95\":1,\"119\":1,\"191\":1}}],[\"sampled\",{\"1\":{\"30\":1}}],[\"sampling\",{\"0\":{\"30\":1}}],[\"swap\",{\"1\":{\"29\":2}}],[\"solving\",{\"1\":{\"191\":1}}],[\"solution\",{\"1\":{\"29\":2,\"101\":1,\"105\":1}}],[\"solutions\",{\"1\":{\"25\":1}}],[\"socket缓冲区\",{\"1\":{\"155\":1,\"156\":1}}],[\"soft\",{\"1\":{\"115\":5}}],[\"source=copy\",{\"1\":{\"105\":1}}],[\"source=sf\",{\"1\":{\"74\":1}}],[\"source=41\",{\"1\":{\"74\":1}}],[\"source=e9988d180a03a7b167558e2688c4362b\",{\"1\":{\"4\":1,\"105\":1}}],[\"source\",{\"1\":{\"74\":1}}],[\"sorted\",{\"1\":{\"25\":1}}],[\"std\",{\"1\":{\"103\":1,\"104\":1}}],[\"stash\",{\"1\":{\"114\":3,\"126\":2}}],[\"staged\",{\"1\":{\"124\":1,\"126\":3}}],[\"stage\",{\"0\":{\"126\":1},\"1\":{\"111\":3,\"114\":1,\"115\":4,\"118\":2,\"124\":2,\"126\":5,\"137\":1}}],[\"state\",{\"1\":{\"82\":2}}],[\"status\",{\"1\":{\"80\":1,\"82\":2,\"119\":1,\"124\":2}}],[\"static\",{\"1\":{\"2\":2,\"3\":2,\"24\":1,\"30\":2,\"80\":1,\"81\":1,\"82\":4}}],[\"start\",{\"1\":{\"80\":2,\"81\":2,\"82\":2}}],[\"stackoverflow\",{\"1\":{\"55\":1,\"62\":1,\"129\":2}}],[\"structure\",{\"1\":{\"62\":1}}],[\"stream\",{\"1\":{\"30\":6}}],[\"string\",{\"1\":{\"2\":1,\"3\":1,\"24\":1,\"30\":1,\"80\":1,\"81\":1,\"82\":4,\"164\":1}}],[\"判断\",{\"1\":{\"2\":1}}],[\"jksj\",{\"1\":{\"218\":1}}],[\"j++\",{\"1\":{\"104\":2}}],[\"jz16\",{\"1\":{\"101\":1}}],[\"juconcurrent\",{\"1\":{\"218\":1}}],[\"juejin\",{\"1\":{\"95\":1,\"129\":1,\"191\":3}}],[\"justloveyou\",{\"1\":{\"74\":1}}],[\"join\",{\"1\":{\"80\":1,\"81\":1,\"94\":1,\"164\":2}}],[\"jianshu\",{\"1\":{\"62\":2,\"74\":1}}],[\"jamesdbloom\",{\"1\":{\"55\":1}}],[\"javaguide\",{\"1\":{\"95\":1}}],[\"java语言中的\",{\"1\":{\"80\":1}}],[\"javase\",{\"1\":{\"62\":2}}],[\"javamagazine\",{\"1\":{\"62\":1}}],[\"java算法模版\",{\"1\":{\"22\":1}}],[\"java\",{\"0\":{\"8\":1},\"1\":{\"29\":1,\"30\":2,\"55\":2,\"62\":2,\"74\":1,\"83\":1},\"2\":{\"56\":1,\"63\":1,\"75\":1,\"84\":1}}],[\"jvm是如何处理处理的\",{\"1\":{\"73\":1}}],[\"jvm在加载一个类时\",{\"1\":{\"73\":1}}],[\"jvms\",{\"1\":{\"62\":4}}],[\"jvm常量池内存分布\",{\"0\":{\"60\":1}}],[\"jvm常量池种类\",{\"0\":{\"59\":1}}],[\"jvminternals\",{\"1\":{\"55\":1}}],[\"jvm\",{\"1\":{\"55\":5,\"62\":2},\"2\":{\"57\":1,\"64\":1,\"76\":1}}],[\"jvm基本原理分析\",{\"0\":{\"51\":1}}],[\"j\",{\"1\":{\"2\":6,\"29\":3,\"30\":6,\"104\":8}}],[\"注意两点比较和三点比较的区别\",{\"1\":{\"127\":1}}],[\"注意\",{\"1\":{\"119\":1,\"156\":1}}],[\"注意⚠️\",{\"1\":{\"24\":2}}],[\"注解\",{\"2\":{\"76\":1}}],[\"注\",{\"1\":{\"2\":1,\"24\":5,\"80\":1,\"87\":1,\"94\":1,\"101\":1,\"115\":2,\"118\":1,\"119\":1,\"122\":1,\"125\":1,\"127\":1,\"164\":1,\"204\":1,\"208\":1}}],[\"2pc\",{\"1\":{\"205\":1}}],[\"2次数据拷贝\",{\"1\":{\"156\":2}}],[\"2次上下文切换\",{\"1\":{\"155\":2,\"156\":1}}],[\"2次cpu拷贝\",{\"1\":{\"151\":1}}],[\"2次dma拷贝\",{\"1\":{\"155\":1,\"156\":1}}],[\"2次dma\",{\"1\":{\"151\":1,\"154\":1}}],[\"2种\",{\"1\":{\"137\":1}}],[\"2种越界情况\",{\"1\":{\"24\":2}}],[\"2101\",{\"1\":{\"36\":1}}],[\"235^v38^pc\",{\"1\":{\"36\":1}}],[\"2~default~baidujs\",{\"1\":{\"36\":1}}],[\"2017\",{\"1\":{\"191\":1}}],[\"2014\",{\"1\":{\"191\":1}}],[\"2000l\",{\"1\":{\"80\":1,\"81\":1,\"82\":2}}],[\"2020\",{\"1\":{\"74\":1}}],[\"2022\",{\"1\":{\"55\":1,\"119\":1}}],[\"2023\",{\"1\":{\"24\":1}}],[\"20\",{\"1\":{\"24\":1,\"94\":2,\"191\":1}}],[\"2\",{\"0\":{\"43\":1,\"44\":2,\"45\":1,\"46\":1,\"92\":1,\"103\":1,\"137\":1,\"140\":1,\"151\":1,\"152\":2,\"155\":1,\"171\":1,\"172\":2,\"173\":1,\"176\":1,\"181\":1,\"182\":1,\"183\":1,\"184\":2,\"188\":1,\"197\":1,\"198\":2,\"201\":1,\"218\":1},\"1\":{\"2\":1,\"3\":3,\"24\":21,\"29\":2,\"30\":1,\"82\":2,\"89\":2,\"104\":2,\"176\":1}}],[\"08\",{\"1\":{\"191\":1}}],[\"0a86966146b6https\",{\"1\":{\"74\":1}}],[\"01\",{\"1\":{\"62\":1,\"119\":1}}],[\"00\",{\"1\":{\"55\":1}}],[\"05\",{\"1\":{\"55\":1}}],[\"09\",{\"1\":{\"24\":1,\"55\":1,\"119\":1}}],[\"07\",{\"1\":{\"24\":1,\"74\":2}}],[\"0作用\",{\"1\":{\"2\":1}}],[\"0\",{\"1\":{\"2\":3,\"3\":3,\"4\":2,\"24\":13,\"29\":3,\"30\":4,\"36\":1,\"82\":10,\"89\":2,\"101\":4,\"103\":2,\"104\":19}}],[\"found\",{\"1\":{\"221\":1}}],[\"force\",{\"1\":{\"125\":1}}],[\"for\",{\"1\":{\"2\":2,\"3\":2,\"24\":5,\"29\":1,\"30\":3,\"82\":10,\"104\":7}}],[\"float\",{\"1\":{\"164\":1}}],[\"flag\",{\"1\":{\"2\":8,\"3\":8}}],[\"fetch\",{\"1\":{\"128\":1}}],[\"from\",{\"1\":{\"87\":1,\"89\":4,\"91\":1,\"92\":1,\"93\":3,\"94\":4,\"173\":2}}],[\"from=333\",{\"1\":{\"4\":1,\"145\":1}}],[\"frank909\",{\"1\":{\"74\":1}}],[\"faq\",{\"0\":{\"61\":1,\"73\":1,\"186\":1,\"216\":1},\"1\":{\"46\":1}}],[\"false\",{\"1\":{\"2\":2,\"3\":2,\"79\":1,\"80\":1}}],[\"f\",{\"1\":{\"24\":2,\"113\":1,\"125\":1}}],[\"fixup=\",{\"1\":{\"140\":1}}],[\"fixup\",{\"1\":{\"140\":2}}],[\"finally\",{\"1\":{\"82\":2}}],[\"final\",{\"1\":{\"82\":2}}],[\"findrightopen\",{\"1\":{\"24\":2}}],[\"findrightclosed\",{\"1\":{\"24\":2}}],[\"findleftopenans\",{\"1\":{\"24\":2}}],[\"findleftopen\",{\"1\":{\"24\":2}}],[\"findleftclosed\",{\"1\":{\"24\":2}}],[\"file\",{\"1\":{\"62\":1,\"125\":1}}],[\"fill\",{\"1\":{\"2\":1,\"3\":1}}],[\"fisher\",{\"0\":{\"29\":1}}],[\"1页磁盘块的数据项的数量为m\",{\"1\":{\"177\":1}}],[\"1次io操作\",{\"1\":{\"177\":1}}],[\"1次数据拷贝\",{\"1\":{\"155\":1}}],[\"1次cpu拷贝\",{\"1\":{\"154\":1,\"155\":1}}],[\"1c6ce75\",{\"1\":{\"139\":1}}],[\"1+\",{\"1\":{\"100\":1}}],[\"1190000023130736\",{\"1\":{\"74\":1}}],[\"1190000040922573\",{\"1\":{\"62\":1}}],[\"113788263https\",{\"1\":{\"74\":1}}],[\"1114576https\",{\"1\":{\"74\":1}}],[\"110\",{\"1\":{\"2\":1,\"3\":1}}],[\"100010\",{\"1\":{\"91\":1}}],[\"100001\",{\"1\":{\"91\":1}}],[\"1000010\",{\"1\":{\"89\":1}}],[\"1000000\",{\"1\":{\"87\":1,\"89\":1,\"93\":2}}],[\"100000\",{\"1\":{\"87\":2,\"94\":2}}],[\"1000l\",{\"1\":{\"81\":1,\"82\":2}}],[\"102983363https\",{\"1\":{\"74\":1}}],[\"10209952\",{\"1\":{\"62\":1}}],[\"107981268http\",{\"1\":{\"74\":1}}],[\"10\",{\"1\":{\"30\":1,\"55\":1,\"87\":3,\"89\":1,\"92\":1,\"93\":2,\"104\":4}}],[\"1个操作系统\",{\"1\":{\"177\":1}}],[\"1个b+树结点\",{\"1\":{\"177\":1}}],[\"1个数据页\",{\"1\":{\"171\":1}}],[\"1个叶子结点\",{\"1\":{\"171\":1}}],[\"1个\",{\"1\":{\"30\":1}}],[\"1种随机选法\",{\"1\":{\"29\":1}}],[\"1种越界情况\",{\"1\":{\"24\":3}}],[\"1987503\",{\"1\":{\"25\":1}}],[\"13\",{\"1\":{\"24\":3}}],[\"1时\",{\"1\":{\"24\":1}}],[\"120270845\",{\"1\":{\"191\":1}}],[\"120450561\",{\"1\":{\"62\":1}}],[\"124417972https\",{\"1\":{\"74\":1}}],[\"124961973\",{\"1\":{\"36\":2}}],[\"12\",{\"1\":{\"24\":1,\"191\":1}}],[\"1\",{\"0\":{\"43\":1,\"91\":1,\"100\":2,\"101\":1,\"103\":1,\"136\":1,\"139\":1,\"151\":1,\"154\":1,\"171\":1,\"175\":1,\"179\":1,\"180\":2,\"181\":1,\"183\":1,\"187\":1,\"197\":1,\"200\":1,\"217\":1},\"1\":{\"2\":3,\"3\":3,\"24\":80,\"29\":12,\"30\":7,\"36\":1,\"89\":1,\"93\":1,\"101\":6,\"103\":4,\"104\":13,\"158\":1,\"176\":1,\"204\":3,\"217\":1}}],[\"+=\",{\"1\":{\"2\":1,\"104\":4}}],[\"+\",{\"0\":{\"43\":1},\"1\":{\"2\":1,\"3\":1,\"24\":29,\"29\":1,\"30\":2,\"80\":2,\"82\":11,\"94\":1,\"104\":7,\"151\":1,\"153\":2,\"154\":2,\"155\":3,\"156\":2,\"164\":1,\"171\":1,\"211\":1}}],[\"ivdilhm94loh0b632fhjxw\",{\"1\":{\"191\":1}}],[\"ignored\",{\"1\":{\"124\":1}}],[\"isinterrupted\",{\"1\":{\"79\":1,\"80\":1,\"81\":2,\"82\":4}}],[\"is\",{\"1\":{\"58\":1,\"62\":1}}],[\"it\",{\"1\":{\"35\":2}}],[\"it参数后在命令最后加上\",{\"1\":{\"35\":1}}],[\"it参数\",{\"1\":{\"35\":1}}],[\"image\",{\"1\":{\"34\":1,\"35\":2}}],[\"import\",{\"1\":{\"30\":1}}],[\"i分之k\",{\"1\":{\"30\":1}}],[\"io次数取决于b+树的高度h\",{\"1\":{\"177\":1}}],[\"io等资源\",{\"1\":{\"164\":1}}],[\"io\",{\"1\":{\"25\":1,\"55\":2,\"62\":1,\"163\":1}}],[\"innodb和myisam引擎区别\",{\"0\":{\"185\":1}}],[\"innodb的辅助索引data域存储相应记录主键的值而不是地址\",{\"1\":{\"185\":1}}],[\"innodb的辅助索引\",{\"1\":{\"184\":1}}],[\"innodb要求\",{\"1\":{\"182\":1}}],[\"innodb引擎\",{\"0\":{\"182\":1},\"1\":{\"185\":1}}],[\"innodb\",{\"1\":{\"175\":1,\"191\":1}}],[\"innodb会监控对表上辅助索引的查找\",{\"1\":{\"175\":1}}],[\"innodb会根据表的使用情况自动为表生成\",{\"1\":{\"175\":1}}],[\"innodb中支持的hash索引是\",{\"1\":{\"175\":1}}],[\"innodb中b+树索引可以分为聚集索引\",{\"1\":{\"171\":1}}],[\"inner\",{\"1\":{\"94\":1}}],[\"in关键字后的元素个数不要太多\",{\"1\":{\"164\":1}}],[\"index\",{\"1\":{\"111\":2,\"172\":1,\"173\":1,\"191\":2}}],[\"index=3\",{\"1\":{\"36\":1}}],[\"include<queue>\",{\"1\":{\"104\":1}}],[\"include<map>\",{\"1\":{\"103\":1,\"104\":1}}],[\"include<limits>\",{\"1\":{\"103\":1,\"104\":1}}],[\"include<vector>\",{\"1\":{\"103\":1,\"104\":1}}],[\"include<unordered\",{\"1\":{\"103\":2,\"104\":2}}],[\"include<string\",{\"1\":{\"103\":1,\"104\":1}}],[\"include<string>\",{\"1\":{\"103\":1,\"104\":1}}],[\"include<set>\",{\"1\":{\"103\":1,\"104\":1}}],[\"include<algorithm>\",{\"1\":{\"103\":1,\"104\":1}}],[\"include<climits>\",{\"1\":{\"103\":1,\"104\":1}}],[\"include<cstdio>\",{\"1\":{\"103\":1,\"104\":1}}],[\"include<cmath>\",{\"1\":{\"103\":1,\"104\":1}}],[\"include<iostream>\",{\"1\":{\"103\":1,\"104\":1}}],[\"in\",{\"1\":{\"25\":1,\"55\":1,\"129\":2,\"164\":1}}],[\"introduction\",{\"1\":{\"218\":1}}],[\"integer\",{\"1\":{\"82\":4}}],[\"interrupttest2\",{\"1\":{\"82\":2}}],[\"interruptedexception异常\",{\"1\":{\"80\":4,\"81\":1}}],[\"interruptedexception\",{\"1\":{\"80\":2,\"81\":4,\"82\":4}}],[\"interrupted\",{\"1\":{\"79\":2,\"81\":1,\"82\":1}}],[\"interrupt\",{\"1\":{\"79\":1,\"80\":6,\"81\":3,\"82\":4}}],[\"interview\",{\"1\":{\"55\":1}}],[\"int\",{\"1\":{\"2\":3,\"3\":3,\"24\":52,\"29\":11,\"30\":12,\"82\":12,\"101\":3,\"103\":1,\"104\":26,\"164\":2,\"187\":3}}],[\"id范围\",{\"1\":{\"91\":1}}],[\"id的连续性\",{\"1\":{\"91\":1}}],[\"idx=1\",{\"1\":{\"74\":1}}],[\"idx\",{\"1\":{\"24\":15,\"173\":2}}],[\"id\",{\"1\":{\"4\":1,\"87\":1,\"89\":8,\"91\":3,\"92\":2,\"93\":5,\"94\":9,\"145\":1,\"177\":2}}],[\"i的最小质因数\",{\"1\":{\"3\":1}}],[\"if\",{\"1\":{\"2\":2,\"3\":3,\"24\":20,\"30\":1,\"81\":1,\"82\":1,\"101\":1,\"103\":1,\"104\":4}}],[\"i++\",{\"1\":{\"2\":1,\"3\":1,\"29\":1,\"30\":2,\"82\":6,\"104\":4}}],[\"i为质数\",{\"1\":{\"2\":1,\"3\":1}}],[\"i\",{\"1\":{\"2\":9,\"3\":8,\"29\":11,\"30\":16,\"55\":1,\"82\":23,\"104\":29,\"136\":1,\"139\":1,\"140\":1}}],[\"===\",{\"1\":{\"24\":4}}],[\"==\",{\"1\":{\"3\":1,\"24\":36,\"101\":1,\"103\":1,\"104\":2}}],[\"=\",{\"1\":{\"2\":9,\"3\":9,\"24\":47,\"29\":10,\"30\":10,\"80\":2,\"81\":2,\"82\":20,\"94\":2,\"101\":5,\"103\":5,\"104\":24,\"164\":2,\"173\":2,\"211\":1}}],[\"质数\",{\"1\":{\"3\":1}}],[\"质数表\",{\"1\":{\"2\":1,\"3\":1}}],[\"质数筛\",{\"0\":{\"1\":1},\"2\":{\"6\":1}}],[\"luogu\",{\"1\":{\"105\":1}}],[\"l++\",{\"1\":{\"82\":1}}],[\"last\",{\"0\":{\"92\":1},\"1\":{\"92\":1}}],[\"launchedurlclassloader\",{\"0\":{\"72\":1}}],[\"labuladong\",{\"1\":{\"25\":1}}],[\"long\",{\"1\":{\"103\":4}}],[\"log三点比较没有前后顺序之分\",{\"1\":{\"123\":1}}],[\"log三点\",{\"1\":{\"121\":1}}],[\"log\",{\"0\":{\"121\":1},\"1\":{\"115\":1,\"119\":7,\"123\":2,\"134\":1}}],[\"log10\",{\"1\":{\"104\":1}}],[\"log2n​\",{\"1\":{\"100\":2}}],[\"logn\",{\"1\":{\"2\":1}}],[\"locks\",{\"1\":{\"191\":1}}],[\"lockinterruptibly\",{\"1\":{\"82\":3}}],[\"lock\",{\"1\":{\"82\":10,\"191\":1}}],[\"loader\",{\"1\":{\"74\":2}}],[\"loading\",{\"1\":{\"55\":1}}],[\"l3wszgsjd58yibs3ld1wdw\",{\"1\":{\"55\":1}}],[\"lc382\",{\"1\":{\"30\":1}}],[\"lc384\",{\"1\":{\"29\":1}}],[\"lc题源\",{\"1\":{\"29\":1,\"30\":1}}],[\"lihua\",{\"1\":{\"173\":2}}],[\"like\",{\"1\":{\"164\":1}}],[\"limit\",{\"1\":{\"87\":6,\"89\":4,\"92\":1,\"93\":3,\"94\":2}}],[\"list\",{\"1\":{\"82\":14}}],[\"list<thread>\",{\"1\":{\"82\":2}}],[\"list<integer>\",{\"1\":{\"2\":3,\"3\":3}}],[\"ling\",{\"1\":{\"25\":1}}],[\"least\",{\"1\":{\"210\":1,\"211\":1}}],[\"learning\",{\"1\":{\"74\":1}}],[\"len\",{\"1\":{\"104\":5}}],[\"lenb\",{\"1\":{\"104\":3}}],[\"lena\",{\"1\":{\"104\":8}}],[\"lenarr\",{\"1\":{\"104\":9}}],[\"lennum\",{\"1\":{\"104\":3}}],[\"lenres\",{\"1\":{\"104\":4}}],[\"length\",{\"1\":{\"24\":21,\"29\":2,\"30\":1}}],[\"le\",{\"1\":{\"25\":1}}],[\"leetcode\",{\"1\":{\"25\":1}}],[\"left逐渐逼近\",{\"1\":{\"24\":2}}],[\"left\",{\"1\":{\"24\":82}}],[\"l\",{\"1\":{\"3\":4,\"48\":1,\"82\":2}}],[\"l是i的最小质因数\",{\"1\":{\"3\":1}}],[\"phone\",{\"1\":{\"173\":2}}],[\"phase\",{\"1\":{\"55\":1,\"205\":1}}],[\"pk\",{\"1\":{\"171\":3,\"173\":1,\"184\":1,\"185\":1}}],[\"python\",{\"1\":{\"163\":1,\"164\":3}}],[\"ps\",{\"1\":{\"123\":1}}],[\"p1226\",{\"1\":{\"105\":1}}],[\"p1824\",{\"0\":{\"13\":1}}],[\"performance\",{\"1\":{\"95\":1}}],[\"partition\",{\"1\":{\"203\":1,\"204\":1,\"208\":1,\"214\":1}}],[\"param\",{\"1\":{\"2\":1,\"3\":1,\"24\":13}}],[\"pattern\",{\"0\":{\"201\":1}}],[\"path>\",{\"1\":{\"126\":1}}],[\"page\",{\"1\":{\"169\":5,\"177\":1}}],[\"pagesize\",{\"1\":{\"87\":1}}],[\"pagination\",{\"1\":{\"95\":1}}],[\"p\",{\"1\":{\"62\":2,\"74\":1,\"83\":1,\"104\":6,\"191\":1}}],[\"publisher\",{\"1\":{\"204\":1}}],[\"publish\",{\"0\":{\"201\":1}}],[\"public\",{\"1\":{\"2\":2,\"3\":2,\"24\":7,\"29\":3,\"30\":3,\"80\":2,\"81\":2,\"82\":4,\"101\":1}}],[\"pulsar\",{\"1\":{\"198\":1}}],[\"pull\",{\"1\":{\"134\":2}}],[\"push\",{\"1\":{\"111\":1,\"113\":2}}],[\"purpose\",{\"1\":{\"62\":1}}],[\"poc\",{\"1\":{\"191\":1}}],[\"pop\",{\"1\":{\"114\":1}}],[\"pow\",{\"1\":{\"101\":4}}],[\"power\",{\"1\":{\"101\":2}}],[\"pool\",{\"1\":{\"62\":2,\"175\":1}}],[\"post\",{\"1\":{\"62\":1,\"95\":1,\"129\":1,\"191\":3}}],[\"pdai\",{\"1\":{\"55\":1}}],[\"pc\",{\"1\":{\"36\":1}}],[\"producer\",{\"1\":{\"204\":1}}],[\"problems\",{\"1\":{\"25\":1}}],[\"prune\",{\"1\":{\"128\":2}}],[\"pretty=\",{\"1\":{\"119\":1}}],[\"printstacktrace\",{\"1\":{\"81\":4}}],[\"print\",{\"1\":{\"30\":1}}],[\"println\",{\"1\":{\"2\":1,\"3\":1,\"24\":7,\"30\":1,\"80\":4,\"81\":2,\"82\":8}}],[\"primes\",{\"1\":{\"2\":5,\"3\":6}}],[\"private\",{\"1\":{\"2\":1,\"3\":1,\"24\":1,\"29\":2,\"82\":2}}],[\"p3853\",{\"0\":{\"15\":1}}],[\"p2678\",{\"0\":{\"14\":1}}],[\"p2440\",{\"0\":{\"12\":1}}],[\"number\",{\"1\":{\"173\":1}}],[\"number列值不在\",{\"1\":{\"173\":1}}],[\"nums\",{\"1\":{\"29\":6,\"104\":2}}],[\"null\",{\"1\":{\"164\":1}}],[\"nginx\",{\"1\":{\"157\":1}}],[\"not\",{\"1\":{\"221\":1}}],[\"no\",{\"1\":{\"119\":1}}],[\"none\",{\"1\":{\"36\":1}}],[\"namespace\",{\"1\":{\"103\":1,\"104\":1}}],[\"name\",{\"1\":{\"82\":5,\"119\":1,\"173\":3,\"177\":1}}],[\"name=\",{\"1\":{\"34\":1,\"35\":2}}],[\"n7zq0zyhf\",{\"1\":{\"48\":1}}],[\"network\",{\"1\":{\"48\":1,\"158\":1}}],[\"net\",{\"1\":{\"36\":1,\"74\":8,\"191\":1}}],[\"nextint\",{\"1\":{\"29\":1,\"30\":1}}],[\"new\",{\"1\":{\"2\":2,\"3\":2,\"24\":5,\"29\":1,\"30\":2,\"80\":3,\"81\":3,\"82\":7}}],[\"n个无重复元素\",{\"1\":{\"29\":1}}],[\"n\",{\"1\":{\"2\":6,\"3\":7,\"29\":16,\"30\":3,\"103\":6,\"116\":1,\"118\":5,\"125\":2,\"204\":1,\"217\":1}}],[\"nlog\",{\"1\":{\"2\":1}}],[\"返回但\",{\"1\":{\"217\":1}}],[\"返回线程\",{\"1\":{\"79\":2}}],[\"返回left\",{\"1\":{\"24\":1}}],[\"返回left时\",{\"1\":{\"24\":2}}],[\"返回值较为特殊\",{\"1\":{\"24\":1}}],[\"返回元素小\",{\"1\":{\"24\":2}}],[\"返回元素最大\",{\"1\":{\"24\":4}}],[\"返回元素最小\",{\"1\":{\"24\":4}}],[\"返回目标元素最大\",{\"1\":{\"24\":2}}],[\"返回目标元素最小\",{\"1\":{\"24\":1}}],[\"返回目标元素\",{\"1\":{\"24\":2}}],[\"返回\",{\"1\":{\"2\":1,\"3\":1,\"24\":17}}],[\"apache\",{\"1\":{\"218\":2}}],[\"at\",{\"1\":{\"210\":2,\"211\":1}}],[\"age复合索引中\",{\"1\":{\"173\":1}}],[\"age\",{\"1\":{\"173\":5,\"177\":2}}],[\"amend\",{\"1\":{\"137\":6}}],[\"a105=a1∗a8∗a32∗a64\",{\"1\":{\"99\":1}}],[\"as\",{\"1\":{\"94\":4}}],[\"aneasystone\",{\"1\":{\"191\":1}}],[\"an\",{\"1\":{\"119\":1}}],[\"and\",{\"1\":{\"91\":1,\"129\":2,\"164\":1}}],[\"answer\",{\"1\":{\"62\":2}}],[\"ans\",{\"1\":{\"24\":5,\"29\":5,\"46\":1,\"82\":4,\"187\":1,\"188\":1,\"189\":1,\"190\":1}}],[\"ack\",{\"1\":{\"217\":2}}],[\"activemq\",{\"1\":{\"198\":1}}],[\"acquiring\",{\"1\":{\"82\":2}}],[\"acesifter\",{\"1\":{\"2\":3}}],[\"alt\",{\"1\":{\"154\":1}}],[\"aliyun\",{\"1\":{\"74\":1}}],[\"algo\",{\"1\":{\"25\":1}}],[\"algorithms\",{\"1\":{\"191\":1}}],[\"algorithm\",{\"0\":{\"0\":1},\"2\":{\"5\":1,\"20\":1,\"26\":1,\"31\":1,\"106\":1}}],[\"a\",{\"1\":{\"58\":1,\"62\":1,\"74\":1,\"89\":2,\"103\":6,\"104\":10,\"123\":4,\"187\":2}}],[\"autosquash\",{\"1\":{\"140\":2}}],[\"author\",{\"1\":{\"24\":1}}],[\"auuh\",{\"1\":{\"25\":1}}],[\"archives\",{\"1\":{\"191\":1}}],[\"are\",{\"1\":{\"129\":2}}],[\"articles\",{\"1\":{\"191\":1}}],[\"article\",{\"1\":{\"36\":1,\"74\":9,\"191\":1}}],[\"arr\",{\"1\":{\"24\":61,\"29\":5,\"104\":10}}],[\"array\",{\"1\":{\"25\":1}}],[\"arrays\",{\"1\":{\"2\":1,\"3\":1}}],[\"arraylist<>\",{\"1\":{\"2\":1,\"3\":1,\"82\":2}}],[\"args\",{\"1\":{\"2\":1,\"3\":1,\"24\":1,\"30\":1,\"80\":1,\"81\":1,\"82\":2}}],[\"add\",{\"1\":{\"2\":1,\"3\":1,\"82\":2,\"111\":1,\"115\":5,\"124\":1,\"137\":1}}],[\"optimization\",{\"1\":{\"95\":1,\"191\":1}}],[\"once\",{\"1\":{\"210\":3,\"211\":2}}],[\"on\",{\"1\":{\"94\":1,\"173\":1}}],[\"oneline\",{\"1\":{\"134\":1}}],[\"one\",{\"1\":{\"58\":1}}],[\"oom\",{\"1\":{\"87\":1}}],[\"occurs\",{\"1\":{\"80\":1}}],[\"offset\",{\"1\":{\"87\":6,\"204\":1}}],[\"offer\",{\"1\":{\"80\":1}}],[\"of\",{\"1\":{\"62\":1,\"191\":1}}],[\"or\",{\"1\":{\"164\":1,\"205\":1}}],[\"origin\",{\"1\":{\"111\":1,\"113\":1,\"127\":1,\"128\":1}}],[\"order\",{\"1\":{\"87\":2,\"88\":1,\"89\":8,\"91\":2,\"92\":1,\"93\":5,\"94\":6,\"164\":6}}],[\"oracle\",{\"1\":{\"62\":3}}],[\"org\",{\"1\":{\"4\":1,\"191\":1,\"218\":2}}],[\"os\",{\"1\":{\"48\":1,\"158\":1},\"2\":{\"160\":1}}],[\"out\",{\"1\":{\"2\":1,\"3\":1,\"24\":7,\"30\":2,\"80\":4,\"81\":2,\"82\":8}}],[\"o\",{\"1\":{\"2\":1,\"3\":1,\"30\":1,\"82\":1,\"100\":1}}],[\"埃拉托斯特尼筛法\",{\"1\":{\"2\":2,\"4\":1}}],[\"埃氏筛\",{\"0\":{\"2\":1},\"1\":{\"2\":1}}],[\"即可\",{\"1\":{\"217\":1}}],[\"即可保证消息不丢失\",{\"1\":{\"209\":1}}],[\"即1次磁盘io操作不光会读取请求的目标数据块\",{\"1\":{\"169\":1}}],[\"即使group\",{\"1\":{\"164\":1}}],[\"即减少\",{\"1\":{\"152\":1}}],[\"即在原分支最新提交的基础上生成一个新commit\",{\"1\":{\"118\":1}}],[\"即在电脑里能看到的代码库目录\",{\"1\":{\"111\":1}}],[\"即在对系统做扩容或者缩容时\",{\"1\":{\"44\":1}}],[\"即若当前线程被中断\",{\"1\":{\"79\":1}}],[\"即完成\",{\"1\":{\"29\":1}}],[\"即\",{\"1\":{\"2\":1,\"92\":1,\"115\":2,\"123\":1,\"177\":1}}],[\"给出2种低时间复杂度快速筛选质数的方法\",{\"1\":{\"1\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n,id:o}})=>{const u=bt[s];e==="suggest"?self.postMessage([e,o,tt(t,u,n)]):e==="search"?self.postMessage([e,o,Z(t,u,n)]):self.postMessage({suggestions:[e,o,tt(t,u,n)],results:[e,o,Z(t,u,n)]})};
//# sourceMappingURL=index.js.map
